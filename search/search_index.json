{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#xqute","title":"xqute","text":"<p>A job management system for Python, designed to simplify job scheduling and execution with support for multiple schedulers and plugins.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Written in async for high performance</li> <li>Plugin system for extensibility</li> <li>Scheduler adaptor for various backends</li> <li>Job retrying and pipeline halting on failure</li> <li>Support for cloud-based working directories</li> <li>Built-in support for Google Batch Jobs, Slurm, SGE, SSH, and container schedulers</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install xqute\n</code></pre>"},{"location":"#a-toy-example","title":"A Toy Example","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    # Initialize Xqute with 3 jobs allowed to run concurrently\n    xqute = Xqute(forks=3)\n    for _ in range(10):\n        await xqute.feed(['sleep', '1'])\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#daemon-mode-keep-feeding","title":"Daemon Mode (Keep Feeding)","text":"<p>You can also run Xqute in daemon mode, where jobs can be added continuously after starting:</p> <pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(forks=3)\n\n    # Add initial job\n    await xqute.feed(['echo', 'Job 1'])\n\n    # Start in keep_feeding mode (returns immediately)\n    await xqute.run_until_complete(keep_feeding=True)\n\n    # Continue adding jobs dynamically\n    for i in range(2, 11):\n        await xqute.feed(['sleep', '1'])\n        await asyncio.sleep(0.1)  # Jobs can be added over time\n\n    # Signal completion and wait for all jobs to finish\n    await xqute.stop_feeding()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>Tip: Use <code>xqute.is_feeding()</code> to check if you need to call <code>stop_feeding()</code>.</p> <p></p>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>Full API documentation is available at: https://pwwang.github.io/xqute/</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#xqute-object","title":"Xqute Object","text":"<p>An <code>Xqute</code> object is initialized as follows:</p> <pre><code>xqute = Xqute(...)\n</code></pre> <p>Available arguments are:</p> <ul> <li><code>scheduler</code>: The scheduler class or name (default: <code>local</code>)</li> <li><code>plugins</code>: Plugins to enable/disable for this session</li> <li><code>workdir</code>: Directory for job metadata (default: <code>./.xqute/</code>)</li> <li><code>forks</code>: Number of jobs allowed to run concurrently</li> <li><code>error_strategy</code>: Strategy for handling errors (e.g., <code>halt</code>, <code>retry</code>)</li> <li><code>num_retries</code>: Maximum number of retries when <code>error_strategy</code> is set to <code>retry</code></li> <li><code>submission_batch</code>: Number of jobs to submit in a batch</li> <li><code>scheduler_opts</code>: Additional keyword arguments for the scheduler</li> <li><code>jobname_prefix</code>: Prefix for job names</li> <li><code>recheck_interval</code>: Interval to recheck job status. The actual interval will be <code>&lt;recheck_interval&gt; * &lt;xqute.defaults.SLEEP_INTERVAL_POLLING_JOBS&gt;</code></li> </ul> <p>Note: The producer must be initialized within an event loop.</p> <p>To add a job to the queue:</p> <pre><code>await xqute.feed(['echo', 'Hello, World!'])\n</code></pre> <p>To run until all jobs complete:</p> <pre><code># Traditional mode - wait for all jobs to complete\nawait xqute.run_until_complete()\n\n# Or daemon mode - add jobs continuously\nawait xqute.run_until_complete(keep_feeding=True)\n# ... add more jobs ...\nawait xqute.stop_feeding()  # Signal completion and wait\n</code></pre>"},{"location":"#using-sge-scheduler","title":"Using SGE Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='sge',\n    forks=100,\n    scheduler_opts={\n        'qsub': '/path/to/qsub',\n        'qdel': '/path/to/qdel',\n        'qstat': '/path/to/qstat',\n        'q': '1-day',  # or qsub_q='1-day'\n    }\n)\n</code></pre> <p>Keyword arguments starting with <code>sge_</code> are interpreted as <code>qsub</code> options. For example:</p> <p><pre><code>'l': ['h_vmem=2G', 'gpu=1']\n</code></pre> will be expanded in the job script as:</p> <pre><code>#$ -l h_vmem=2G\n#$ -l gpu=1\n</code></pre>"},{"location":"#using-slurm-scheduler","title":"Using Slurm Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='slurm',\n    forks=100,\n    scheduler_opts={\n        'sbatch': '/path/to/sbatch',\n        'scancel': '/path/to/scancel',\n        'squeue': '/path/to/squeue',\n        'partition': '1-day',\n        'time': '01:00:00',\n    }\n)\n</code></pre>"},{"location":"#using-ssh-scheduler","title":"Using SSH Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='ssh',\n    forks=100,\n    scheduler_opts={\n        'ssh': '/path/to/ssh',\n        'servers': {\n            'server1': {\n                'user': 'username',\n                'port': 22,\n                'keyfile': '/path/to/keyfile',\n                'ctrl_persist': 600,\n                'ctrl_dir': '/tmp',\n            }\n        }\n    }\n)\n</code></pre> <p>Note: SSH servers must share the same filesystem and use keyfile authentication.</p>"},{"location":"#using-google-batch-jobs-scheduler","title":"Using Google Batch Jobs Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='gbatch',\n    forks=100,\n    scheduler_opts={\n        'project': 'your-gcp-project-id',\n        'location': 'us-central1',\n        'gcloud': '/path/to/gcloud',\n        'taskGroups': [ ... ],\n    }\n)\n</code></pre>"},{"location":"#using-container-scheduler","title":"Using Container Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='container',\n    forks=100,\n    scheduler_opts={\n        'image': 'docker://bash:latest',\n        'entrypoint': '/usr/local/bin/bash',\n        'bin': 'docker',\n        'volumes': '/host/path:/container/path',\n        'envs': {'MY_ENV_VAR': 'value'},\n        'remove': True,\n        'bin_args': ['--hostname', 'xqute-container'],\n    }\n)\n</code></pre>"},{"location":"#plugins","title":"Plugins","text":"<p>To create a plugin for <code>xqute</code>, implement the following hooks:</p> <ul> <li><code>def on_init(scheduler)</code>: Called after the scheduler is initialized</li> <li><code>def on_shutdown(scheduler, sig)</code>: Called when the scheduler shuts down</li> <li><code>async def on_job_init(scheduler, job)</code>: Called when a job is initialized</li> <li><code>async def on_job_queued(scheduler, job)</code>: Called when a job is queued</li> <li><code>async def on_job_submitted(scheduler, job)</code>: Called when a job is submitted</li> <li><code>async def on_job_started(scheduler, job)</code>: Called when a job starts running</li> <li><code>async def on_job_polling(scheduler, job, counter)</code>: Called during job status polling</li> <li><code>async def on_job_killing(scheduler, job)</code>: Called when a job is being killed</li> <li><code>async def on_job_killed(scheduler, job)</code>: Called when a job is killed</li> <li><code>async def on_job_failed(scheduler, job)</code>: Called when a job fails</li> <li><code>async def on_job_succeeded(scheduler, job)</code>: Called when a job succeeds</li> <li><code>def on_jobcmd_init(scheduler, job) -&gt; str</code>: Called during job command initialization</li> <li><code>def on_jobcmd_prep(scheduler, job) -&gt; str</code>: Called before the job command runs</li> <li><code>def on_jobcmd_end(scheduler, job) -&gt; str</code>: Called after the job command completes</li> </ul> <p>To implement a hook, use the <code>simplug</code> plugin manager:</p> <pre><code>from xqute import simplug as pm\n\n@pm.impl\ndef on_init(scheduler):\n    ...\n</code></pre>"},{"location":"#implementing-a-scheduler","title":"Implementing a Scheduler","text":"<p>To create a custom scheduler, subclass the <code>Scheduler</code> abstract class and implement the following methods:</p> <pre><code>from xqute import Scheduler\n\nclass MyScheduler(Scheduler):\n    name = 'mysched'\n\n    async def submit_job(self, job):\n        \"\"\"Submit a job and return its unique ID.\"\"\"\n\n    async def kill_job(self, job):\n        \"\"\"Kill a job.\"\"\"\n\n    async def job_is_running(self, job):\n        \"\"\"Check if a job is running.\"\"\"\n</code></pre>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#advanced-usage","title":"Advanced Usage","text":"<p>Advanced patterns and customization for power users.</p>"},{"location":"advanced/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Custom Schedulers</li> <li>Job Dependencies</li> <li>Job Arrays</li> <li>Progress Tracking</li> <li>Streaming Output</li> <li>Custom Error Handling</li> <li>Job Templates</li> <li>Batch Processing</li> <li>Integration with Other Tools</li> <li>Performance Optimization</li> </ul>"},{"location":"advanced/#custom-schedulers","title":"Custom Schedulers","text":""},{"location":"advanced/#creating-a-custom-scheduler","title":"Creating a Custom Scheduler","text":"<p>Implement the <code>Scheduler</code> abstract class:</p> <pre><code>from xqute import Scheduler\n\nclass CustomScheduler(Scheduler):\n    \"\"\"Custom scheduler implementation\"\"\"\n    name = 'custom'\n\n    async def submit_job(self, job):\n        \"\"\"Submit a job and return its unique ID\"\"\"\n        # Your submission logic here\n        job_id = self._submit_to_custom_system(job)\n        return job_id\n\n    async def kill_job(self, job):\n        \"\"\"Kill a job\"\"\"\n        jid = await job.get_jid()\n        # Your kill logic here\n        self._kill_in_custom_system(jid)\n\n    async def job_is_running(self, job):\n        \"\"\"Check if a job is running\"\"\"\n        jid = await job.get_jid()\n        # Your status check logic here\n        return self._check_status(jid) == 'running'\n</code></pre>"},{"location":"advanced/#using-custom-scheduler","title":"Using Custom Scheduler","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler=CustomScheduler,\n    forks=10,\n    scheduler_opts={\n        'custom_param': 'value',\n    }\n)\n\nawait xqute.feed(['echo', 'Hello'])\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"advanced/#advanced-custom-scheduler-example","title":"Advanced Custom Scheduler Example","text":"<pre><code>from xqute import Scheduler\nfrom typing import Dict, Any\nimport subprocess\n\nclass MyClusterScheduler(Scheduler):\n    \"\"\"Scheduler for custom cluster\"\"\"\n\n    name = 'mycluster'\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.jobs: Dict[str, Any] = {}\n\n    async def submit_job(self, job):\n        \"\"\"Submit job to custom cluster\"\"\"\n        cmd = self._build_submit_command(job)\n        proc = await asyncio.create_subprocess_exec(\n            *cmd,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        stdout, stderr = await proc.communicate()\n\n        if proc.returncode != 0:\n            raise RuntimeError(f\"Submission failed: {stderr.decode()}\")\n\n        job_id = stdout.decode().strip()\n        self.jobs[job_id] = {\n            'job': job,\n            'status': 'submitted',\n        }\n        return job_id\n\n    async def kill_job(self, job):\n        \"\"\"Kill job\"\"\"\n        jid = await job.get_jid()\n        cmd = ['mycluster-kill', jid]\n        await asyncio.create_subprocess_exec(*cmd)\n        if jid in self.jobs:\n            del self.jobs[jid]\n\n    async def job_is_running(self, job):\n        \"\"\"Check if job is running\"\"\"\n        jid = await job.get_jid()\n        if jid not in self.jobs:\n            return False\n\n        cmd = ['mycluster-status', jid]\n        proc = await asyncio.create_subprocess_exec(\n            *cmd,\n            stdout=asyncio.subprocess.PIPE,\n        )\n        stdout, _ = await proc.communicate()\n        status = stdout.decode().strip()\n\n        self.jobs[jid]['status'] = status\n        return status == 'running'\n\n    def _build_submit_command(self, job):\n        \"\"\"Build submission command\"\"\"\n        return [\n            'mycluster-submit',\n            '--job-name', f'{self.jobname_prefix}-{job.index}',\n            '--output', str(job.stdout_file),\n            '--error', str(job.stderr_file),\n        ]\n</code></pre>"},{"location":"advanced/#job-dependencies","title":"Job Dependencies","text":""},{"location":"advanced/#sequential-dependencies","title":"Sequential Dependencies","text":"<p>Run jobs in order using daemon mode:</p> <pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def run_with_dependencies():\n    xqute = Xqute(forks=1)  # Single fork for sequential execution\n\n    await xqute.run_until_complete(keep_feeding=True)\n\n    # Job 1\n    await xqute.feed(['prepare_data.sh'])\n    await xqute.run_until_complete()\n\n    # Job 2 (depends on Job 1)\n    await xqute.feed(['process_data.sh'])\n    await xqute.run_until_complete()\n\n    # Job 3 (depends on Job 2)\n    await xqute.feed(['finalize.sh'])\n\n    await xqute.stop_feeding()\n</code></pre>"},{"location":"advanced/#dependency-tracking-with-plugins","title":"Dependency Tracking with Plugins","text":"<pre><code>from xqute import simplug as pm\n\ndependencies = {}  # job_index -&gt; [parent_indices]\n\n@pm.impl\nasync def on_job_queued(scheduler, job):\n    \"\"\"Check if dependencies are satisfied\"\"\"\n    if job.index not in dependencies:\n        return\n\n    deps = dependencies[job.index]\n    for dep_idx in deps:\n        dep_job = scheduler.xqute.jobs[dep_idx]\n        status = await dep_job.get_status()\n        if status != 4:  # Not FINISHED\n            # Skip for now, will be retried later\n            return False\n</code></pre>"},{"location":"advanced/#job-arrays","title":"Job Arrays","text":""},{"location":"advanced/#simple-job-array","title":"Simple Job Array","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(forks=10)\n\n    # Submit job array\n    for i in range(100):\n        await xqute.feed(['process.sh', str(i)])\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"advanced/#job-array-with-slurm","title":"Job Array with Slurm","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='slurm',\n    forks=100,\n    scheduler_opts={\n        'partition': 'compute',\n        'array': '1-100',  # Job array\n    }\n)\n\n# Single submission for array\nawait xqute.feed(['process.sh', '$SLURM_ARRAY_TASK_ID'])\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"advanced/#progress-tracking","title":"Progress Tracking","text":""},{"location":"advanced/#simple-progress-bar","title":"Simple Progress Bar","text":"<pre><code>import asyncio\nfrom xqute import Xqute\nfrom xqute.defaults import JobStatus\nfrom tqdm import tqdm\n\nasync def track_progress():\n    xqute = Xqute(forks=5)\n\n    # Submit jobs\n    for i in range(100):\n        await xqute.feed(['sleep', '1'])\n\n    # Start progress bar\n    progress = tqdm(total=100, desc=\"Processing\")\n\n    async def update_progress():\n        while True:\n            completed = sum(\n                1 for job in xqute.jobs\n                if await job.get_status() in (JobStatus.FINISHED, JobStatus.FAILED)\n            )\n            progress.n = completed\n            progress.refresh()\n\n            if completed == 100:\n                progress.close()\n                break\n            await asyncio.sleep(1)\n\n    # Run jobs with progress tracking\n    import asyncio\n    await asyncio.gather(\n        xqute.run_until_complete(),\n        update_progress(),\n    )\n</code></pre>"},{"location":"advanced/#detailed-progress-tracking","title":"Detailed Progress Tracking","text":"<pre><code>import asyncio\nfrom xqute import Xqute\nfrom xqute.defaults import JobStatus\nimport time\n\nclass ProgressTracker:\n    def __init__(self, xqute):\n        self.xqute = xqute\n        self.start_time = time.time()\n\n    async def track(self):\n        while True:\n            status_counts = {}\n            for status in JobStatus:\n                count = sum(\n                    1 for job in self.xqute.jobs\n                    if await job.get_status() == status\n                )\n                status_counts[status] = count\n\n            elapsed = time.time() - self.start_time\n            total = len(self.xqute.jobs)\n            completed = status_counts.get(JobStatus.FINISHED, 0)\n            failed = status_counts.get(JobStatus.FAILED, 0)\n\n            print(f\"[{elapsed:.1f}s] \"\n                  f\"Completed: {completed}/{total} \"\n                  f\"Failed: {failed} \"\n                  f\"Running: {status_counts.get(JobStatus.RUNNING, 0)}\")\n\n            if completed + failed == total:\n                break\n\n            await asyncio.sleep(2)\n\nasync def main():\n    xqute = Xqute(forks=5)\n\n    for i in range(50):\n        await xqute.feed(['sleep', str(i % 5)])\n\n    tracker = ProgressTracker(xqute)\n    await asyncio.gather(\n        xqute.run_until_complete(),\n        tracker.track(),\n    )\n</code></pre>"},{"location":"advanced/#streaming-output","title":"Streaming Output","text":""},{"location":"advanced/#stream-output-to-console","title":"Stream Output to Console","text":"<pre><code>from xqute import simplug as pm\nimport asyncio\n\n@pm.impl\nasync def on_job_succeeded(scheduler, job):\n    \"\"\"Stream output after job completes\"\"\"\n    stdout = await job.stdout_file.a_read_text()\n    if stdout:\n        print(f\"Job {job.index} output:\\n{stdout}\")\n</code></pre>"},{"location":"advanced/#real-time-output-streaming","title":"Real-time Output Streaming","text":"<pre><code>from xqute import simplug as pm\nimport aiofiles\n\n@pm.impl\nasync def on_job_polling(scheduler, job, counter):\n    \"\"\"Stream output during polling\"\"\"\n    try:\n        async with aiofiles.open(job.stdout_file, 'r') as f:\n            # Seek to end\n            await f.seek(0, 2)\n            # Read new lines\n            while True:\n                line = await f.readline()\n                if not line:\n                    break\n                print(f\"[Job {job.index}] {line.strip()}\")\n    except FileNotFoundError:\n        pass\n</code></pre>"},{"location":"advanced/#custom-error-handling","title":"Custom Error Handling","text":""},{"location":"advanced/#conditional-retry-logic","title":"Conditional Retry Logic","text":"<pre><code>from xqute import simplug as pm\n\n@pm.impl\nasync def on_job_failed(scheduler, job):\n    \"\"\"Custom retry logic based on error type\"\"\"\n    stderr = await job.stderr_file.a_read_text()\n\n    # Don't retry on certain errors\n    if 'SyntaxError' in stderr:\n        from xqute.utils import logger\n        logger.warning(f\"Syntax error in job {job.index}, not retrying\")\n        # Disable retry for this job\n        job._error_retry = False\n        job._num_retries = 0\n</code></pre>"},{"location":"advanced/#error-aggregation","title":"Error Aggregation","text":"<pre><code>from xqute import simplug as pm\n\nerror_summary = {\n    'syntax_errors': 0,\n    'runtime_errors': 0,\n    'timeout_errors': 0,\n}\n\n@pm.impl\nasync def on_job_failed(scheduler, job):\n    \"\"\"Aggregate error types\"\"\"\n    stderr = await job.stderr_file.a_read_text()\n\n    if 'SyntaxError' in stderr:\n        error_summary['syntax_errors'] += 1\n    elif 'TimeoutError' in stderr:\n        error_summary['timeout_errors'] += 1\n    else:\n        error_summary['runtime_errors'] += 1\n\n@pm.impl\ndef on_shutdown(scheduler, sig):\n    \"\"\"Print error summary\"\"\"\n    print(\"Error Summary:\")\n    for error_type, count in error_summary.items():\n        print(f\"  {error_type}: {count}\")\n</code></pre>"},{"location":"advanced/#job-templates","title":"Job Templates","text":""},{"location":"advanced/#template-with-environment-variables","title":"Template with Environment Variables","text":"<pre><code>from xqute import Xqute\n\ndef create_template_job(index, params):\n    \"\"\"Create job from template\"\"\"\n    return {\n        'cmd': ['python', 'process.py'],\n        'envs': {\n            'INPUT_FILE': params['input'],\n            'OUTPUT_DIR': params['output'],\n            'PARAM_A': str(params.get('param_a', 1)),\n        }\n    }\n\nasync def main():\n    xqute = Xqute(forks=5)\n\n    # Create jobs from templates\n    jobs = [\n        {\n            'input': f'/data/input_{i}.txt',\n            'output': f'/data/output_{i}/',\n            'param_a': i,\n        }\n        for i in range(10)\n    ]\n\n    for i, params in enumerate(jobs):\n        job = create_template_job(i, params)\n        await xqute.feed(job['cmd'], envs=job['envs'])\n\n    await xqute.run_until_complete()\n</code></pre>"},{"location":"advanced/#template-with-command-generation","title":"Template with Command Generation","text":"<pre><code>def generate_job_commands(config):\n    \"\"\"Generate job commands from configuration\"\"\"\n    commands = []\n\n    for dataset in config['datasets']:\n        for model in config['models']:\n            cmd = [\n                'python', 'train.py',\n                '--dataset', dataset,\n                '--model', model,\n                '--epochs', str(config.get('epochs', 10)),\n                '--batch-size', str(config.get('batch_size', 32)),\n            ]\n            commands.append(cmd)\n\n    return commands\n\n# Usage\nconfig = {\n    'datasets': ['imagenet', 'cifar10'],\n    'models': ['resnet50', 'vgg16'],\n    'epochs': 50,\n    'batch_size': 64,\n}\n\nxqute = Xqute(forks=4)\n\nfor cmd in generate_job_commands(config):\n    await xqute.feed(cmd)\n\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"advanced/#batch-processing","title":"Batch Processing","text":""},{"location":"advanced/#process-files-in-batches","title":"Process Files in Batches","text":"<pre><code>import asyncio\nfrom xqute import Xqute\nfrom pathlib import Path\n\nasync def process_files(file_list, batch_size=10):\n    \"\"\"Process files in batches\"\"\"\n    xqute = Xqute(forks=5)\n\n    for i in range(0, len(file_list), batch_size):\n        batch = file_list[i:i+batch_size]\n\n        for file_path in batch:\n            await xqute.feed(['python', 'process.py', file_path])\n\n        # Wait for batch to complete\n        await xqute.run_until_complete()\n        xqute = Xqute(forks=5)  # Create new Xqute for next batch\n\n# Usage\nfiles = list(Path('/data').glob('*.txt'))\nawait process_files(files, batch_size=10)\n</code></pre>"},{"location":"advanced/#batch-processing-with-results","title":"Batch Processing with Results","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def process_with_results(items, process_func):\n    \"\"\"Process items and collect results\"\"\"\n    xqute = Xqute(forks=5)\n\n    # Submit all jobs\n    for item in items:\n        await xqute.feed(['python', process_func, item])\n\n    # Wait for completion\n    await xqute.run_until_complete()\n\n    # Collect results\n    results = []\n    for job in xqute.jobs:\n        stdout = await job.stdout_file.a_read_text()\n        results.append((job.index, stdout))\n\n    return results\n\n# Usage\nitems = ['item1', 'item2', 'item3']\nresults = await process_with_results(items, 'processor.py')\n</code></pre>"},{"location":"advanced/#integration-with-other-tools","title":"Integration with Other Tools","text":""},{"location":"advanced/#integration-with-airflow","title":"Integration with Airflow","text":"<pre><code>from airflow import DAG\nfrom airflow.operators.python import PythonOperator\nimport asyncio\nfrom xqute import Xqute\nfrom datetime import datetime, timedelta\n\ndef run_xqute_jobs(**context):\n    \"\"\"Run Xqute jobs in Airflow task\"\"\"\n\n    async def process():\n        xqute = Xqute(\n            scheduler='slurm',\n            forks=10,\n            scheduler_opts={\n                'partition': 'airflow',\n            }\n        )\n\n        # Get files from Airflow context\n        files = context['params']['files']\n\n        for file_path in files:\n            await xqute.feed(['python', 'process.py', file_path])\n\n        await xqute.run_until_complete()\n\n    asyncio.run(process())\n\nwith DAG(\n    'xqute_pipeline',\n    default_args={\n        'owner': 'airflow',\n        'depends_on_past': False,\n        'start_date': datetime(2024, 1, 1),\n        'retries': 1,\n    },\n    schedule_interval=timedelta(days=1),\n) as dag:\n\n    run_jobs = PythonOperator(\n        task_id='run_xqute_jobs',\n        python_callable=run_xqute_jobs,\n        params={\n            'files': ['/data/file1.txt', '/data/file2.txt'],\n        },\n    )\n</code></pre>"},{"location":"advanced/#integration-with-dask","title":"Integration with Dask","text":"<pre><code>import dask\nfrom xqute import Xqute\nimport asyncio\n\n@dask.delayed\ndef run_xqute_task(task_id, command):\n    \"\"\"Run Xqute job as Dask task\"\"\"\n\n    async def process():\n        xqute = Xqute(forks=1)\n        await xqute.feed(command)\n        await xqute.run_until_complete()\n\n    asyncio.run(process())\n\n# Create Dask workflow\ntasks = [\n    run_xqute_task(i, ['python', 'process.py', str(i)])\n    for i in range(100)\n]\n\n# Execute with Dask\nresults = dask.compute(*tasks)\n</code></pre>"},{"location":"advanced/#performance-optimization","title":"Performance Optimization","text":""},{"location":"advanced/#optimize-concurrency","title":"Optimize Concurrency","text":"<pre><code>import os\nimport psutil\n\ndef calculate_optimal_forks():\n    \"\"\"Calculate optimal concurrency based on resources\"\"\"\n    cpu_count = os.cpu_count()\n    mem_gb = psutil.virtual_memory().total / (1024**3)\n\n    # Adjust based on job type\n    if mem_gb &gt; 64:\n        return cpu_count * 2\n    elif mem_gb &gt; 32:\n        return cpu_count\n    else:\n        return max(1, cpu_count // 2)\n\nxqute = Xqute(forks=calculate_optimal_forks())\n</code></pre>"},{"location":"advanced/#batch-submissions","title":"Batch Submissions","text":"<pre><code># Reduce scheduler overhead by batching submissions\nxqute = Xqute(\n    scheduler='slurm',\n    forks=1000,\n    submission_batch=50,  # Submit 50 jobs at once\n)\n</code></pre>"},{"location":"advanced/#reduce-polling-frequency","title":"Reduce Polling Frequency","text":"<pre><code># Poll less frequently for long-running jobs\nxqute = Xqute(\n    scheduler='slurm',\n    recheck_interval=50,  # Check every 50 polls instead of 10\n)\n</code></pre>"},{"location":"advanced/#optimize-working-directory","title":"Optimize Working Directory","text":"<pre><code># Use local directory instead of cloud for speed\nxqute = Xqute(\n    workdir='./.xqute',  # Local, not 'gs://bucket/jobs'\n)\n\n# Or use mounted path\nxqute = Xqute(\n    workdir='gs://bucket/jobs',\n    scheduler_opts={\n        'mounted_workdir': '/mnt/gs',  # Faster access\n    },\n)\n</code></pre>"},{"location":"advanced/#memory-management","title":"Memory Management","text":"<pre><code>from xqute import simplug as pm\n\n@pm.impl\nasync def on_job_succeeded(scheduler, job):\n    \"\"\"Clean up large output files to save space\"\"\"\n    # Remove stdout if it's too large\n    if await job.stdout_file.a_size() &gt; 10_000_000:  # 10MB\n        await job.stdout_file.a_unlink()\n\n    # Remove stderr\n    await job.stderr_file.a_unlink()\n</code></pre>"},{"location":"advanced/#next-steps","title":"Next Steps","text":"<ul> <li>User Guide - Comprehensive usage guide</li> <li>Schedulers - Learn about different scheduler backends</li> <li>Plugins - Extend functionality</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"plugins/","title":"Plugins","text":""},{"location":"plugins/#plugins","title":"Plugins","text":"<p>Extend Xqute's functionality using the plugin system based on <code>simplug</code>.</p>"},{"location":"plugins/#overview","title":"Overview","text":"<p>Xqute uses a hook-based plugin system that allows you to:</p> <ul> <li>Customize job lifecycle behavior</li> <li>Add custom logging and monitoring</li> <li>Integrate with external services</li> <li>Modify job commands dynamically</li> <li>Implement custom error handling</li> </ul>"},{"location":"plugins/#available-hooks","title":"Available Hooks","text":""},{"location":"plugins/#scheduler-hooks","title":"Scheduler Hooks","text":"Hook Type Description <code>on_init</code> sync Called when scheduler is initialized <code>on_shutdown</code> sync Called when scheduler shuts down"},{"location":"plugins/#job-lifecycle-hooks","title":"Job Lifecycle Hooks","text":"Hook Type Description <code>on_job_init</code> async Called when a job is created <code>on_job_queued</code> async Called when job is queued <code>on_job_submitted</code> async Called after job is submitted <code>on_job_started</code> async Called when job starts running <code>on_job_polling</code> async Called during status polling <code>on_job_killing</code> async Called when job is being killed <code>on_job_killed</code> async Called after job is killed <code>on_job_failed</code> async Called when job fails <code>on_job_succeeded</code> async Called when job succeeds"},{"location":"plugins/#job-command-hooks","title":"Job Command Hooks","text":"Hook Type Description <code>on_jobcmd_init</code> sync Returns code to prepend to job script <code>on_jobcmd_prep</code> sync Returns code before job command <code>on_jobcmd_end</code> sync Returns code after job command"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":""},{"location":"plugins/#basic-plugin-structure","title":"Basic Plugin Structure","text":"<pre><code>from xqute import simplug as pm\n\n@pm.impl\ndef on_init(scheduler):\n    \"\"\"Called when scheduler is initialized\"\"\"\n    print(f\"Scheduler {scheduler.name} initialized\")\n\n@pm.impl\nasync def on_job_submitted(scheduler, job):\n    \"\"\"Called when job is submitted\"\"\"\n    print(f\"Job {job.index} submitted with JID: {job._jid}\")\n</code></pre>"},{"location":"plugins/#complete-example","title":"Complete Example","text":"<p>Create a file <code>myplugin.py</code>:</p> <pre><code>\"\"\"Custom plugin for Xqute\"\"\"\nfrom xqute import simplug as pm\nfrom xqute.defaults import JobStatus\nimport logging\n\n# Setup logging\nlogger = logging.getLogger('myplugin')\n\n@pm.impl\ndef on_init(scheduler):\n    \"\"\"Initialize plugin with scheduler\"\"\"\n    logger.info(f\"MyPlugin loaded for {scheduler.name}\")\n\n@pm.impl\nasync def on_job_init(scheduler, job):\n    \"\"\"Called when job is initialized\"\"\"\n    logger.info(f\"Job {job.index} initialized: {job.cmd}\")\n\n@pm.impl\nasync def on_job_queued(scheduler, job):\n    \"\"\"Called when job is queued\"\"\"\n    logger.info(f\"Job {job.index} queued\")\n\n@pm.impl\nasync def on_job_submitted(scheduler, job):\n    \"\"\"Called after job is submitted\"\"\"\n    jid = await job.get_jid()\n    logger.info(f\"Job {job.index} submitted (JID: {jid})\")\n\n@pm.impl\nasync def on_job_started(scheduler, job):\n    \"\"\"Called when job starts running\"\"\"\n    logger.info(f\"Job {job.index} started\")\n\n@pm.impl\nasync def on_job_polling(scheduler, job, counter):\n    \"\"\"Called during status polling\"\"\"\n    if counter % 10 == 0:\n        status = await job.get_status()\n        status_name = JobStatus.get_name(status)\n        logger.debug(f\"Job {job.index} polling: {status_name}\")\n\n@pm.impl\nasync def on_job_failed(scheduler, job):\n    \"\"\"Called when job fails\"\"\"\n    logger.error(f\"Job {job.index} failed\")\n\n@pm.impl\nasync def on_job_succeeded(scheduler, job):\n    \"\"\"Called when job succeeds\"\"\"\n    logger.info(f\"Job {job.index} succeeded\")\n</code></pre>"},{"location":"plugins/#using-plugins","title":"Using Plugins","text":""},{"location":"plugins/#enable-plugin","title":"Enable Plugin","text":"<p>Import the plugin module before creating Xqute:</p> <pre><code>import asyncio\nfrom xqute import Xqute\n\n# Import your plugin\nimport myplugin\n\nasync def main():\n    xqute = Xqute(forks=3)\n\n    await xqute.feed(['echo', 'Hello'])\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"plugins/#enable-multiple-plugins","title":"Enable Multiple Plugins","text":"<pre><code># Import multiple plugins\nimport logging_plugin\nimport monitoring_plugin\n\n# Enable specific plugins\nxqute = Xqute(plugins=['logging_plugin', 'monitoring_plugin'])\n</code></pre>"},{"location":"plugins/#disable-plugin","title":"Disable Plugin","text":"<pre><code># Import all plugins\nimport myplugin\nimport another_plugin\n\n# Disable specific plugin\nxqute = Xqute(plugins=['-myplugin'])\n</code></pre>"},{"location":"plugins/#plugin-examples","title":"Plugin Examples","text":""},{"location":"plugins/#1-email-notifications","title":"1. Email Notifications","text":"<pre><code>\"\"\"Send email notifications for job completion\"\"\"\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom xqute import simplug as pm\n\nSMTP_SERVER = 'smtp.example.com'\nSMTP_PORT = 587\nSMTP_USER = 'user@example.com'\nSMTP_PASSWORD = 'password'\n\ndef send_email(to, subject, body):\n    \"\"\"Send email notification\"\"\"\n    msg = MIMEText(body)\n    msg['Subject'] = subject\n    msg['From'] = SMTP_USER\n    msg['To'] = to\n\n    with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:\n        server.starttls()\n        server.login(SMTP_USER, SMTP_PASSWORD)\n        server.send_message(msg)\n\n@pm.impl\nasync def on_job_failed(scheduler, job):\n    \"\"\"Send email on job failure\"\"\"\n    stderr = await job.stderr_file.a_read_text()\n    subject = f\"Job {job.index} Failed\"\n    body = f\"Job command: {job.cmd}\\n\\nStderr:\\n{stderr}\"\n    send_email('admin@example.com', subject, body)\n</code></pre>"},{"location":"plugins/#2-database-logging","title":"2. Database Logging","text":"<pre><code>\"\"\"Log job information to database\"\"\"\nimport sqlite3\nfrom xqute import simplug as pm\n\nDB_PATH = 'jobs.db'\n\ndef get_db():\n    \"\"\"Get database connection\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    conn.execute('''\n        CREATE TABLE IF NOT EXISTS jobs (\n            index INTEGER PRIMARY KEY,\n            command TEXT,\n            status INTEGER,\n            submitted_at TIMESTAMP,\n            completed_at TIMESTAMP\n        )\n    ''')\n    return conn\n\n@pm.impl\nasync def on_job_submitted(scheduler, job):\n    \"\"\"Log job submission\"\"\"\n    import datetime\n    conn = get_db()\n    conn.execute(\n        'INSERT INTO jobs (index, command, status, submitted_at) VALUES (?, ?, ?, ?)',\n        (job.index, str(job.cmd), 2, datetime.datetime.now())\n    )\n    conn.commit()\n    conn.close()\n\n@pm.impl\nasync def on_job_succeeded(scheduler, job):\n    \"\"\"Update job completion\"\"\"\n    import datetime\n    conn = get_db()\n    conn.execute(\n        'UPDATE jobs SET status = 4, completed_at = ? WHERE index = ?',\n        (datetime.datetime.now(), job.index)\n    )\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"plugins/#3-slack-notifications","title":"3. Slack Notifications","text":"<pre><code>\"\"\"Send Slack notifications\"\"\"\nimport requests\nfrom xqute import simplug as pm\n\nSLACK_WEBHOOK = 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL'\n\ndef send_slack(message):\n    \"\"\"Send message to Slack\"\"\"\n    requests.post(SLACK_WEBHOOK, json={'text': message})\n\n@pm.impl\nasync def on_job_failed(scheduler, job):\n    \"\"\"Send Slack notification on failure\"\"\"\n    send_slack(f\":x: Job {job.index} failed: {job.cmd}\")\n\n@pm.impl\nasync def on_job_succeeded(scheduler, job):\n    \"\"\"Send Slack notification on success\"\"\"\n    send_slack(f\":white_check_mark: Job {job.index} completed\")\n</code></pre>"},{"location":"plugins/#4-custom-command-wrapping","title":"4. Custom Command Wrapping","text":"<pre><code>\"\"\"Wrap job commands with additional setup\"\"\"\nfrom xqute import simplug as pm\n\n@pm.impl\ndef on_jobcmd_init(scheduler, job):\n    \"\"\"Add initialization code to job script\"\"\"\n    return f\"\"\"\n# Custom initialization\nset -e\nexport CUSTOM_VAR=\"value\"\n\"\"\"\n\n@pm.impl\ndef on_jobcmd_prep(scheduler, job):\n    \"\"\"Add preparation code before job command\"\"\"\n    return f\"\"\"\n# Preparation\ncd /tmp/workdir\necho \"Preparing job {job.index}\"\n\"\"\"\n\n@pm.impl\ndef on_jobcmd_end(scheduler, job):\n    \"\"\"Add cleanup code after job command\"\"\"\n    return f\"\"\"\n# Cleanup\nrm -rf /tmp/workdir\necho \"Job {job.index} completed\"\n\"\"\"\n</code></pre>"},{"location":"plugins/#5-resource-monitoring","title":"5. Resource Monitoring","text":"<pre><code>\"\"\"Monitor job resource usage\"\"\"\nimport psutil\nimport time\nfrom xqute import simplug as pm\n\nMONITOR_FILE = 'job_resources.txt'\n\n@pm.impl\nasync def on_job_started(scheduler, job):\n    \"\"\"Start resource monitoring\"\"\"\n    # In real implementation, start background monitoring\n    pass\n\n@pm.impl\nasync def on_job_polling(scheduler, job, counter):\n    \"\"\"Log resource usage\"\"\"\n    # Log CPU, memory usage\n    cpu_percent = psutil.cpu_percent()\n    memory = psutil.virtual_memory()\n\n    with open(MONITOR_FILE, 'a') as f:\n        f.write(f\"{job.index},{counter},{cpu_percent},{memory.percent}\\n\")\n</code></pre>"},{"location":"plugins/#6-conditional-job-submission","title":"6. Conditional Job Submission","text":"<pre><code>\"\"\"Conditionally submit jobs based on criteria\"\"\"\nfrom xqute import simplug as pm\n\n@pm.impl\nasync def on_job_submitting(scheduler, job):\n    \"\"\"Decide whether to submit job\"\"\"\n    # Skip jobs with index 5 and 10\n    if job.index in [5, 10]:\n        print(f\"Skipping job {job.index}\")\n        return False  # Cancel submission\n\n    # Proceed with submission\n    return None\n</code></pre>"},{"location":"plugins/#plugin-development-tips","title":"Plugin Development Tips","text":""},{"location":"plugins/#1-error-handling","title":"1. Error Handling","text":"<p>Always handle errors gracefully:</p> <pre><code>@pm.impl\nasync def on_job_failed(scheduler, job):\n    try:\n        # Your code here\n        pass\n    except Exception as e:\n        # Log error but don't crash\n        from xqute.utils import logger\n        logger.error(f\"Plugin error: {e}\")\n</code></pre>"},{"location":"plugins/#2-async-vs-sync-hooks","title":"2. Async vs Sync Hooks","text":"<p>Use async hooks for I/O operations:</p> <pre><code># Async: Use for file I/O, network calls\n@pm.impl\nasync def on_job_submitted(scheduler, job):\n    await job.stdout_file.a_read_text()\n\n# Sync: Use for simple operations\n@pm.impl\ndef on_init(scheduler):\n    print(\"Initialized\")\n</code></pre>"},{"location":"plugins/#3-hook-order","title":"3. Hook Order","text":"<p>Multiple plugins can implement the same hook. They execute in import order:</p> <pre><code># plugin1.py\n@pm.impl\ndef on_init(scheduler):\n    print(\"First\")\n\n# plugin2.py\n@pm.impl\ndef on_init(scheduler):\n    print(\"Second\")\n\n# Output when imported:\n# First\n# Second\n</code></pre>"},{"location":"plugins/#4-canceling-hooks","title":"4. Canceling Hooks","text":"<p>Return <code>False</code> from specific hooks to cancel actions:</p> <pre><code>@pm.impl\nasync def on_job_submitting(scheduler, job):\n    # Cancel submission\n    return False\n\n@pm.impl\nasync def on_job_killing(scheduler, job):\n    # Prevent job from being killed\n    return False\n</code></pre>"},{"location":"plugins/#5-hook-return-values","title":"5. Hook Return Values","text":"<p>Some hooks expect return values:</p> <pre><code># on_jobcmd_* hooks return code strings\n@pm.impl\ndef on_jobcmd_init(scheduler, job):\n    return \"# My initialization code\"\n</code></pre>"},{"location":"plugins/#plugin-distribution","title":"Plugin Distribution","text":""},{"location":"plugins/#package-as-python-package","title":"Package as Python Package","text":"<p>Create directory structure:</p> <pre><code>xqute-myplugin/\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 xqute_myplugin/\n    \u2514\u2500\u2500 __init__.py\n</code></pre> <p><code>xqute_myplugin/__init__.py</code>:</p> <pre><code>\"\"\"Xqute plugin for custom functionality\"\"\"\nfrom xqute import simplug as pm\n\n@pm.impl\ndef on_init(scheduler):\n    print(\"MyPlugin loaded\")\n</code></pre> <p><code>setup.py</code>:</p> <pre><code>from setuptools import setup, find_packages\n\nsetup(\n    name='xqute-myplugin',\n    version='0.1.0',\n    packages=find_packages(),\n    install_requires=['xqute'],\n    entry_points={\n        'xqute.plugins': [\n            'myplugin = xqute_myplugin',\n        ],\n    },\n)\n</code></pre>"},{"location":"plugins/#install-plugin","title":"Install Plugin","text":"<pre><code>pip install xqute-myplugin\n\n# Use plugin\nfrom xqute import Xqute\nxqute = Xqute(plugins=['myplugin'])\n</code></pre>"},{"location":"plugins/#testing-plugins","title":"Testing Plugins","text":""},{"location":"plugins/#unit-testing","title":"Unit Testing","text":"<pre><code>import pytest\nfrom xqute import Xqute, simplug as pm\n\n# Define test plugin\n@pm.impl\ndef on_init(scheduler):\n    scheduler.test_flag = True\n\nasync def test_plugin():\n    xqute = Xqute()\n    assert hasattr(xqute.scheduler, 'test_flag')\n    assert xqute.scheduler.test_flag is True\n</code></pre>"},{"location":"plugins/#integration-testing","title":"Integration Testing","text":"<pre><code>import pytest\nimport asyncio\n\nasync def test_plugin_integration():\n    # Import plugin\n    import myplugin\n\n    xqute = Xqute(forks=1)\n    await xqute.feed(['echo', 'test'])\n    await xqute.run_until_complete()\n\n    # Verify plugin behavior\n    # ... assertions\n</code></pre>"},{"location":"plugins/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Always catch exceptions in hooks</li> <li>Logging: Use <code>xqute.utils.logger</code> for consistent logging</li> <li>Performance: Avoid blocking operations in async hooks</li> <li>Idempotency: Hooks should be safe to call multiple times</li> <li>Documentation: Document your hooks and behavior</li> <li>Testing: Write tests for your plugin functionality</li> <li>Compatibility: Test with multiple Xqute versions</li> </ol>"},{"location":"plugins/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Usage - Advanced patterns and customization</li> <li>User Guide - Comprehensive usage guide</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#quick-start","title":"Quick Start","text":"<p>Get up and running with Xqute in minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install xqute\n</code></pre>"},{"location":"quickstart/#optional-dependencies","title":"Optional Dependencies","text":"<p>For additional features, install with extras:</p> <pre><code># Google Cloud Storage support\npip install xqute[gs]\n\n# Cloud shell support\npip install xqute[cloudsh]\n</code></pre>"},{"location":"quickstart/#your-first-job","title":"Your First Job","text":""},{"location":"quickstart/#minimal-example","title":"Minimal Example","text":"<p>Create a file <code>first_job.py</code>:</p> <pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    # Create Xqute instance with default local scheduler\n    xqute = Xqute(forks=3)\n\n    # Add a simple job\n    await xqute.feed(['echo', 'Hello, Xqute!'])\n\n    # Wait for all jobs to complete\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>Run it:</p> <pre><code>python first_job.py\n</code></pre> <p>Output:</p> <pre><code>Job metadata is stored at: .xqute\n...\nHello, Xqute!\n...\nDone!\n</code></pre>"},{"location":"quickstart/#multiple-jobs","title":"Multiple Jobs","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    # Run 3 jobs concurrently\n    xqute = Xqute(forks=3)\n\n    # Add multiple jobs\n    for i in range(10):\n        await xqute.feed(['echo', f'Job {i}'])\n\n    # Wait for completion\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#daemon-mode-keep-feeding","title":"Daemon Mode (Keep Feeding)","text":"<p>For scenarios where jobs need to be added dynamically:</p> <pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(forks=3)\n\n    # Start in daemon mode\n    await xqute.run_until_complete(keep_feeding=True)\n\n    # Add jobs while running\n    for i in range(10):\n        await xqute.feed(['sleep', '1'])\n        await asyncio.sleep(0.1)\n\n    # Signal completion and wait\n    await xqute.stop_feeding()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#using-different-schedulers","title":"Using Different Schedulers","text":""},{"location":"quickstart/#sge-sun-grid-engine","title":"SGE (Sun Grid Engine)","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(\n        scheduler='sge',\n        forks=100,\n        scheduler_opts={\n            'q': '1-day',  # Queue name\n            'l': ['h_vmem=2G'],  # Resource requirements\n        }\n    )\n\n    # Add jobs to SGE\n    for i in range(100):\n        await xqute.feed(['echo', f'Job {i}'])\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#slurm","title":"Slurm","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(\n        scheduler='slurm',\n        forks=100,\n        scheduler_opts={\n            'partition': 'compute',\n            'time': '01:00:00',\n            'mem': '2G',\n        }\n    )\n\n    # Add jobs to Slurm\n    for i in range(100):\n        await xqute.feed(['echo', f'Job {i}'])\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#google-batch","title":"Google Batch","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(\n        scheduler='gbatch',\n        forks=100,\n        scheduler_opts={\n            'project': 'your-project-id',\n            'location': 'us-central1',\n            'taskGroups': [\n                {\n                    'taskSpec': {\n                        'runnables': [\n                            {\n                                'container': {\n                                    'imageUri': 'ubuntu',\n                                    'entrypoint': 'bash',\n                                    'commands': ['-c', 'echo \"Hello from Google Batch\"']\n                                }\n                            }\n                        ]\n                    },\n                    'taskCount': 10,\n                    'parallelism': 3\n                }\n            ]\n        }\n    )\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#docker-containers","title":"Docker Containers","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(\n        scheduler='container',\n        forks=3,\n        scheduler_opts={\n            'image': 'python:3.11',\n            'entrypoint': '/bin/bash',\n            'bin': 'docker',\n        }\n    )\n\n    # Run jobs in containers\n    for i in range(10):\n        await xqute.feed(['python', '-c', f'print({i})'])\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#error-handling","title":"Error Handling","text":""},{"location":"quickstart/#retry-strategy","title":"Retry Strategy","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(\n        error_strategy='retry',  # Retry failed jobs\n        num_retries=3,           # Maximum 3 attempts\n    )\n\n    # This job will be retried if it fails\n    await xqute.feed(['python', '-c', 'import sys; sys.exit(1)'])\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#halt-strategy","title":"Halt Strategy","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(\n        error_strategy='halt',  # Stop on first failure\n    )\n\n    await xqute.feed(['echo', 'Job 1'])\n    await xqute.feed(['python', '-c', 'import sys; sys.exit(1)'])  # Fails\n    await xqute.feed(['echo', 'Job 3'])  # Won't run\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#environment-variables","title":"Environment Variables","text":"<p>Pass environment variables to jobs:</p> <pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(forks=3)\n\n    # Pass environment variables\n    await xqute.feed(\n        ['bash', '-c', 'echo \"MY_VAR: $MY_VAR\"'],\n        envs={'MY_VAR': 'custom_value'}\n    )\n\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#checking-job-status","title":"Checking Job Status","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    xqute = Xqute(forks=3)\n\n    # Add jobs\n    for i in range(5):\n        await xqute.feed(['sleep', str(i)])\n\n    # Access job information\n    job = xqute.jobs[0]\n    print(f\"Job index: {job.index}\")\n    print(f\"Job command: {job.cmd}\")\n    print(f\"Job metadir: {job.metadir}\")\n    print(f\"Status file: {job.status_file}\")\n    print(f\"Stdout file: {job.stdout_file}\")\n    print(f\"Stderr file: {job.stderr_file}\")\n\n    # Run jobs\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>User Guide - Comprehensive usage guide</li> <li>Schedulers - Learn about different scheduler backends</li> <li>Plugins - Create and use plugins</li> <li>Advanced Usage - Advanced patterns and customization</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"schedulers/","title":"Schedulers","text":""},{"location":"schedulers/#schedulers","title":"Schedulers","text":"<p>Xqute supports multiple scheduler backends for different computing environments. Each scheduler provides a unified interface while handling backend-specific details.</p>"},{"location":"schedulers/#available-schedulers","title":"Available Schedulers","text":"<ul> <li>Local Scheduler - Run jobs on the local machine</li> <li>SGE Scheduler - Sun Grid Engine clusters</li> <li>Slurm Scheduler - Slurm workload manager</li> <li>SSH Scheduler - Distribute jobs across SSH servers</li> <li>Google Batch Scheduler - Google Cloud Batch</li> <li>Container Scheduler - Docker containers</li> </ul>"},{"location":"schedulers/#local-scheduler","title":"Local Scheduler","text":""},{"location":"schedulers/#overview","title":"Overview","text":"<p>Runs jobs directly on the local machine. Best for: - Development and testing - Small-scale processing - Single-machine workloads</p>"},{"location":"schedulers/#basic-usage","title":"Basic Usage","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='local',\n    forks=4,  # Max 4 concurrent jobs\n)\n\nawait xqute.feed(['echo', 'Hello'])\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"schedulers/#configuration-options","title":"Configuration Options","text":"<pre><code>xqute = Xqute(\n    scheduler='local',\n    forks=4,              # Max concurrent jobs\n    workdir='./.xqute',   # Job metadata directory\n)\n</code></pre>"},{"location":"schedulers/#use-cases","title":"Use Cases","text":"<ul> <li>Running small batches of jobs</li> <li>Testing job pipelines</li> <li>Processing data on a single machine</li> <li>Development and debugging</li> </ul>"},{"location":"schedulers/#limitations","title":"Limitations","text":"<ul> <li>Limited to local machine resources</li> <li>No cluster management</li> <li>No job priority queues</li> </ul>"},{"location":"schedulers/#sge-scheduler","title":"SGE Scheduler","text":""},{"location":"schedulers/#overview_1","title":"Overview","text":"<p>Integrates with Sun Grid Engine (SGE) for HPC cluster job management. Best for: - University and research clusters - Traditional HPC environments - Job queue management with resource allocation</p>"},{"location":"schedulers/#basic-usage_1","title":"Basic Usage","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='sge',\n    forks=100,\n    scheduler_opts={\n        'q': '1-day',  # Queue name\n    }\n)\n\nfor i in range(100):\n    await xqute.feed(['echo', f'Job {i}'])\n\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"schedulers/#configuration-options_1","title":"Configuration Options","text":"<pre><code>xqute = Xqute(\n    scheduler='sge',\n    forks=100,\n    scheduler_opts={\n        # Command paths\n        'qsub': '/usr/bin/qsub',\n        'qdel': '/usr/bin/qdel',\n        'qstat': '/usr/bin/qstat',\n\n        # Queue configuration (shortcut for qsub_q)\n        'q': '1-day',\n\n        # Resource requirements\n        'l': ['h_vmem=2G', 'gpu=1'],\n\n        # Job arrays\n        't': '1-100',\n\n        # Additional qsub options\n        'cwd': True,\n        'notify': False,\n\n        # Direct qsub parameters\n        'qsub_q': '1-day',\n        'qsub_l': ['h_vmem=2G'],\n        'qsub_N': 'myjob',\n    }\n)\n</code></pre>"},{"location":"schedulers/#resource-requirements","title":"Resource Requirements","text":"<p>Specify resources using the <code>l</code> option:</p> <pre><code>scheduler_opts={\n    'l': [\n        'h_vmem=4G',      # Memory per job\n        'gpu=1',          # GPU count\n        'h_rt=24:00:00',  # Runtime\n    ]\n}\n</code></pre>"},{"location":"schedulers/#common-sge-options","title":"Common SGE Options","text":"Parameter Description Example <code>q</code> Queue name <code>'1-day'</code> <code>l</code> Resource list <code>['h_vmem=2G']</code> <code>t</code> Task array <code>'1-100'</code> <code>N</code> Job name <code>'myjob'</code> <code>cwd</code> Current working directory <code>True</code> <code>notify</code> Email notification <code>False</code>"},{"location":"schedulers/#use-cases_1","title":"Use Cases","text":"<ul> <li>University cluster jobs</li> <li>Large-scale data processing</li> <li>HPC workflows</li> <li>Resource-constrained jobs</li> </ul>"},{"location":"schedulers/#notes","title":"Notes","text":"<ul> <li>Jobs are submitted via <code>qsub</code></li> <li>Status checked via <code>qstat</code></li> <li>Jobs cancelled via <code>qdel</code></li> <li>Jobs fail before running if resources are unavailable</li> </ul>"},{"location":"schedulers/#slurm-scheduler","title":"Slurm Scheduler","text":""},{"location":"schedulers/#overview_2","title":"Overview","text":"<p>Integrates with Slurm workload manager. Best for: - Modern HPC clusters - Cloud-based HPC (e.g., Google Cloud Slurm) - Job arrays and dependency management</p>"},{"location":"schedulers/#basic-usage_2","title":"Basic Usage","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='slurm',\n    forks=100,\n    scheduler_opts={\n        'partition': 'compute',\n    }\n)\n\nfor i in range(100):\n    await xqute.feed(['echo', f'Job {i}'])\n\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"schedulers/#configuration-options_2","title":"Configuration Options","text":"<pre><code>xqute = Xqute(\n    scheduler='slurm',\n    forks=100,\n    scheduler_opts={\n        # Command paths\n        'sbatch': '/usr/bin/sbatch',\n        'scancel': '/usr/bin/scancel',\n        'squeue': '/usr/bin/squeue',\n\n        # Job configuration\n        'partition': 'compute',\n        'time': '01:00:00',\n        'mem': '2G',\n        'cpus-per-task': 1,\n\n        # Additional options\n        'job-name': 'myjob',\n        'output': 'job-%j.out',\n        'error': 'job-%j.err',\n    }\n)\n</code></pre>"},{"location":"schedulers/#resource-allocation","title":"Resource Allocation","text":"<pre><code>scheduler_opts={\n    'partition': 'gpu',\n    'time': '24:00:00',        # Max runtime\n    'mem': '8G',                # Memory\n    'cpus-per-task': 4,        # CPUs per job\n    'gres': 'gpu:1',           # GPU resources\n    'nodes': 1,                # Number of nodes\n}\n</code></pre>"},{"location":"schedulers/#common-slurm-options","title":"Common Slurm Options","text":"Parameter Description Example <code>partition</code> Queue/partition name <code>'compute'</code> <code>time</code> Runtime limit <code>'01:00:00'</code> <code>mem</code> Memory <code>'2G'</code> <code>cpus-per-task</code> CPUs per job <code>4</code> <code>gres</code> Generic resources <code>'gpu:1'</code> <code>job-name</code> Job name <code>'myjob'</code> <code>output</code> Stdout file <code>'job-%j.out'</code> <code>error</code> Stderr file <code>'job-%j.err'</code>"},{"location":"schedulers/#use-cases_2","title":"Use Cases","text":"<ul> <li>Modern HPC clusters</li> <li>GPU-accelerated computing</li> <li>Job arrays</li> <li>Large-scale parallel processing</li> </ul>"},{"location":"schedulers/#notes_1","title":"Notes","text":"<ul> <li>Jobs are submitted via <code>sbatch</code></li> <li>Status checked via <code>squeue</code></li> <li>Jobs cancelled via <code>scancel</code></li> <li>Supports job arrays and dependencies</li> </ul>"},{"location":"schedulers/#ssh-scheduler","title":"SSH Scheduler","text":""},{"location":"schedulers/#overview_3","title":"Overview","text":"<p>Distributes jobs across multiple SSH-accessible servers. Best for: - Cluster of Linux servers - Load balancing across machines - Using existing SSH infrastructure</p>"},{"location":"schedulers/#basic-usage_3","title":"Basic Usage","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='ssh',\n    forks=100,\n    scheduler_opts={\n        'servers': {\n            'server1': {\n                'user': 'username',\n                'host': 'server1.example.com',\n                'port': 22,\n                'keyfile': '/path/to/keyfile',\n            },\n            'server2': {\n                'user': 'username',\n                'host': 'server2.example.com',\n            },\n        }\n    }\n)\n\nfor i in range(100):\n    await xqute.feed(['echo', f'Job {i}'])\n\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"schedulers/#configuration-options_3","title":"Configuration Options","text":"<pre><code>xqute = Xqute(\n    scheduler='ssh',\n    forks=100,\n    scheduler_opts={\n        # SSH command path\n        'ssh': '/usr/bin/ssh',\n\n        # Server configuration\n        'servers': {\n            'server1': {\n                'user': 'username',\n                'host': 'server1.example.com',\n                'port': 22,\n                'keyfile': '/path/to/keyfile',\n                'ctrl_persist': 600,  # Connection persistence\n                'ctrl_dir': '/tmp/ssh',\n            },\n            'server2': {\n                'user': 'username',\n                'host': 'server2.example.com',\n            },\n        }\n    }\n)\n</code></pre>"},{"location":"schedulers/#server-configuration","title":"Server Configuration","text":"Parameter Description Example <code>user</code> SSH username <code>'username'</code> <code>host</code> Server hostname <code>'server1.example.com'</code> <code>port</code> SSH port <code>22</code> <code>keyfile</code> SSH private key path <code>'/path/to/key'</code> <code>ctrl_persist</code> Keep-alive time (seconds) <code>600</code> <code>ctrl_dir</code> Control socket directory <code>'/tmp/ssh'</code>"},{"location":"schedulers/#use-cases_3","title":"Use Cases","text":"<ul> <li>Load balancing across servers</li> <li>Using existing SSH infrastructure</li> <li>Distributed computing on multiple machines</li> <li>Resource utilization across a cluster</li> </ul>"},{"location":"schedulers/#notes_2","title":"Notes","text":"<ul> <li>Requirement: All servers must share the same filesystem</li> <li>Authentication: Key-based authentication required</li> <li>Connection: Uses SSH control sockets for efficiency</li> <li>Workdir: Must be accessible from all servers</li> </ul>"},{"location":"schedulers/#google-batch-scheduler","title":"Google Batch Scheduler","text":""},{"location":"schedulers/#overview_4","title":"Overview","text":"<p>Integrates with Google Cloud Batch for cloud-based job execution. Best for: - Cloud-native workflows - Large-scale parallel processing - Auto-scaling compute resources</p>"},{"location":"schedulers/#basic-usage_4","title":"Basic Usage","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='gbatch',\n    forks=100,\n    scheduler_opts={\n        'project': 'your-project-id',\n        'location': 'us-central1',\n        'taskGroups': [\n            {\n                'taskSpec': {\n                    'runnables': [\n                        {\n                            'container': {\n                                'imageUri': 'ubuntu',\n                                'entrypoint': 'bash',\n                                'commands': ['-c', 'echo \"Hello from Google Batch\"']\n                            }\n                        }\n                    ]\n                },\n                'taskCount': 10,\n                'parallelism': 3\n            }\n        ]\n    }\n)\n\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"schedulers/#configuration-options_4","title":"Configuration Options","text":"<pre><code>xqute = Xqute(\n    scheduler='gbatch',\n    forks=100,\n    scheduler_opts={\n        # Google Cloud configuration\n        'project': 'your-project-id',\n        'location': 'us-central1',\n        'gcloud': '/path/to/gcloud',\n\n        # Job configuration\n        'taskGroups': [\n            {\n                'taskSpec': {\n                    'runnables': [\n                        {\n                            'container': {\n                                'imageUri': 'python:3.11',\n                                'entrypoint': 'python',\n                                'commands': ['-c', 'print(\"Hello\")']\n                            }\n                        }\n                    ],\n                    'environment': {\n                        'variables': {\n                            'MY_VAR': 'value'\n                        }\n                    }\n                },\n                'taskCount': 100,\n                'parallelism': 10,\n                'taskCountPerNode': 2,\n            }\n        ],\n\n        # Additional options\n        'allocationPolicy': {\n            'instances': [\n                {\n                    'policy': {\n                        'machineType': 'n1-standard-4',\n                    }\n                }\n            ]\n        },\n    }\n)\n</code></pre>"},{"location":"schedulers/#task-group-configuration","title":"Task Group Configuration","text":"<pre><code>'taskGroups': [\n    {\n        'taskSpec': {\n            'runnables': [\n                {\n                    'container': {\n                        'imageUri': 'python:3.11',\n                        'entrypoint': 'python',\n                        'commands': ['-c', 'print(\"Hello\")']\n                    }\n                }\n            ],\n            'environment': {\n                'variables': {\n                    'MY_VAR': 'value'\n                }\n            },\n            'maxRetryCount': 3,\n        },\n        'taskCount': 100,        # Total number of tasks\n        'parallelism': 10,       # Max parallel tasks\n        'taskCountPerNode': 2,   # Tasks per VM\n    }\n]\n</code></pre>"},{"location":"schedulers/#use-cases_4","title":"Use Cases","text":"<ul> <li>Cloud-native processing</li> <li>Auto-scaling workloads</li> <li>Large-scale data processing</li> <li>Serverless batch jobs</li> </ul>"},{"location":"schedulers/#notes_3","title":"Notes","text":"<ul> <li>Requires Google Cloud project and authentication</li> <li>Uses Google Cloud Batch API</li> <li>Supports container-based jobs</li> <li>Auto-scales based on parallelism</li> </ul>"},{"location":"schedulers/#container-scheduler","title":"Container Scheduler","text":""},{"location":"schedulers/#overview_5","title":"Overview","text":"<p>Runs jobs in Docker containers. Best for: - Isolated job execution - Consistent environments - Reproducible workflows</p>"},{"location":"schedulers/#basic-usage_5","title":"Basic Usage","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='container',\n    forks=3,\n    scheduler_opts={\n        'image': 'python:3.11',\n        'entrypoint': '/bin/bash',\n    }\n)\n\nfor i in range(10):\n    await xqute.feed(['python', '-c', f'print({i})'])\n\nawait xqute.run_until_complete()\n</code></pre>"},{"location":"schedulers/#configuration-options_5","title":"Configuration Options","text":"<pre><code>xqute = Xqute(\n    scheduler='container',\n    forks=3,\n    scheduler_opts={\n        # Container image\n        'image': 'python:3.11',\n\n        # Container entrypoint\n        'entrypoint': '/bin/bash',\n\n        # Container runtime\n        'bin': 'docker',\n\n        # Volume mounts\n        'volumes': [\n            '/host/path:/container/path:ro',\n            '/data:/data:rw',\n        ],\n\n        # Environment variables\n        'envs': {\n            'MY_VAR': 'value',\n        },\n\n        # Additional options\n        'remove': True,  # Remove container after completion\n        'bin_args': ['--hostname', 'my-job'],\n    }\n)\n</code></pre>"},{"location":"schedulers/#volume-mounts","title":"Volume Mounts","text":"<p>Mount host directories into containers:</p> <pre><code>'volumes': [\n    # Format: host:container:mode\n    '/data:/data:rw',        # Read-write\n    '/scripts:/scripts:ro',   # Read-only\n    '/tmp:/tmp',             # Default read-write\n]\n</code></pre>"},{"location":"schedulers/#environment-variables","title":"Environment Variables","text":"<pre><code>'envs': {\n    'MY_VAR': 'value',\n    'ANOTHER_VAR': 'another value',\n}\n</code></pre>"},{"location":"schedulers/#additional-docker-arguments","title":"Additional Docker Arguments","text":"<pre><code>'bin_args': [\n    '--hostname', 'my-job',\n    '--network', 'host',\n    '--gpus', 'all',\n]\n</code></pre>"},{"location":"schedulers/#use-cases_5","title":"Use Cases","text":"<ul> <li>Isolated job execution</li> <li>Reproducible environments</li> <li>Testing across different environments</li> <li>Container-based workflows</li> </ul>"},{"location":"schedulers/#notes_4","title":"Notes","text":"<ul> <li>Requires Docker installed</li> <li>Containers are removed after completion if <code>remove=True</code></li> <li>Volumes must be accessible on all execution nodes</li> <li>Supports all Docker run options via <code>bin_args</code></li> </ul>"},{"location":"schedulers/#choosing-a-scheduler","title":"Choosing a Scheduler","text":"Scheduler Best For Scale Setup Complexity Local Development, small jobs Low None SGE University clusters High Low Slurm Modern HPC Very High Low SSH Multi-server clusters Medium Medium Google Batch Cloud workloads Very High High Container Isolated environments Medium Low"},{"location":"schedulers/#custom-schedulers","title":"Custom Schedulers","text":"<p>You can implement custom schedulers by subclassing the <code>Scheduler</code> base class:</p> <pre><code>from xqute import Scheduler\n\nclass MyScheduler(Scheduler):\n    name = 'mysched'\n\n    async def submit_job(self, job):\n        # Submit job to your scheduler\n        return job_id\n\n    async def kill_job(self, job):\n        # Kill the job\n        pass\n\n    async def job_is_running(self, job):\n        # Check if job is running\n        return True\n\n# Use your scheduler\nxqute = Xqute(scheduler=MyScheduler)\n</code></pre> <p>For more details, see Advanced Usage.</p>"},{"location":"schedulers/#next-steps","title":"Next Steps","text":"<ul> <li>User Guide - Comprehensive usage guide</li> <li>Plugins - Extend scheduler functionality</li> <li>Advanced Usage - Custom schedulers and advanced patterns</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":""},{"location":"user-guide/#user-guide","title":"User Guide","text":"<p>Comprehensive guide for using Xqute effectively.</p>"},{"location":"user-guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Core Concepts</li> <li>Initialization</li> <li>Job Management</li> <li>Execution Modes</li> <li>Error Handling</li> <li>Working Directories</li> <li>Environment Variables</li> <li>Job Output</li> <li>Monitoring</li> <li>Best Practices</li> </ul>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/#xqute","title":"Xqute","text":"<p>The main class that manages jobs and coordinates their execution. It acts as both a producer and consumer pattern:</p> <ul> <li>Producer: Feeds jobs into the buffer queue</li> <li>Consumer: Submits jobs to the scheduler</li> <li>Monitor: Polls job status and handles completion</li> </ul>"},{"location":"user-guide/#job","title":"Job","text":"<p>Represents a single unit of work with: - Command to execute - Metadata directory for logs and status - Environment variables - Status tracking</p>"},{"location":"user-guide/#scheduler","title":"Scheduler","text":"<p>Abstracts job execution for different backends. Each scheduler implementation handles: - Job submission - Status monitoring - Job cancellation</p>"},{"location":"user-guide/#initialization","title":"Initialization","text":""},{"location":"user-guide/#basic-initialization","title":"Basic Initialization","text":"<pre><code>from xqute import Xqute\n\n# Default: local scheduler, 1 fork\nxqute = Xqute()\n\n# Specify concurrency\nxqute = Xqute(forks=5)\n</code></pre>"},{"location":"user-guide/#full-initialization-options","title":"Full Initialization Options","text":"<pre><code>from xqute import Xqute\n\nxqute = Xqute(\n    scheduler='local',           # Scheduler type or class\n    plugins=None,                # Plugin list (e.g., ['myplugin'])\n    workdir='./.xqute',         # Job metadata directory\n    submission_batch=5,          # Parallel job submissions\n    error_strategy='retry',       # Error handling strategy\n    num_retries=3,               # Max retry attempts\n    forks=10,                   # Max concurrent jobs\n    scheduler_opts={},            # Scheduler-specific options\n    jobname_prefix='myjob',      # Job name prefix\n    recheck_interval=10,          # Recheck running jobs every N polls\n)\n</code></pre>"},{"location":"user-guide/#parameter-details","title":"Parameter Details","text":"Parameter Type Default Description <code>scheduler</code> str/Scheduler <code>'local'</code> Scheduler backend <code>plugins</code> list <code>None</code> Plugins to enable/disable <code>workdir</code> str/path <code>'./.xqute'</code> Job metadata directory <code>submission_batch</code> int <code>None</code> Parallel job submissions <code>error_strategy</code> str <code>'retry'</code> Error strategy (<code>'retry'</code> or <code>'halt'</code>) <code>num_retries</code> int <code>3</code> Max retry attempts <code>forks</code> int <code>1</code> Max concurrent jobs <code>scheduler_opts</code> dict <code>{}</code> Scheduler-specific options <code>jobname_prefix</code> str scheduler name Job name prefix <code>recheck_interval</code> int <code>10</code> Recheck interval (in polls)"},{"location":"user-guide/#job-management","title":"Job Management","text":""},{"location":"user-guide/#feeding-jobs","title":"Feeding Jobs","text":""},{"location":"user-guide/#simple-commands","title":"Simple Commands","text":"<pre><code># String command\nawait xqute.feed('echo \"Hello World\"')\n\n# List command\nawait xqute.feed(['echo', 'Hello World'])\n</code></pre>"},{"location":"user-guide/#with-environment-variables","title":"With Environment Variables","text":"<pre><code>await xqute.feed(\n    ['bash', '-c', 'echo $MY_VAR'],\n    envs={'MY_VAR': 'value'}\n)\n</code></pre>"},{"location":"user-guide/#multiple-jobs","title":"Multiple Jobs","text":"<pre><code>for i in range(100):\n    await xqute.feed(['python', 'process.py', str(i)])\n</code></pre>"},{"location":"user-guide/#job-objects","title":"Job Objects","text":"<p>Create jobs directly:</p> <pre><code>from xqute import Job\n\njob = Job(\n    index=0,\n    cmd=['echo', 'test'],\n    workdir='./.xqute',\n    error_retry=True,\n    num_retries=3,\n)\nawait xqute.feed(job)\n</code></pre>"},{"location":"user-guide/#job-metadata","title":"Job Metadata","text":"<p>Each job has a metadata directory containing:</p> <pre><code>.xqute/\n\u251c\u2500\u2500 0/                  # Job index\n\u2502   \u251c\u2500\u2500 job.stdout       # Standard output\n\u2502   \u251c\u2500\u2500 job.stderr       # Standard error\n\u2502   \u251c\u2500\u2500 job.status       # Job status\n\u2502   \u251c\u2500\u2500 job.rc          # Return code\n\u2502   \u251c\u2500\u2500 job.jid        # Scheduler job ID\n\u2502   \u251c\u2500\u2500 job.retry/     # Retry history (if retried)\n\u2502   \u2514\u2500\u2500 job.wrapped.local  # Wrapped script\n\u2514\u2500\u2500 1/\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"user-guide/#execution-modes","title":"Execution Modes","text":""},{"location":"user-guide/#traditional-mode-default","title":"Traditional Mode (Default)","text":"<p>Add all jobs first, then wait for completion:</p> <pre><code>async def main():\n    xqute = Xqute(forks=5)\n\n    # Add all jobs\n    for i in range(100):\n        await xqute.feed(['echo', f'Job {i}'])\n\n    # Wait for all to complete\n    await xqute.run_until_complete()\n</code></pre>"},{"location":"user-guide/#daemon-mode-keep-feeding","title":"Daemon Mode (Keep Feeding)","text":"<p>Add jobs while running:</p> <pre><code>async def main():\n    xqute = Xqute(forks=5)\n\n    # Start in background\n    await xqute.run_until_complete(keep_feeding=True)\n\n    # Add jobs dynamically\n    for i in range(100):\n        await xqute.feed(['echo', f'Job {i}'])\n\n    # Signal completion and wait\n    await xqute.stop_feeding()\n</code></pre>"},{"location":"user-guide/#checking-feeding-status","title":"Checking Feeding Status","text":"<pre><code>if xqute.is_feeding():\n    await xqute.stop_feeding()\n</code></pre>"},{"location":"user-guide/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/#error-strategies","title":"Error Strategies","text":""},{"location":"user-guide/#retry-strategy-default","title":"Retry Strategy (Default)","text":"<p>Automatically retry failed jobs:</p> <pre><code>xqute = Xqute(\n    error_strategy='retry',\n    num_retries=3,\n)\n</code></pre> <p>When a job fails: 1. Job metadata is backed up to <code>.xqute/&lt;index&gt;/job.retry/&lt;trial&gt;</code> 2. Job status is reset to QUEUED 3. Job is resubmitted</p>"},{"location":"user-guide/#halt-strategy","title":"Halt Strategy","text":"<p>Stop execution on first failure:</p> <pre><code>xqute = Xqute(\n    error_strategy='halt',\n)\n</code></pre> <p>When a job fails: 1. All running jobs are killed 2. No more jobs are submitted 3. Execution terminates with SIGTERM</p>"},{"location":"user-guide/#per-job-error-handling","title":"Per-Job Error Handling","text":"<p>Override error strategy per job:</p> <pre><code>from xqute import Job\n\njob = Job(\n    index=0,\n    cmd=['risky-command'],\n    workdir='./.xqute',\n    error_retry=False,  # Disable retry for this job\n)\n</code></pre>"},{"location":"user-guide/#working-directories","title":"Working Directories","text":""},{"location":"user-guide/#local-working-directory","title":"Local Working Directory","text":"<pre><code>xqute = Xqute(workdir='./myjobs')\n</code></pre>"},{"location":"user-guide/#cloud-working-directory","title":"Cloud Working Directory","text":"<pre><code>xqute = Xqute(\n    workdir='gs://my-bucket/jobs',\n    scheduler_opts={\n        'mounted_workdir': '/mnt/jobs',  # Mount point\n    }\n)\n</code></pre>"},{"location":"user-guide/#mounted-paths","title":"Mounted Paths","text":"<p>For cloud storage, specify mount point:</p> <pre><code>xqute = Xqute(\n    workdir='gs://bucket/jobs',\n    scheduler_opts={\n        'mounted_workdir': '/mnt/gs',\n    }\n)\n</code></pre>"},{"location":"user-guide/#environment-variables","title":"Environment Variables","text":""},{"location":"user-guide/#built-in-variables","title":"Built-in Variables","text":"<p>Xqute automatically sets these environment variables for each job:</p> Variable Description <code>XQUTE_JOB_INDEX</code> Job index number <code>XQUTE_METADIR</code> Main metadata directory <code>XQUTE_JOB_METADIR</code> Job-specific metadata directory"},{"location":"user-guide/#custom-variables","title":"Custom Variables","text":"<pre><code>await xqute.feed(\n    ['bash', '-c', 'echo $MY_CUSTOM_VAR'],\n    envs={\n        'MY_CUSTOM_VAR': 'value',\n        'ANOTHER_VAR': 'another value',\n    }\n)\n</code></pre>"},{"location":"user-guide/#accessing-in-jobs","title":"Accessing in Jobs","text":"<pre><code>await xqute.feed(\n    ['python', '-c', '''\nimport os\nprint(f\"Job index: {os.getenv('XQUTE_JOB_INDEX')}\")\nprint(f\"Custom: {os.getenv('MY_VAR')}\")\n'''],\n    envs={'MY_VAR': 'custom'}\n)\n</code></pre>"},{"location":"user-guide/#job-output","title":"Job Output","text":""},{"location":"user-guide/#reading-output-after-completion","title":"Reading Output After Completion","text":"<pre><code>async def main():\n    xqute = Xqute(forks=3)\n\n    await xqute.feed(['echo', 'Hello'])\n    await xqute.run_until_complete()\n\n    # Read output\n    job = xqute.jobs[0]\n    stdout = await job.stdout_file.a_read_text()\n    stderr = await job.stderr_file.a_read_text()\n    rc = await job.get_rc()\n\n    print(f\"Output: {stdout}\")\n    print(f\"Errors: {stderr}\")\n    print(f\"Return code: {rc}\")\n</code></pre>"},{"location":"user-guide/#stream-output-during-execution","title":"Stream Output During Execution","text":"<p>Use plugins to stream output (see Plugins).</p>"},{"location":"user-guide/#output-file-locations","title":"Output File Locations","text":"<pre><code>job = xqute.jobs[0]\nprint(f\"stdout: {job.stdout_file}\")\nprint(f\"stderr: {job.stderr_file}\")\nprint(f\"status: {job.status_file}\")\nprint(f\"rc: {job.rc_file}\")\n</code></pre>"},{"location":"user-guide/#monitoring","title":"Monitoring","text":""},{"location":"user-guide/#job-status","title":"Job Status","text":"<pre><code>from xqute.defaults import JobStatus\n\nstatus = await job.get_status()\n\nstatus_name = JobStatus.get_name(status)\nprint(f\"Job status: {status_name}\")\n</code></pre>"},{"location":"user-guide/#status-values","title":"Status Values","text":"Status Value Description <code>INIT</code> 0 Job initialized <code>QUEUED</code> 1 Job queued for submission <code>SUBMITTED</code> 2 Job submitted to scheduler <code>RUNNING</code> 3 Job is running <code>FINISHED</code> 4 Job completed successfully <code>FAILED</code> 5 Job failed <code>KILLING</code> 6 Job is being killed"},{"location":"user-guide/#checking-multiple-jobs","title":"Checking Multiple Jobs","text":"<pre><code>import asyncio\n\nasync def check_all_jobs():\n    statuses = await asyncio.gather(\n        *[job.get_status(refresh=True) for job in xqute.jobs]\n    )\n\n    for job, status in zip(xqute.jobs, statuses):\n        status_name = JobStatus.get_name(status)\n        print(f\"Job {job.index}: {status_name}\")\n</code></pre>"},{"location":"user-guide/#completion-tracking","title":"Completion Tracking","text":"<pre><code># Wait for specific job to complete\nfrom xqute.defaults import JobStatus\n\nwhile True:\n    status = await xqute.jobs[0].get_status(refresh=True)\n    if status in (JobStatus.FINISHED, JobStatus.FAILED):\n        break\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"user-guide/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/#1-choose-appropriate-concurrency","title":"1. Choose Appropriate Concurrency","text":"<pre><code># Local machine: match CPU cores\nimport os\nxqute = Xqute(forks=os.cpu_count())\n\n# Slurm: match allocated resources\nxqute = Xqute(forks=100)\n</code></pre>"},{"location":"user-guide/#2-use-submission-batching","title":"2. Use Submission Batching","text":"<pre><code># For high-latency schedulers\nxqute = Xqute(\n    scheduler='slurm',\n    submission_batch=10,  # Submit 10 jobs at once\n)\n</code></pre>"},{"location":"user-guide/#3-monitor-resource-usage","title":"3. Monitor Resource Usage","text":"<pre><code># Check running jobs before adding more\nif len([j for j in xqute.jobs if j._status == JobStatus.RUNNING]) &lt; 100:\n    await xqute.feed(['next-job'])\n</code></pre>"},{"location":"user-guide/#4-handle-large-output","title":"4. Handle Large Output","text":"<pre><code># Write output to files instead of stdout\nawait xqute.feed([\n    'python', 'process.py',\n    '--output', f'{job.metadir}/output.txt'\n])\n</code></pre>"},{"location":"user-guide/#5-use-descriptive-job-names","title":"5. Use Descriptive Job Names","text":"<pre><code>xqute = Xqute(\n    jobname_prefix='myproject',\n    scheduler_opts={'job_name': 'batch1'}\n)\n</code></pre>"},{"location":"user-guide/#6-cleanup-old-jobs","title":"6. Cleanup Old Jobs","text":"<pre><code># Clean up old metadata\nimport shutil\nif os.path.exists('./.xqute'):\n    shutil.rmtree('./.xqute')\n</code></pre>"},{"location":"user-guide/#7-logging-configuration","title":"7. Logging Configuration","text":"<pre><code>from xqute.utils import logger\nimport logging\n\nlogger.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"user-guide/#8-error-recovery","title":"8. Error Recovery","text":"<pre><code>try:\n    await xqute.run_until_complete()\nexcept Exception as e:\n    logger.error(f\"Failed: {e}\")\n\n    # Check failed jobs\n    failed = [\n        job for job in xqute.jobs\n        if await job.get_status() == JobStatus.FAILED\n    ]\n    logger.info(f\"Failed jobs: {len(failed)}\")\n</code></pre>"},{"location":"user-guide/#9-graceful-shutdown","title":"9. Graceful Shutdown","text":"<pre><code># Signal handler\nasync def shutdown_handler():\n    logger.info(\"Shutting down...\")\n    await xqute.stop_feeding()\n\n# Handle Ctrl+C\nimport signal\nloop = asyncio.get_running_loop()\nloop.add_signal_handler(signal.SIGINT, lambda: asyncio.create_task(shutdown_handler()))\n</code></pre>"},{"location":"user-guide/#10-cloud-storage-best-practices","title":"10. Cloud Storage Best Practices","text":"<pre><code># Use local cache for cloud paths\nxqute = Xqute(\n    workdir='gs://bucket/jobs',\n    scheduler_opts={\n        'mounted_workdir': '/mnt/gs',\n        'cache_dir': '/tmp/cache',  # Local cache\n    }\n)\n</code></pre>"},{"location":"user-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/#jobs-stuck-in-submitted-status","title":"Jobs Stuck in SUBMITTED Status","text":"<p>Check if job failed before running:</p> <pre><code># Check scheduler logs\nqstat -j &lt;job_id&gt;  # SGE\nsqueue -j &lt;job_id&gt;  # Slurm\n</code></pre>"},{"location":"user-guide/#high-memory-usage","title":"High Memory Usage","text":"<p>Reduce concurrency:</p> <pre><code>xqute = Xqute(forks=5)  # Reduce from default\n</code></pre>"},{"location":"user-guide/#slow-job-submission","title":"Slow Job Submission","text":"<p>Increase submission batch:</p> <pre><code>xqute = Xqute(\n    scheduler='slurm',\n    submission_batch=20,\n)\n</code></pre>"},{"location":"user-guide/#next-steps","title":"Next Steps","text":"<ul> <li>Schedulers - Learn about specific scheduler backends</li> <li>Plugins - Extend Xqute functionality</li> <li>Advanced Usage - Advanced patterns and customization</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"api/xqute.defaults/","title":"xqute.defaults","text":"module &lt;/&gt; <p>Default settings and utilities for xqute</p> Attributes <ul> <li><code>DEFAULT_ERROR_STRATEGY</code> (str) \u2014 The default strategy when there iserror happened </li> <li><code>DEFAULT_JOB_CMD_WRAPPER_SHELL</code> \u2014 The default shell for job wrapper</li> <li><code>DEFAULT_NUM_RETRIES</code> (int) \u2014 Default number of retries whenDEFAULT_ERROR_STRATEGY is retry </li> <li><code>DEFAULT_SCHEDULER_FORKS</code> (int) \u2014 Default number of job forks for scheduler</li> <li><code>DEFAULT_WORKDIR</code> \u2014 The default work directory for jobs to save the metadata</li> </ul> Classes <ul> <li><code>JobErrorStrategy</code> \u2014 The strategy when error happen from jobs&lt;/&gt;</li> <li><code>JobStatus</code> \u2014 The status of a job&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_jobcmd_wrapper_init</code><code>(</code><code>local</code><code>)</code> (str) \u2014 Get the job command wrapper initialization script&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The strategy when error happen from jobs</p> Attributes <ul> <li><code>HALT</code> \u2014 halt the whole program</li> <li><code>IGNORE</code> \u2014 ignore and run next jobs</li> <li><code>RETRY</code> \u2014 retry the job</li> </ul> class &lt;/&gt; <p>The status of a job</p><p>Life cycles: ........................queued in scheduler INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; FINISHED (FAILED) INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; KILLING -&gt; FINISHED INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; KILLING -&gt; FINISHED INIT -&gt; QUEUED -&gt; (CANCELLED)</p> <p>Note that RUNNING, FINISHED and FAILED are the statuses that are polled from the scheduler. They can not be set directly by xqute; they are set in the job wrapper script.</p> Attributes <ul> <li><code># RETRYING</code> \u2014 When a job is to be retried</li> <li><code>FAILED</code> \u2014 When a job is failed</li> <li><code>FINISHED</code> \u2014 When a job is finished</li> <li><code>INIT</code> \u2014 When a job is initialized</li> <li><code>KILLING</code> \u2014 When a job is being killed</li> <li><code>QUEUED</code> \u2014 When a job is queued</li> <li><code>RUNNING</code> \u2014 When a job is running</li> <li><code>SUBMITTED</code> \u2014 When a job is submitted</li> </ul> Methods <ul> <li><code>get_name</code><code>(</code><code>*statuses</code><code>)</code> (Union) \u2014 Get the name of the status&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Get the name of the status</p> Parameters <ul> <li><code>*statuses</code> (int) \u2014 The status values</li> </ul> Returns (Union) <p>The name of the status if a single status is passed, otherwisea tuple of names</p> function &lt;/&gt; <p>Get the job command wrapper initialization script</p> Parameters <ul> <li><code>local</code> (bool) \u2014 Whether the job is running locally</li> </ul> Returns (str) <p>The job command wrapper initialization script</p>"},{"location":"api/xqute.defaults/#xqutedefaults","title":"xqute.defaults","text":""},{"location":"api/xqute.defaults/#xqutedefaultsjoberrorstrategy","title":"<code>xqute.defaults.</code><code>JobErrorStrategy</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.defaults/#xqutedefaultsjobstatus","title":"<code>xqute.defaults.</code><code>JobStatus</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.defaults/#xqutedefaultsjobstatusget_name","title":"<code>get_name</code><code>(</code><code>*statuses</code><code>)</code>","text":""},{"location":"api/xqute.defaults/#xqutedefaultsget_jobcmd_wrapper_init","title":"<code>xqute.defaults.</code><code>get_jobcmd_wrapper_init</code><code>(</code><code>local</code><code>)</code>","text":""},{"location":"api/xqute.job/","title":"xqute.job","text":"module &lt;/&gt; <p>Job to execute</p> Classes <ul> <li><code>Job</code> \u2014 The class for job&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The class for job</p> Attributes <ul> <li><code>jid_file</code> (SpecPath) \u2014 The jid file of the job&lt;/&gt;</li> <li><code>rc_file</code> (SpecPath) \u2014 The rc file of the job&lt;/&gt;</li> <li><code>retry_dir</code> (SpecPath) \u2014 The retry directory of the job&lt;/&gt;</li> <li><code>status_file</code> (SpecPath) \u2014 The status file of the job&lt;/&gt;</li> <li><code>stderr_file</code> (SpecPath) \u2014 The stderr file of the job&lt;/&gt;</li> <li><code>stdout_file</code> (SpecPath) \u2014 The stdout file of the job&lt;/&gt;</li> </ul> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> <li><code>error_retry</code> (bool | none, optional) \u2014 Whether we should retry if error happened</li> <li><code>num_retries</code> (int | none, optional) \u2014 Total number of retries</li> <li><code>metadir</code> \u2014 The meta directory of the Job</li> </ul> Methods <ul> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 repr of the job&lt;/&gt;</li> <li><code>clean</code><code>(</code><code>retry</code><code>)</code> \u2014 Clean up the meta files&lt;/&gt;</li> <li><code>get_jid</code><code>(</code><code>)</code> (int | str | none) \u2014 Get the jid of the job in scheduler system&lt;/&gt;</li> <li><code>get_rc</code><code>(</code><code>)</code> (int) \u2014 The return code of the job&lt;/&gt;</li> <li><code>get_status</code><code>(</code><code>refresh</code><code>)</code> (int) \u2014 Query the status of the job&lt;/&gt;</li> <li><code>set_rc</code><code>(</code><code>rc</code><code>)</code> \u2014 Set the return code of the job&lt;/&gt;</li> <li><code>set_status</code><code>(</code><code>stat</code>, <code>flush</code><code>)</code> \u2014 Set the status manually&lt;/&gt;</li> </ul> method &lt;/&gt; <p>repr of the job</p> method &lt;/&gt; <p>Get the jid of the job in scheduler system</p> method &lt;/&gt; <p>Query the status of the job</p><p>If the job is submitted, try to query it from the status file Make sure the status is updated by trap in wrapped script</p> <p>Uses caching to avoid excessive file I/O. Cache is invalidated when status is explicitly set.</p> Parameters <ul> <li><code>refresh</code> (bool, optional) \u2014 Whether to refresh the status from file</li> </ul> method &lt;/&gt; <p>Set the status manually</p> Parameters <ul> <li><code>stat</code> (int) \u2014 The status to set</li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to file</li> </ul> method &lt;/&gt; <p>The return code of the job</p> method &lt;/&gt; <p>Set the return code of the job</p> Parameters <ul> <li><code>rc</code> (int | str) \u2014 The return code</li> </ul> method &lt;/&gt; <p>Clean up the meta files</p> Parameters <ul> <li><code>retry</code> (bool, optional) \u2014 Whether clean it for retrying</li> </ul>"},{"location":"api/xqute.job/#xqutejob","title":"xqute.job","text":""},{"location":"api/xqute.job/#xqutejobjob","title":"<code>xqute.job.</code><code>Job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>workdir</code>, <code>error_retry=None</code>, <code>num_retries=None</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.job/#xqutejobjobrepr","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.job/#xqutejobjobget_jid","title":"<code>get_jid</code><code>(</code><code>)</code> \u2192 int | str | none","text":""},{"location":"api/xqute.job/#xqutejobjobget_status","title":"<code>get_status</code><code>(</code><code>refresh=False</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.job/#xqutejobjobset_status","title":"<code>set_status</code><code>(</code><code>stat</code>, <code>flush=True</code><code>)</code>","text":""},{"location":"api/xqute.job/#xqutejobjobget_rc","title":"<code>get_rc</code><code>(</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.job/#xqutejobjobset_rc","title":"<code>set_rc</code><code>(</code><code>rc</code><code>)</code>","text":""},{"location":"api/xqute.job/#xqutejobjobclean","title":"<code>clean</code><code>(</code><code>retry=False</code><code>)</code>","text":""},{"location":"api/xqute/","title":"xqute","text":"package &lt;/&gt; <p>A job management system for python</p> module &lt;/&gt; <p>The xqute module</p> Classes <ul> <li><code>Xqute</code> \u2014 The main class of the package&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Utilities for xqute</p> module &lt;/&gt; <p>Hook specifications for scheduler plugins</p> Functions <ul> <li><code>on_init</code><code>(</code><code>xqute</code><code>)</code> \u2014 When xqute is initialized&lt;/&gt;</li> <li><code>on_job_failed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is failed&lt;/&gt;</li> <li><code>on_job_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is initialized&lt;/&gt;</li> <li><code>on_job_killed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is killed&lt;/&gt;</li> <li><code>on_job_killing</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is being killed&lt;/&gt;</li> <li><code>on_job_polling</code><code>(</code><code>scheduler</code>, <code>job</code>, <code>counter</code><code>)</code> \u2014 When the system is polling job status&lt;/&gt;</li> <li><code>on_job_queued</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is queued&lt;/&gt;</li> <li><code>on_job_started</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job starts to run.&lt;/&gt;</li> <li><code>on_job_submitted</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is submitted&lt;/&gt;</li> <li><code>on_job_submitting</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is to be submitted&lt;/&gt;</li> <li><code>on_job_succeeded</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is succeeded&lt;/&gt;</li> <li><code>on_jobcmd_end</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command finishes and after the postscript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command wrapper script is initialized before the prescript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_prep</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command right about to be runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>. For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins. &lt;/&gt;</li> <li><code>on_shutdown</code><code>(</code><code>xqute</code>, <code>sig</code><code>)</code> \u2014 When xqute is shutting down&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Job to execute</p> Classes <ul> <li><code>Job</code> \u2014 The class for job&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to schedule jobs</p> Classes <ul> <li><code>Scheduler</code><code>(</code><code>workdir</code>, <code>forks</code>, <code>error_strategy</code>, <code>num_retries</code>, <code>prescript</code>, <code>postscript</code>, <code>jobname_prefix</code>, <code>submission_batch</code>, <code>recheck_interval</code>, <code>cwd</code>, <code>**kwargs</code><code>)</code> \u2014 The abstract class for scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides the SpecPath and MountedPath classes.</p><p>It is used to represent paths of jobs and it is useful when a job is running in a remote system (a VM, a container, etc.), where we need to mount the paths into the remote system (MountedPath).</p> <p>But in the system where this framework is running, we need to use the paths (specified directly) that are used in the framework, where we also need to carry the information of the mounted path (SpecPath).</p> <p>The module provides two main abstract base classes: <ul><li>- <code>MountedPath</code>: Represents a path as it appears in the remote execution environment.</li><li>- <code>SpecPath</code>: Represents a path as it appears in the local environment where the</li></ul>framework runs.</p><p>Both classes have implementations for local paths and various cloud storage paths, including: <ul><li>- Google Cloud Storage</li><li>- Azure Blob Storage</li><li>- Amazon S3</li></ul><p>These classes maintain the relationship between the local and remote pathrepresentations, allowing transparent path operations while preserving both path contexts.</p> Classes <ul> <li><code>MountedPath</code> (MountedPath) \u2014 A router class to instantiate the correct path based on the path typefor the mounted path. &lt;/&gt;</li> <li><code>MountedLocalPath</code> (MountedPath) \u2014 A class to represent a mounted local path&lt;/&gt;</li> <li><code>MountedCloudPath</code><code>(</code><code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (MountedPath) \u2014 A class to represent a mounted cloud path&lt;/&gt;</li> <li><code>MountedGSPath</code> (MountedPath) \u2014 A class to represent a mounted Google Cloud Storage path&lt;/&gt;</li> <li><code>MountedAzurePath</code> (MountedPath) \u2014 A class to represent a mounted Azure Blob Storage path&lt;/&gt;</li> <li><code>MountedS3Path</code> (MountedPath) \u2014 A class to represent a mounted Amazon S3 path&lt;/&gt;</li> <li><code>SpecPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A router class to instantiate the correct path based on the path typefor the spec path. &lt;/&gt;</li> <li><code>SpecLocalPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec local path&lt;/&gt;</li> <li><code>SpecCloudPath</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec cloud path&lt;/&gt;</li> <li><code>SpecGSPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec Google Cloud Storage path&lt;/&gt;</li> <li><code>SpecAzurePath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec Azure Blob Storage path&lt;/&gt;</li> <li><code>SpecS3Path</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec Amazon S3 path&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Default settings and utilities for xqute</p> Attributes <ul> <li><code>DEFAULT_ERROR_STRATEGY</code> (str) \u2014 The default strategy when there iserror happened </li> <li><code>DEFAULT_JOB_CMD_WRAPPER_SHELL</code> \u2014 The default shell for job wrapper</li> <li><code>DEFAULT_NUM_RETRIES</code> (int) \u2014 Default number of retries whenDEFAULT_ERROR_STRATEGY is retry </li> <li><code>DEFAULT_SCHEDULER_FORKS</code> (int) \u2014 Default number of job forks for scheduler</li> <li><code>DEFAULT_WORKDIR</code> \u2014 The default work directory for jobs to save the metadata</li> </ul> Classes <ul> <li><code>JobErrorStrategy</code> \u2014 The strategy when error happen from jobs&lt;/&gt;</li> <li><code>JobStatus</code> \u2014 The status of a job&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_jobcmd_wrapper_init</code><code>(</code><code>local</code><code>)</code> (str) \u2014 Get the job command wrapper initialization script&lt;/&gt;</li> </ul> package &lt;/&gt; <p>Builtin schedulers</p> Functions <ul> <li><code>get_scheduler</code><code>(</code><code>scheduler</code><code>)</code> (Type) \u2014 Get the scheduler class&lt;/&gt;</li> </ul>"},{"location":"api/xqute/#xqute","title":"xqute","text":""},{"location":"api/xqute/#xqutexqute","title":"xqute.xqute","text":""},{"location":"api/xqute/#xquteutils","title":"xqute.utils","text":""},{"location":"api/xqute/#xquteplugin","title":"xqute.plugin","text":""},{"location":"api/xqute/#xqutejob","title":"xqute.job","text":""},{"location":"api/xqute/#xqutescheduler","title":"xqute.scheduler","text":""},{"location":"api/xqute/#xqutepath","title":"xqute.path","text":""},{"location":"api/xqute/#xqutedefaults","title":"xqute.defaults","text":""},{"location":"api/xqute/#xquteschedulers","title":"xqute.schedulers","text":""},{"location":"api/xqute.path/","title":"xqute.path","text":"module &lt;/&gt; <p>Provides the SpecPath and MountedPath classes.</p><p>It is used to represent paths of jobs and it is useful when a job is running in a remote system (a VM, a container, etc.), where we need to mount the paths into the remote system (MountedPath).</p> <p>But in the system where this framework is running, we need to use the paths (specified directly) that are used in the framework, where we also need to carry the information of the mounted path (SpecPath).</p> <p>The module provides two main abstract base classes: <ul><li>- <code>MountedPath</code>: Represents a path as it appears in the remote execution environment.</li><li>- <code>SpecPath</code>: Represents a path as it appears in the local environment where the</li></ul>framework runs.</p><p>Both classes have implementations for local paths and various cloud storage paths, including: <ul><li>- Google Cloud Storage</li><li>- Azure Blob Storage</li><li>- Amazon S3</li></ul><p>These classes maintain the relationship between the local and remote pathrepresentations, allowing transparent path operations while preserving both path contexts.</p> Classes <ul> <li><code>MountedPath</code> (MountedPath) \u2014 A router class to instantiate the correct path based on the path typefor the mounted path. &lt;/&gt;</li> <li><code>MountedLocalPath</code> (MountedPath) \u2014 A class to represent a mounted local path&lt;/&gt;</li> <li><code>MountedCloudPath</code><code>(</code><code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (MountedPath) \u2014 A class to represent a mounted cloud path&lt;/&gt;</li> <li><code>MountedGSPath</code> (MountedPath) \u2014 A class to represent a mounted Google Cloud Storage path&lt;/&gt;</li> <li><code>MountedAzurePath</code> (MountedPath) \u2014 A class to represent a mounted Azure Blob Storage path&lt;/&gt;</li> <li><code>MountedS3Path</code> (MountedPath) \u2014 A class to represent a mounted Amazon S3 path&lt;/&gt;</li> <li><code>SpecPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A router class to instantiate the correct path based on the path typefor the spec path. &lt;/&gt;</li> <li><code>SpecLocalPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec local path&lt;/&gt;</li> <li><code>SpecCloudPath</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec cloud path&lt;/&gt;</li> <li><code>SpecGSPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec Google Cloud Storage path&lt;/&gt;</li> <li><code>SpecAzurePath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec Azure Blob Storage path&lt;/&gt;</li> <li><code>SpecS3Path</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A class to represent a spec Amazon S3 path&lt;/&gt;</li> </ul> class &lt;/&gt; Bases panpath.base.PanPath pathlib.Path pathlib.PurePath <p>A router class to instantiate the correct path based on the path typefor the mounted path.</p> <p>This abstract base class serves as a factory that creates appropriate mounted path instances based on the input path type. It represents a path as it exists in a remote execution environment (e.g., container, VM) while maintaining a reference to the corresponding path in the local environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment (SpecPath).</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; # Create a mounted path with corresponding spec path&gt;&gt;&gt; mounted_path = MountedPath(\n&gt;&gt;&gt;   \"/container/data/file.txt\", spec=\"/local/data/file.txt\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; str(mounted_path)\n'/container/data/file.txt'\n&gt;&gt;&gt; str(mounted_path.spec)\n'/local/data/file.txt'\n</code></pre> <pre><code>&gt;&gt;&gt; # Create a GCS mounted path\n&gt;&gt;&gt; gs_path = MountedPath(\"gs://bucket/file.txt\", spec=\"/local/file.txt\")\n&gt;&gt;&gt; type(gs_path)\n&lt;class 'xqute.path.MountedGSPath'&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; # Serialize and deserialize a mounted path\n&gt;&gt;&gt; import pickle\n&gt;&gt;&gt; mounted_path = MountedPath(\"/container/data/file.txt\",\n...                            spec=\"/local/data/file.txt\")\n&gt;&gt;&gt; serialized = pickle.dumps(mounted_path)\n&gt;&gt;&gt; restored = pickle.loads(serialized)\n&gt;&gt;&gt; str(restored) == str(mounted_path)\nTrue\n&gt;&gt;&gt; str(restored.spec) == str(mounted_path.spec)\nTrue\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate MountedPath subclass based on the path type) \u2014 Factory method to create the appropriate MountedPath subclass instance.&lt;/&gt;</li> <li><code>__reduce__</code><code>(</code><code>)</code> \u2014 Support for pickling and serialization.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__setstate__</code><code>(</code><code>state</code><code>)</code> \u2014 Restore internal state after unpickling.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> \u2014 Return the string representation of the path, suitable forpassing to system calls. &lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (MountedPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Asynchronously copy this path to the target path.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Asynchronously copy the directory and all its contents recursively to the target path.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously yield paths matching a glob pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path is a symbolic link.&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously iterate over directory contents.&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Asynchronously create a directory at this path.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Asynchronously open the file and return an async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Asynchronously read the file's bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Asynchronously read the file's text content.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (PanPath) \u2014 Asynchronously read the target of the symbolic link.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Asynchronously rename this path to the target path.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Asynchronously replace this path with the target path.&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously yield paths matching a recursive glob pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Asynchronously remove the directory and its contents recursively.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Asynchronously remove the directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Asynchronously get the file or directory's status information.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Asynchronously create a symbolic link pointing to the target path.&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Asynchronously create the file if it does not exist.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Asynchronously remove (delete) the file or empty directory.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously walk the directory tree.&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> (Optional) \u2014 Asynchronously write bytes to the file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Asynchronously write text to the file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> \u2014 Return the path as a 'file' URI.&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern. &lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> \u2014 True if the path is absolute (has both a root and, if applicable,a drive). &lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> \u2014 Whether this path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files). &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> \u2014 Whether this path is a symbolic link.&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Return True if this path matches the given pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does. &lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> \u2014 Open the file in bytes mode, read it, and close the file.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code><code>)</code> \u2014 Open the file in text mode, read it, and close the file.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> \u2014 Return the path to which the symbolic link points.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it. &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree. &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()). &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does. &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink. &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead. &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> \u2014 Walk the directory tree.&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (MountedPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (MountedPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Open the file in bytes mode, write to it, and close the file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file in text mode, write to it, and close the file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path, suitable forpassing to system calls.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the path as a 'file' URI.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive).</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Return True if this path matches the given pattern.</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.</p> method &lt;/&gt; <p>Whether this path is a directory.</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a symbolic link.</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file.</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Return the path to which the symbolic link points.</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist.</p> method &lt;/&gt; <p>Create a new directory at this given path.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty.</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Asynchronously check if the path exists.</p> Returns (bool) <p>True if the path exists, False otherwise.</p> method &lt;/&gt; <p>Asynchronously read the file's bytes.</p> Returns (bytes) <p>File content as bytes.</p> method &lt;/&gt; <p>Asynchronously read the file's text content.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> Returns (str) <p>File content as string.</p> method &lt;/&gt; <p>Asynchronously write bytes to the file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> Returns (Optional) <p>Number of bytes written. For some cloud paths, may return None.</p> method &lt;/&gt; <p>Asynchronously write text to the file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> Returns (int) <p>Number of characters written.</p> method &lt;/&gt; <p>Asynchronously remove (delete) the file or empty directory.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>Asynchronously iterate over directory contents.</p> Yields (AsyncGenerator) <p>PanPath instances for each item in the directory.</p> method &lt;/&gt; <p>Asynchronously check if the path is a directory.</p> Returns (bool) <p>True if the path is a directory, False otherwise.</p> method &lt;/&gt; <p>Asynchronously check if the path is a file.</p> Returns (bool) <p>True if the path is a file, False otherwise.</p> method &lt;/&gt; <p>Asynchronously get the file or directory's status information.</p> Returns (stat_result) <p>An object containing file status information (platform-dependent).</p> method &lt;/&gt; <p>Asynchronously create a directory at this path.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Directory mode (permissions) to set.</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, does not raise an error if the directory already exists.</li> </ul> method &lt;/&gt; <p>Asynchronously yield paths matching a glob pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Glob pattern to match.</li> </ul> Returns (AsyncGenerator) <p>List of PanPath instances matching the pattern.</p> method &lt;/&gt; <p>Asynchronously yield paths matching a recursive glob pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Recursive glob pattern to match.</li> </ul> Returns (AsyncGenerator) <p>List of PanPath instances matching the pattern.</p> method &lt;/&gt; <p>Asynchronously walk the directory tree.</p> Yields (AsyncGenerator) <p>Tuples of (current_path, dirnames, filenames) at each level.</p> method &lt;/&gt; <p>Asynchronously create the file if it does not exist.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raises an error if the file already exists.</li> </ul> method &lt;/&gt; <p>Asynchronously rename this path to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path to rename to.</li> </ul> Returns (PanPath) <p>The renamed PanPath instance.</p> method &lt;/&gt; <p>Asynchronously replace this path with the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path to replace with.</li> </ul> Returns (PanPath) <p>The replaced PanPath instance.</p> method &lt;/&gt; <p>Asynchronously remove the directory and its contents recursively.</p> method &lt;/&gt; <p>Asynchronously check if the path is a symbolic link.</p><p>For local path, this checks if the path is a symlink. For cloud paths, this will check if the object has a metdata flag indicating it's a symlink. Note that it is not a real symlink like in local filesystems. But for example, gcsfuse supports symlink-like behavior via metadata.</p> Returns (bool) <p>True if the path is a symlink, False otherwise.</p> method &lt;/&gt; <p>Asynchronously read the target of the symbolic link.</p><p>For local path, this reads the symlink target. For cloud paths, this reads the metadata flag indicating the symlink target.</p> Returns (PanPath) <p>The target PanPath of the symlink.</p> method &lt;/&gt; <p>Asynchronously create a symbolic link pointing to the target path.</p><p>For local path, this creates a real symlink. For cloud paths, this sets a metadata flag indicating the symlink target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 The target PanPath the symlink points to.</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Whether the target is a directory (ignored for cloud paths).</li> </ul> method &lt;/&gt; <p>Asynchronously remove the directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, ignores errors during removal.</li> <li><code>onerror</code> (Any, optional) \u2014 Optional function to call on errors.</li> </ul> method &lt;/&gt; <p>Asynchronously copy this path to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Asynchronously copy the directory and all its contents recursively to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, copies the contents of symlinks.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Asynchronously open the file and return an async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 Mode to open the file (e.g., 'r', 'rb', 'w', 'wb').</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8').</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments to pass to the underlying open method.</li> </ul> Returns (AsyncFileHandle) <p>An async file handle.</p> method &lt;/&gt; <p>Walk the directory tree.</p> Yields <p>Tuples of (current_path, dirnames, filenames) at each level.</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate MountedPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the mounted path location.</li> <li><code>spec</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns (An instance of the appropriate MountedPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> method &lt;/&gt; <p>Support for pickling and serialization.</p><p>Returns a tuple of (callable, args, state) so that the underlying path is reconstructed from its string, and the spec relationship is restored via state.</p> method &lt;/&gt; <p>Restore internal state after unpickling.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the name changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the suffix changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segments appended to both    the mounted path and spec path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segment appended.</p> class &lt;/&gt; Bases xqute.path.MountedPath panpath.local_path.LocalPath pathlib.PosixPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a mounted local path</p><p>This class represents a path in a local filesystem as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedLocalPath(\"/container/data/file.txt\",...                               spec=\"/local/data/file.txt\")\n&gt;&gt;&gt; str(mounted_path)\n'/container/data/file.txt'\n&gt;&gt;&gt; str(mounted_path.spec)\n'/local/data/file.txt'\n&gt;&gt;&gt; mounted_path.name\n'file.txt'\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate MountedPath subclass based on the path type) \u2014 Factory method to create the appropriate MountedPath subclass instance.&lt;/&gt;</li> <li><code>__reduce__</code><code>(</code><code>)</code> \u2014 Support for pickling and serialization.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__setstate__</code><code>(</code><code>state</code><code>)</code> \u2014 Restore internal state after unpickling.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> \u2014 Return the string representation of the path, suitable forpassing to system calls. &lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (MountedPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Recursively copy the directory and all its contents to the target path.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists (async).&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously yield paths matching the glob pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory (async).&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file (async).&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a symlink (async).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create directory (async).&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (Any) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes (async).&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text (async).&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (LocalPath) \u2014 Asynchronously read the target of a symbolic link.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Rename the file or directory to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Rename the file or directory to target, overwriting if target exists.&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively yield all existing files matching the given pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory (async).&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>)</code> \u2014 Recursively remove directory and its contents (async).&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Get file stats (async).&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Asynchronously create a symbolic link pointing to target.&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create the file if it does not exist or update the modification time (async).&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file (async).&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously walk the directory tree.&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Write bytes to file (async).&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file (async).&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> \u2014 Return the path as a 'file' URI.&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Recursively copy the directory and all its contents to the target path.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern. &lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> \u2014 True if the path is absolute (has both a root and, if applicable,a drive). &lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> \u2014 Whether this path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files). &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> \u2014 Whether this path is a symbolic link.&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Return True if this path matches the given pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does. &lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> \u2014 Open the file in bytes mode, read it, and close the file.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code><code>)</code> \u2014 Open the file in text mode, read it, and close the file.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> \u2014 Return the path to which the symbolic link points.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Rename the file or directory to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it. &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree. &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively remove directory and its contents.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()). &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does. &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink. &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead. &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> (Iterator) \u2014 Walk the directory tree.&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (MountedPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (MountedPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Open the file in bytes mode, write to it, and close the file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file in text mode, write to it, and close the file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path, suitable forpassing to system calls.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the path as a 'file' URI.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive).</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Return True if this path matches the given pattern.</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.</p> method &lt;/&gt; <p>Whether this path is a directory.</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a symbolic link.</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file.</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Return the path to which the symbolic link points.</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist.</p> method &lt;/&gt; <p>Create a new directory at this given path.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Create the file if it does not exist or update the modification time (async).</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raises an error if the file already exists.</li> </ul> method &lt;/&gt; <p>Rename the file or directory to target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path</li> </ul> Returns (PanPath) <p>New path instance</p> method &lt;/&gt; <p>Rename the file or directory to target, overwriting if target exists.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path</li> </ul> Returns (PanPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Recursively copy the directory and all its contents to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, copies the contents of symlinks.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Asynchronously walk the directory tree.</p> Returns (AsyncGenerator) <p>A list of tuples (dirpath, dirnames, filenames)</p> method &lt;/&gt; <p>Asynchronously read the target of a symbolic link.</p> Returns (LocalPath) <p>The path to which the symbolic link points.</p> method &lt;/&gt; <p>Asynchronously create a symbolic link pointing to target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 The target path the symbolic link points to.</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Whether the target is a directory.</li> </ul> method &lt;/&gt; <p>Asynchronously yield paths matching the glob pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Glob pattern (relative)</li> </ul> Yields (AsyncGenerator) <p>Matching LocalPath instances</p> method &lt;/&gt; <p>Recursively yield all existing files matching the given pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Glob pattern (relative)</li> </ul> Yields (AsyncGenerator) <p>Matching LocalPath instances</p> method &lt;/&gt; <p>Check if path exists (async).</p> method &lt;/&gt; <p>Check if path is a file (async).</p> method &lt;/&gt; <p>Check if path is a directory (async).</p> method &lt;/&gt; <p>Read file as bytes (async).</p> method &lt;/&gt; <p>Read file as text (async).</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file (async).</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file (async).</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Check if path is a symlink (async).</p> method &lt;/&gt; <p>Delete file (async).</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>Create directory (async).</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Directory mode (permissions) to set.</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, does not raise an error if the directory already exists.</li> </ul> method &lt;/&gt; <p>Remove empty directory (async).</p> method &lt;/&gt; <p>Recursively remove directory and its contents (async).</p> method &lt;/&gt; <p>List directory contents (async).</p> method &lt;/&gt; <p>Get file stats (async).</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 Mode to open the file (e.g., 'r', 'rb', 'w', 'wb').</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding to use (default: 'utf-8').</li> </ul> Returns (Any) <p>Async file handle from aiofiles</p> method &lt;/&gt; <p>Rename the file or directory to target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path</li> </ul> Returns (PanPath) <p>New path instance</p> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, follow symbolic links</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Recursively copy the directory and all its contents to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, copies the contents of symlinks.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Remove empty directory.</p> method &lt;/&gt; <p>Recursively remove directory and its contents.</p> generator &lt;/&gt; <p>Walk the directory tree.</p> Returns (Iterator) <p>A list of tuples (dirpath, dirnames, filenames)</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate MountedPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the mounted path location.</li> <li><code>spec</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns (An instance of the appropriate MountedPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> method &lt;/&gt; <p>Support for pickling and serialization.</p><p>Returns a tuple of (callable, args, state) so that the underlying path is reconstructed from its string, and the spec relationship is restored via state.</p> method &lt;/&gt; <p>Restore internal state after unpickling.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the name changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the suffix changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segments appended to both    the mounted path and spec path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segment appended.</p> abstract class &lt;/&gt; Bases xqute.path.MountedPath panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a mounted cloud path</p><p>This class represents a cloud storage path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",...    spec=\"gs://local-bucket/file.txt\")\n&gt;&gt;&gt; str(mounted_path)\n'gs://bucket/file.txt'\n&gt;&gt;&gt; str(mounted_path.spec)\n'gs://local-bucket/file.txt'\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate MountedPath subclass based on the path type) \u2014 Factory method to create the appropriate MountedPath subclass instance.&lt;/&gt;</li> <li><code>__reduce__</code><code>(</code><code>)</code> \u2014 Support for pickling and serialization.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__setstate__</code><code>(</code><code>state</code><code>)</code> \u2014 Restore internal state after unpickling.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (MountedPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (MountedPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (MountedPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate MountedPath subclass instance.</p> Parameters <ul> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the mounted path location.</li> <li><code>spec</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> </ul> Returns (An instance of the appropriate MountedPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> method &lt;/&gt; <p>Support for pickling and serialization.</p><p>Returns a tuple of (callable, args, state) so that the underlying path is reconstructed from its string, and the spec relationship is restored via state.</p> method &lt;/&gt; <p>Restore internal state after unpickling.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the name changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the suffix changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segments appended to both    the mounted path and spec path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> class &lt;/&gt; Bases xqute.path.MountedCloudPath xqute.path.MountedPath panpath.gs_path.GSPath panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a mounted Google Cloud Storage path</p><p>This class represents a Google Cloud Storage path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",...                          spec=\"gs://local-bucket/file.txt\")\n&gt;&gt;&gt; isinstance(mounted_path, MountedGSPath)\nTrue\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate MountedPath subclass based on the path type) \u2014 Factory method to create the appropriate MountedPath subclass instance.&lt;/&gt;</li> <li><code>__reduce__</code><code>(</code><code>)</code> \u2014 Support for pickling and serialization.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__setstate__</code><code>(</code><code>state</code><code>)</code> \u2014 Restore internal state after unpickling.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (MountedPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (MountedPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (MountedPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Delete file.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate MountedPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the mounted path location.</li> <li><code>spec</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns (An instance of the appropriate MountedPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> method &lt;/&gt; <p>Support for pickling and serialization.</p><p>Returns a tuple of (callable, args, state) so that the underlying path is reconstructed from its string, and the spec relationship is restored via state.</p> method &lt;/&gt; <p>Restore internal state after unpickling.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the name changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the suffix changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segments appended to both    the mounted path and spec path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> class &lt;/&gt; Bases xqute.path.MountedCloudPath xqute.path.MountedPath panpath.azure_path.AzurePath panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a mounted Azure Blob Storage path</p><p>This class represents an Azure Blob Storage path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"az://container/blob\",...                          spec=\"az://local-container/blob\")\n&gt;&gt;&gt; isinstance(mounted_path, MountedAzurePath)\nTrue\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate MountedPath subclass based on the path type) \u2014 Factory method to create the appropriate MountedPath subclass instance.&lt;/&gt;</li> <li><code>__reduce__</code><code>(</code><code>)</code> \u2014 Support for pickling and serialization.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__setstate__</code><code>(</code><code>state</code><code>)</code> \u2014 Restore internal state after unpickling.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (MountedPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (MountedPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (MountedPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Delete file.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate MountedPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the mounted path location.</li> <li><code>spec</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns (An instance of the appropriate MountedPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> method &lt;/&gt; <p>Support for pickling and serialization.</p><p>Returns a tuple of (callable, args, state) so that the underlying path is reconstructed from its string, and the spec relationship is restored via state.</p> method &lt;/&gt; <p>Restore internal state after unpickling.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the name changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the suffix changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segments appended to both    the mounted path and spec path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> class &lt;/&gt; Bases xqute.path.MountedCloudPath xqute.path.MountedPath panpath.s3_path.S3Path panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a mounted Amazon S3 path</p><p>This class represents an Amazon S3 path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"s3://bucket/key\",...                          spec=\"s3://local-bucket/key\")\n&gt;&gt;&gt; isinstance(mounted_path, MountedS3Path)\nTrue\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate MountedPath subclass based on the path type) \u2014 Factory method to create the appropriate MountedPath subclass instance.&lt;/&gt;</li> <li><code>__reduce__</code><code>(</code><code>)</code> \u2014 Support for pickling and serialization.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__setstate__</code><code>(</code><code>state</code><code>)</code> \u2014 Restore internal state after unpickling.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (MountedPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (MountedPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (MountedPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Delete file.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate MountedPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the mounted path location.</li> <li><code>spec</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns (An instance of the appropriate MountedPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> method &lt;/&gt; <p>Support for pickling and serialization.</p><p>Returns a tuple of (callable, args, state) so that the underlying path is reconstructed from its string, and the spec relationship is restored via state.</p> method &lt;/&gt; <p>Restore internal state after unpickling.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the name changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the suffix changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segments appended to both    the mounted path and spec path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> class &lt;/&gt; Bases panpath.base.PanPath pathlib.Path pathlib.PurePath <p>A router class to instantiate the correct path based on the path typefor the spec path.</p> <p>This abstract base class serves as a factory that creates appropriate spec path instances based on the input path type. It represents a path in the local environment where the framework runs, while maintaining a reference to the corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; # Create a spec path with corresponding mounted path&gt;&gt;&gt; spec_path = SpecPath(\n&gt;&gt;&gt;   \"/local/data/file.txt\", mounted=\"/container/data/file.txt\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; str(spec_path)\n'/local/data/file.txt'\n&gt;&gt;&gt; str(spec_path.mounted)\n'/container/data/file.txt'\n</code></pre> <pre><code>&gt;&gt;&gt; # Create a GCS spec path\n&gt;&gt;&gt; gs_path = SpecPath(\n&gt;&gt;&gt;   \"gs://bucket/file.txt\", mounted=\"gs://container-bucket/file.txt\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; type(gs_path)\n&lt;class 'xqute.path.SpecGSPath'&gt;\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate SpecPath subclass based on the path type) \u2014 Factory method to create the appropriate SpecPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> \u2014 Return the string representation of the path, suitable forpassing to system calls. &lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (SpecPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Asynchronously copy this path to the target path.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Asynchronously copy the directory and all its contents recursively to the target path.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously yield paths matching a glob pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Asynchronously check if the path is a symbolic link.&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously iterate over directory contents.&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Asynchronously create a directory at this path.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Asynchronously open the file and return an async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Asynchronously read the file's bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Asynchronously read the file's text content.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (PanPath) \u2014 Asynchronously read the target of the symbolic link.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Asynchronously rename this path to the target path.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Asynchronously replace this path with the target path.&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously yield paths matching a recursive glob pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Asynchronously remove the directory and its contents recursively.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Asynchronously remove the directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Asynchronously get the file or directory's status information.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Asynchronously create a symbolic link pointing to the target path.&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Asynchronously create the file if it does not exist.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Asynchronously remove (delete) the file or empty directory.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously walk the directory tree.&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> (Optional) \u2014 Asynchronously write bytes to the file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Asynchronously write text to the file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> \u2014 Return the path as a 'file' URI.&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern. &lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> \u2014 True if the path is absolute (has both a root and, if applicable,a drive). &lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> \u2014 Whether this path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files). &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> \u2014 Whether this path is a symbolic link.&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Return True if this path matches the given pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does. &lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> \u2014 Open the file in bytes mode, read it, and close the file.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code><code>)</code> \u2014 Open the file in text mode, read it, and close the file.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> \u2014 Return the path to which the symbolic link points.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it. &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree. &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()). &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does. &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink. &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead. &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> \u2014 Walk the directory tree.&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (SpecPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> (SpecPath) \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (SpecPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Open the file in bytes mode, write to it, and close the file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file in text mode, write to it, and close the file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path, suitable forpassing to system calls.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the path as a 'file' URI.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive).</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Return True if this path matches the given pattern.</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.</p> method &lt;/&gt; <p>Whether this path is a directory.</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a symbolic link.</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file.</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Return the path to which the symbolic link points.</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist.</p> method &lt;/&gt; <p>Create a new directory at this given path.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty.</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Asynchronously check if the path exists.</p> Returns (bool) <p>True if the path exists, False otherwise.</p> method &lt;/&gt; <p>Asynchronously read the file's bytes.</p> Returns (bytes) <p>File content as bytes.</p> method &lt;/&gt; <p>Asynchronously read the file's text content.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> Returns (str) <p>File content as string.</p> method &lt;/&gt; <p>Asynchronously write bytes to the file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> Returns (Optional) <p>Number of bytes written. For some cloud paths, may return None.</p> method &lt;/&gt; <p>Asynchronously write text to the file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> Returns (int) <p>Number of characters written.</p> method &lt;/&gt; <p>Asynchronously remove (delete) the file or empty directory.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>Asynchronously iterate over directory contents.</p> Yields (AsyncGenerator) <p>PanPath instances for each item in the directory.</p> method &lt;/&gt; <p>Asynchronously check if the path is a directory.</p> Returns (bool) <p>True if the path is a directory, False otherwise.</p> method &lt;/&gt; <p>Asynchronously check if the path is a file.</p> Returns (bool) <p>True if the path is a file, False otherwise.</p> method &lt;/&gt; <p>Asynchronously get the file or directory's status information.</p> Returns (stat_result) <p>An object containing file status information (platform-dependent).</p> method &lt;/&gt; <p>Asynchronously create a directory at this path.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Directory mode (permissions) to set.</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, does not raise an error if the directory already exists.</li> </ul> method &lt;/&gt; <p>Asynchronously yield paths matching a glob pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Glob pattern to match.</li> </ul> Returns (AsyncGenerator) <p>List of PanPath instances matching the pattern.</p> method &lt;/&gt; <p>Asynchronously yield paths matching a recursive glob pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Recursive glob pattern to match.</li> </ul> Returns (AsyncGenerator) <p>List of PanPath instances matching the pattern.</p> method &lt;/&gt; <p>Asynchronously walk the directory tree.</p> Yields (AsyncGenerator) <p>Tuples of (current_path, dirnames, filenames) at each level.</p> method &lt;/&gt; <p>Asynchronously create the file if it does not exist.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raises an error if the file already exists.</li> </ul> method &lt;/&gt; <p>Asynchronously rename this path to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path to rename to.</li> </ul> Returns (PanPath) <p>The renamed PanPath instance.</p> method &lt;/&gt; <p>Asynchronously replace this path with the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path to replace with.</li> </ul> Returns (PanPath) <p>The replaced PanPath instance.</p> method &lt;/&gt; <p>Asynchronously remove the directory and its contents recursively.</p> method &lt;/&gt; <p>Asynchronously check if the path is a symbolic link.</p><p>For local path, this checks if the path is a symlink. For cloud paths, this will check if the object has a metdata flag indicating it's a symlink. Note that it is not a real symlink like in local filesystems. But for example, gcsfuse supports symlink-like behavior via metadata.</p> Returns (bool) <p>True if the path is a symlink, False otherwise.</p> method &lt;/&gt; <p>Asynchronously read the target of the symbolic link.</p><p>For local path, this reads the symlink target. For cloud paths, this reads the metadata flag indicating the symlink target.</p> Returns (PanPath) <p>The target PanPath of the symlink.</p> method &lt;/&gt; <p>Asynchronously create a symbolic link pointing to the target path.</p><p>For local path, this creates a real symlink. For cloud paths, this sets a metadata flag indicating the symlink target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 The target PanPath the symlink points to.</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Whether the target is a directory (ignored for cloud paths).</li> </ul> method &lt;/&gt; <p>Asynchronously remove the directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, ignores errors during removal.</li> <li><code>onerror</code> (Any, optional) \u2014 Optional function to call on errors.</li> </ul> method &lt;/&gt; <p>Asynchronously copy this path to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Asynchronously copy the directory and all its contents recursively to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, copies the contents of symlinks.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Asynchronously open the file and return an async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 Mode to open the file (e.g., 'r', 'rb', 'w', 'wb').</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8').</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments to pass to the underlying open method.</li> </ul> Returns (AsyncFileHandle) <p>An async file handle.</p> method &lt;/&gt; <p>Walk the directory tree.</p> Yields <p>Tuples of (current_path, dirnames, filenames) at each level.</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate SpecPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns (An instance of the appropriate SpecPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the name changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the suffix changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p><p>The stem is the filename without the suffix.</p> Parameters <ul> <li><code>stem</code> \u2014 The new stem for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the stem changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segments appended to both    the spec path and mounted path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segment appended.</p> class &lt;/&gt; Bases xqute.path.SpecPath panpath.local_path.LocalPath pathlib.PosixPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a spec local path</p><p>This class represents a path in the local filesystem as it appears in the framework's environment, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecLocalPath(\"/local/data/file.txt\",...                         mounted=\"/container/data/file.txt\")\n&gt;&gt;&gt; str(spec_path)\n'/local/data/file.txt'\n&gt;&gt;&gt; str(spec_path.mounted)\n'/container/data/file.txt'\n&gt;&gt;&gt; spec_path.name\n'file.txt'\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate SpecPath subclass based on the path type) \u2014 Factory method to create the appropriate SpecPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> \u2014 Return the string representation of the path, suitable forpassing to system calls. &lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (SpecPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Recursively copy the directory and all its contents to the target path.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists (async).&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously yield paths matching the glob pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory (async).&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file (async).&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a symlink (async).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create directory (async).&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (Any) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes (async).&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text (async).&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (LocalPath) \u2014 Asynchronously read the target of a symbolic link.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Rename the file or directory to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Rename the file or directory to target, overwriting if target exists.&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively yield all existing files matching the given pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory (async).&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>)</code> \u2014 Recursively remove directory and its contents (async).&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Get file stats (async).&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Asynchronously create a symbolic link pointing to target.&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create the file if it does not exist or update the modification time (async).&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file (async).&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Asynchronously walk the directory tree.&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Write bytes to file (async).&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file (async).&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> \u2014 Return the path as a 'file' URI.&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Recursively copy the directory and all its contents to the target path.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern. &lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> \u2014 True if the path is absolute (has both a root and, if applicable,a drive). &lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> \u2014 Whether this path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files). &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> \u2014 Whether this path is a symbolic link.&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Return True if this path matches the given pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does. &lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> \u2014 Open the file in bytes mode, read it, and close the file.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code><code>)</code> \u2014 Open the file in text mode, read it, and close the file.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> \u2014 Return the path to which the symbolic link points.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (PanPath) \u2014 Rename the file or directory to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it. &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree. &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively remove directory and its contents.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()). &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does. &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink. &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead. &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> (Iterator) \u2014 Walk the directory tree.&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (SpecPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> (SpecPath) \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (SpecPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Open the file in bytes mode, write to it, and close the file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file in text mode, write to it, and close the file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path, suitable forpassing to system calls.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the path as a 'file' URI.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive).</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Return True if this path matches the given pattern.</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.</p> method &lt;/&gt; <p>Whether this path is a directory.</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a symbolic link.</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file.</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Return the path to which the symbolic link points.</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist.</p> method &lt;/&gt; <p>Create a new directory at this given path.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Create the file if it does not exist or update the modification time (async).</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raises an error if the file already exists.</li> </ul> method &lt;/&gt; <p>Rename the file or directory to target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path</li> </ul> Returns (PanPath) <p>New path instance</p> method &lt;/&gt; <p>Rename the file or directory to target, overwriting if target exists.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path</li> </ul> Returns (PanPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Recursively copy the directory and all its contents to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, copies the contents of symlinks.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Asynchronously walk the directory tree.</p> Returns (AsyncGenerator) <p>A list of tuples (dirpath, dirnames, filenames)</p> method &lt;/&gt; <p>Asynchronously read the target of a symbolic link.</p> Returns (LocalPath) <p>The path to which the symbolic link points.</p> method &lt;/&gt; <p>Asynchronously create a symbolic link pointing to target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 The target path the symbolic link points to.</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Whether the target is a directory.</li> </ul> method &lt;/&gt; <p>Asynchronously yield paths matching the glob pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Glob pattern (relative)</li> </ul> Yields (AsyncGenerator) <p>Matching LocalPath instances</p> method &lt;/&gt; <p>Recursively yield all existing files matching the given pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Glob pattern (relative)</li> </ul> Yields (AsyncGenerator) <p>Matching LocalPath instances</p> method &lt;/&gt; <p>Check if path exists (async).</p> method &lt;/&gt; <p>Check if path is a file (async).</p> method &lt;/&gt; <p>Check if path is a directory (async).</p> method &lt;/&gt; <p>Read file as bytes (async).</p> method &lt;/&gt; <p>Read file as text (async).</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file (async).</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file (async).</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Check if path is a symlink (async).</p> method &lt;/&gt; <p>Delete file (async).</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>Create directory (async).</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Directory mode (permissions) to set.</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, does not raise an error if the directory already exists.</li> </ul> method &lt;/&gt; <p>Remove empty directory (async).</p> method &lt;/&gt; <p>Recursively remove directory and its contents (async).</p> method &lt;/&gt; <p>List directory contents (async).</p> method &lt;/&gt; <p>Get file stats (async).</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 Mode to open the file (e.g., 'r', 'rb', 'w', 'wb').</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding to use (default: 'utf-8').</li> </ul> Returns (Any) <p>Async file handle from aiofiles</p> method &lt;/&gt; <p>Rename the file or directory to target.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path</li> </ul> Returns (PanPath) <p>New path instance</p> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, follow symbolic links</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Recursively copy the directory and all its contents to the target path.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination PanPath to copy to.</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If True, copies the contents of symlinks.</li> </ul> Returns (PanPath) <p>The copied PanPath instance.</p> method &lt;/&gt; <p>Remove empty directory.</p> method &lt;/&gt; <p>Recursively remove directory and its contents.</p> generator &lt;/&gt; <p>Walk the directory tree.</p> Returns (Iterator) <p>A list of tuples (dirpath, dirnames, filenames)</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate SpecPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns (An instance of the appropriate SpecPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the name changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the suffix changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p><p>The stem is the filename without the suffix.</p> Parameters <ul> <li><code>stem</code> \u2014 The new stem for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the stem changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segments appended to both    the spec path and mounted path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segment appended.</p> abstract class &lt;/&gt; Bases xqute.path.SpecPath panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a spec cloud path</p><p>This class represents a cloud storage path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",...                    mounted=\"gs://container-bucket/file.txt\")\n&gt;&gt;&gt; str(spec_path)\n'gs://bucket/file.txt'\n&gt;&gt;&gt; str(spec_path.mounted)\n'gs://container-bucket/file.txt'\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate SpecPath subclass based on the path type) \u2014 Factory method to create the appropriate SpecPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (SpecPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (SpecPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> (SpecPath) \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (SpecPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate SpecPath subclass instance.</p> Parameters <ul> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec path.</li> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> </ul> Returns (An instance of the appropriate SpecPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the name changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the suffix changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p><p>The stem is the filename without the suffix.</p> Parameters <ul> <li><code>stem</code> \u2014 The new stem for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the stem changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segments appended to both    the spec path and mounted path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> class &lt;/&gt; Bases xqute.path.SpecCloudPath xqute.path.SpecPath panpath.gs_path.GSPath panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a spec Google Cloud Storage path</p><p>This class represents a Google Cloud Storage path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",...                    mounted=\"gs://container-bucket/file.txt\")\n&gt;&gt;&gt; isinstance(spec_path, SpecGSPath)\nTrue\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate SpecPath subclass based on the path type) \u2014 Factory method to create the appropriate SpecPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (SpecPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (SpecPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> (SpecPath) \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (SpecPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Delete file.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate SpecPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns (An instance of the appropriate SpecPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the name changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the suffix changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p><p>The stem is the filename without the suffix.</p> Parameters <ul> <li><code>stem</code> \u2014 The new stem for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the stem changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segments appended to both    the spec path and mounted path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> class &lt;/&gt; Bases xqute.path.SpecCloudPath xqute.path.SpecPath panpath.azure_path.AzurePath panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a spec Azure Blob Storage path</p><p>This class represents an Azure Blob Storage path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"az://container/blob\",...                    mounted=\"az://remote-container/blob\")\n&gt;&gt;&gt; isinstance(spec_path, SpecAzurePath)\nTrue\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate SpecPath subclass based on the path type) \u2014 Factory method to create the appropriate SpecPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (SpecPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (SpecPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> (SpecPath) \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (SpecPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Delete file.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate SpecPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns (An instance of the appropriate SpecPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the name changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the suffix changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p><p>The stem is the filename without the suffix.</p> Parameters <ul> <li><code>stem</code> \u2014 The new stem for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the stem changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segments appended to both    the spec path and mounted path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p> class &lt;/&gt; Bases xqute.path.SpecCloudPath xqute.path.SpecPath panpath.s3_path.S3Path panpath.cloud.CloudPath panpath.base.PanPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a spec Amazon S3 path</p><p>This class represents an Amazon S3 path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>async_client</code> (AsyncClient) \u2014 Get or create the async client for this path.&lt;/&gt;</li> <li><code>client</code> (SyncClient) \u2014 Get or create the sync client for this path.&lt;/&gt;</li> <li><code>cloud_prefix</code> (str) \u2014 Return the cloud prefix (e.g., 's3://bucket').&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>key</code> (str) \u2014 Return the key/blob name without the cloud prefix.&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"s3://bucket/key\",...                    mounted=\"s3://remote-bucket/key\")\n&gt;&gt;&gt; isinstance(spec_path, SpecS3Path)\nTrue\n</code></pre> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__fspath__</code><code>(</code><code>)</code> (str) \u2014 Return the filesystem path representation.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate SpecPath subclass based on the path type) \u2014 Factory method to create the appropriate SpecPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> (CloudPath) \u2014 Right join paths while preserving type and client.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 Return properly formatted cloud URI with double slash.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (SpecPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (PanPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>a_exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>a_glob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>a_is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>a_is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>a_is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>a_iterdir</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 List directory contents (async version returns list).&lt;/&gt;</li> <li><code>a_mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>a_open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (AsyncFileHandle) \u2014 Open file and return async file handle.&lt;/&gt;</li> <li><code>a_read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>a_read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>a_readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>a_rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>a_replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>a_resolve</code><code>(</code><code>)</code> (PanPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>a_rglob</code><code>(</code><code>pattern</code><code>)</code> (AsyncGenerator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>a_rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>a_rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>a_stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>a_touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>a_unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>a_walk</code><code>(</code><code>)</code> (AsyncGenerator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>a_write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> (int) \u2014 Write text to file.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (CloudPath) \u2014 Return absolute path - cloud paths are already absolute.&lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a URI (same as string representation).&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy file to target.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks</code><code>)</code> (CloudPath) \u2014 Copy directory tree to target recursively.&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>)</code> (bool) \u2014 Check if path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>get_fspath</code><code>(</code><code>)</code> (PanPath) \u2014 Get the corresponding local filesystem path and copy from cloud.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Glob for files matching pattern.&lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 Cloud paths are always absolute.&lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> (bool) \u2014 Check if path is a file.&lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Check if this is a symbolic link (via metadata).&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (CloudPath) \u2014 Iterate over directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>pattern</code><code>)</code> (bool) \u2014 Match path against glob pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a directory marker in cloud storage.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>encoding</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 Open file for reading/writing.&lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Read file as bytes.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code><code>)</code> (str) \u2014 Read file as text.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (CloudPath) \u2014 Read symlink target from metadata.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Rename/move file to target.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (CloudPath) \u2014 Replace file at target (overwriting if exists).&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>)</code> (CloudPath) \u2014 Resolve to absolute path (no-op for cloud paths).&lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code><code>)</code> (Iterator) \u2014 Recursively glob for files matching pattern.&lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove empty directory marker.&lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>ignore_errors</code>, <code>onerror</code><code>)</code> \u2014 Remove directory and all its contents recursively.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check if this path refers to same file as other.&lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (Any) \u2014 Get file stats.&lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Create symlink pointing to target (via metadata).&lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code><code>)</code> \u2014 Create empty file.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Delete file.&lt;/&gt;</li> <li><code>walk</code><code>(</code><code>)</code> (Iterator) \u2014 Walk directory tree (like os.walk).&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (SpecPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>. &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> (SpecPath) \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (SpecPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Write bytes to file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code><code>)</code> \u2014 Write text to file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> method &lt;/&gt; <p>Right join paths while preserving type and client.</p> method &lt;/&gt; <p>Return properly formatted cloud URI with double slash.</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> method &lt;/&gt; <p>Write bytes to file.</p> method &lt;/&gt; <p>Write text to file.</p> method &lt;/&gt; <p>Delete file.</p> generator &lt;/&gt; <p>Iterate over directory contents.</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Open file for reading/writing.</p> method &lt;/&gt; <p>Return absolute path - cloud paths are already absolute.</p> method &lt;/&gt; <p>Cloud paths are always absolute.</p> method &lt;/&gt; <p>Return the path as a URI (same as string representation).</p> method &lt;/&gt; <p>Match path against glob pattern.</p><p>Override to work correctly with cloud URIs by matching against the key portion of the path (excluding scheme and bucket).</p> generator &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (Iterator) <p>List of matching paths</p> generator &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (Iterator) <p>List of matching paths (recursive)</p> generator &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (Iterator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (CloudPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Check if this path refers to same file as other.</p> Parameters <ul> <li><code>other</code> (Union) \u2014 Path to compare</li> </ul> Returns (bool) <p>True if paths are the same</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Check if path exists.</p> method &lt;/&gt; <p>Read file as bytes.</p> method &lt;/&gt; <p>Read file as text.</p> Parameters <ul> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Write bytes to file.</p> Parameters <ul> <li><code>data</code> (bytes) \u2014 Bytes to write to the file.</li> </ul> method &lt;/&gt; <p>Write text to file.</p> Parameters <ul> <li><code>data</code> (str) \u2014 Text to write to the file.</li> <li><code>encoding</code> (str, optional) \u2014 Text encoding to use (default: 'utf-8')</li> </ul> method &lt;/&gt; <p>Delete file.</p> Parameters <ul> <li><code>missing_ok</code> (bool, optional) \u2014 If True, does not raise an error if the file does not exist.</li> </ul> method &lt;/&gt; <p>List directory contents (async version returns list).</p> method &lt;/&gt; <p>Check if path is a directory.</p> method &lt;/&gt; <p>Check if path is a file.</p> method &lt;/&gt; <p>Get file stats.</p> method &lt;/&gt; <p>Create a directory marker in cloud storage.</p><p>In cloud storage (S3, GCS, Azure), directories are implicit. This method creates an empty object with a trailing slash to serve as a directory marker.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 Ignored (for compatibility with pathlib)</li> <li><code>parents</code> (bool, optional) \u2014 If True, create parent directories as needed</li> <li><code>exist_ok</code> (bool, optional) \u2014 If True, don't raise error if directory already exists</li> </ul> method &lt;/&gt; <p>Glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \"/.py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths</p> method &lt;/&gt; <p>Recursively glob for files matching pattern.</p> Parameters <ul> <li><code>pattern</code> (str) \u2014 Pattern to match (e.g., \".txt\", \".py\")</li> </ul> Returns (AsyncGenerator) <p>List of matching paths (recursive)</p> method &lt;/&gt; <p>Walk directory tree (like os.walk).</p> Returns (AsyncGenerator) <p>List of (dirpath, dirnames, filenames) tuples</p> method &lt;/&gt; <p>Create empty file.</p> Parameters <ul> <li><code>mode</code> (int, optional) \u2014 File mode (permissions) to set if creating the file.</li> <li><code>exist_ok</code> (bool, optional) \u2014 If False, raise error if file exists</li> </ul> method &lt;/&gt; <p>Rename/move file to target.</p><p>Can move between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 New path (can be cloud or local)</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Replace file at target (overwriting if exists).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Target path</li> </ul> Returns (CloudPath) <p>New path instance</p> method &lt;/&gt; <p>Resolve to absolute path (no-op for cloud paths).</p> Returns (PanPath) <p>Self (cloud paths are already absolute)</p> method &lt;/&gt; <p>Remove empty directory marker.</p> method &lt;/&gt; <p>Check if this is a symbolic link (via metadata).</p> Returns (bool) <p>True if symlink metadata exists</p> method &lt;/&gt; <p>Read symlink target from metadata.</p> Returns (CloudPath) <p>Path that this symlink points to</p> method &lt;/&gt; <p>Create symlink pointing to target (via metadata).</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Path this symlink should point to (absolute with scheme or relative)</li> <li><code>target_is_directory</code> (bool, optional) \u2014 Ignored (for compatibility with pathlib)</li> </ul> method &lt;/&gt; <p>Remove directory and all its contents recursively.</p> Parameters <ul> <li><code>ignore_errors</code> (bool, optional) \u2014 If True, errors are ignored</li> <li><code>onerror</code> (Optional, optional) \u2014 Callable that accepts (function, path, excinfo)</li> </ul> method &lt;/&gt; <p>Copy file to target.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> </ul> Returns (PanPath) <p>Target path instance</p> method &lt;/&gt; <p>Copy directory tree to target recursively.</p><p>Can copy between cloud and local paths.</p> Parameters <ul> <li><code>target</code> (Union) \u2014 Destination path (can be cloud or local)</li> <li><code>follow_symlinks</code> (bool, optional) \u2014 If False, symlinks are copied as symlinks (not dereferenced)</li> </ul> Returns (CloudPath) <p>Target path instance</p> method &lt;/&gt; <p>Open file and return async file handle.</p> Parameters <ul> <li><code>mode</code> (str, optional) \u2014 File mode (e.g., 'r', 'w', 'rb', 'wb')</li> <li><code>encoding</code> (Optional, optional) \u2014 Text encoding (for text modes)</li> <li><code>**kwargs</code> (Any) \u2014 Additional arguments passed to the async client</li> </ul> Returns (AsyncFileHandle) <p>Async file handle from the async client</p> staticmethod &lt;/&gt; <p>Factory method to create the appropriate SpecPath subclass instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns (An instance of the appropriate SpecPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the name changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the suffix changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p><p>The stem is the filename without the suffix.</p> Parameters <ul> <li><code>stem</code> \u2014 The new stem for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the stem changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segments appended to both    the spec path and mounted path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segment appended.</p> method &lt;/&gt; <p>Return the filesystem path representation.</p> Returns (str) <p>The filesystem path as a string.</p> method &lt;/&gt; <p>Get the corresponding local filesystem path and copy from cloud.</p> Returns (PanPath) <p>The path as it appears in the local filesystem.</p>"},{"location":"api/xqute.path/#xqutepath","title":"xqute.path","text":""},{"location":"api/xqute.path/#xqutepathmountedpath","title":"<code>xqute.path.</code><code>MountedPath</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 MountedPath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathstr","title":"<code>__str__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_uri","title":"<code>as_uri</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_stem","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_absolute","title":"<code>is_absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathmatch","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathstat","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexists","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_dir","title":"<code>is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_file","title":"<code>is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_symlink","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsamefile","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathopen","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_bytes","title":"<code>read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_text","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_bytes","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_text","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathiterdir","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathglob","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrglob","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathabsolute","title":"<code>absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathresolve","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreadlink","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathtouch","title":"<code>touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathmkdir","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathunlink","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrmdir","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrename","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreplace","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsymlink_to","title":"<code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_resolve","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_exists","title":"<code>a_exists</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_read_bytes","title":"<code>a_read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_read_text","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_write_bytes","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_write_text","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_unlink","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_iterdir","title":"<code>a_iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_is_dir","title":"<code>a_is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_is_file","title":"<code>a_is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_stat","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_mkdir","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_glob","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rglob","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_walk","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_touch","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rename","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_replace","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rmdir","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_is_symlink","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_readlink","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_symlink_to","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rmtree","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_copy","title":"<code>a_copy</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_copytree","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_open","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding='utf-8'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpathwalk","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathget_fspath","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathreduce","title":"<code>__reduce__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathsetstate","title":"<code>__setstate__</code><code>(</code><code>state</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_name","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_suffix","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathjoinpath","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathtruediv","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpath","title":"<code>xqute.path.</code><code>MountedLocalPath</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 MountedPath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_1","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathstr_1","title":"<code>__str__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_1","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_1","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_uri_1","title":"<code>as_uri</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_stem_1","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_1","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_1","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_absolute_1","title":"<code>is_absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_1","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathmatch_1","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathstat_1","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_1","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexists_1","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_dir_1","title":"<code>is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_file_1","title":"<code>is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_1","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_symlink_1","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_1","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_1","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_1","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_1","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_1","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsamefile_1","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathopen_1","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_bytes_1","title":"<code>read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_text_1","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_bytes_1","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_text_1","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathiterdir_1","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathglob_1","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrglob_1","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_1","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_1","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathabsolute_1","title":"<code>absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathresolve_1","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_1","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_1","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreadlink_1","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathtouch_1","title":"<code>touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathmkdir_1","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_1","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_1","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathunlink_1","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreplace_1","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsymlink_to_1","title":"<code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_1","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_1","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_touch","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rename","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_replace","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_resolve","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_copy","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_copytree","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_walk","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_readlink","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_symlink_to","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_glob","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rglob","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_exists","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_is_file","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_is_dir","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_read_bytes","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_read_text","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_write_bytes","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_write_text","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_is_symlink","title":"<code>a_is_symlink</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_unlink","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_mkdir","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rmdir","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rmtree","title":"<code>a_rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_iterdir","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_stat","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 stat_result","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_open","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathrename","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathcopy","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathcopytree","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathrmdir","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathrmtree","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathwalk","title":"<code>walk</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathnew_1","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathget_fspath_1","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_1","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_1","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_1","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_1","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathreduce_1","title":"<code>__reduce__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathsetstate_1","title":"<code>__setstate__</code><code>(</code><code>state</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_name_1","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_suffix_1","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathjoinpath_1","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathtruediv_1","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpath","title":"<code>xqute.path.</code><code>MountedCloudPath</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 MountedPath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_2","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_2","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_2","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_stem_2","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_2","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_2","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_2","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_2","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_2","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_2","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_2","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_2","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_2","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_2","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_2","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_2","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_2","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_2","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_2","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_2","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_2","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_2","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathnew_2","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_2","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_2","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_2","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_2","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathreduce_2","title":"<code>__reduce__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathsetstate_2","title":"<code>__setstate__</code><code>(</code><code>state</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_name_2","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_suffix_2","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathjoinpath_2","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathtruediv_2","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathfspath","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathget_fspath","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedgspath","title":"<code>xqute.path.</code><code>MountedGSPath</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 MountedPath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_3","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_3","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_3","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_stem_3","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_3","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_3","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_3","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_3","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_3","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_3","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_3","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_3","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_3","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_3","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_3","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_3","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_3","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_3","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_3","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_3","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_3","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_3","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv_1","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr_1","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists_1","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes_1","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text_1","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes_1","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text_1","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink_1","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir_1","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir_1","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file_1","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat_1","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir_1","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen_1","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute_1","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute_1","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri_1","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch_1","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob_1","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob_1","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk_1","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch_1","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename_1","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace_1","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir_1","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve_1","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile_1","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink_1","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink_1","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to_1","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree_1","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy_1","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree_1","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists_1","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes_1","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text_1","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes_1","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text_1","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink_1","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir_1","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir_1","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file_1","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat_1","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir_1","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob_1","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob_1","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk_1","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch_1","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename_1","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace_1","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve_1","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir_1","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink_1","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink_1","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to_1","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree_1","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy_1","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree_1","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open_1","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathnew_3","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_3","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_3","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_3","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_3","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathreduce_3","title":"<code>__reduce__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathsetstate_3","title":"<code>__setstate__</code><code>(</code><code>state</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_name_3","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_suffix_3","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathjoinpath_3","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathtruediv_3","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathfspath_1","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathget_fspath_1","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedazurepath","title":"<code>xqute.path.</code><code>MountedAzurePath</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 MountedPath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_4","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_4","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_4","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_stem_4","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_4","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_4","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_4","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_4","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_4","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_4","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_4","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_4","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_4","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_4","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_4","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_4","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_4","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_4","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_4","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_4","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_4","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_4","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv_2","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr_2","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists_2","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes_2","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text_2","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes_2","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text_2","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink_2","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir_2","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir_2","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file_2","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat_2","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir_2","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen_2","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute_2","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute_2","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri_2","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch_2","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob_2","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob_2","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk_2","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch_2","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename_2","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace_2","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir_2","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve_2","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile_2","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink_2","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink_2","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to_2","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree_2","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy_2","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree_2","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists_2","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes_2","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text_2","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes_2","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text_2","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink_2","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir_2","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir_2","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file_2","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat_2","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir_2","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob_2","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob_2","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk_2","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch_2","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename_2","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace_2","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve_2","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir_2","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink_2","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink_2","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to_2","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree_2","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy_2","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree_2","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open_2","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathnew_4","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_4","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_4","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_4","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_4","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathreduce_4","title":"<code>__reduce__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathsetstate_4","title":"<code>__setstate__</code><code>(</code><code>state</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_name_4","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_suffix_4","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathjoinpath_4","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathtruediv_4","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathfspath_2","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathget_fspath_2","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmounteds3path","title":"<code>xqute.path.</code><code>MountedS3Path</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 MountedPath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_5","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_5","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_5","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_stem_5","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_5","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_5","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_5","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_5","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_5","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_5","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_5","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_5","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_5","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_5","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_5","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_5","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_5","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_5","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_5","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_5","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_5","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_5","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv_3","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr_3","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists_3","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes_3","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text_3","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes_3","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text_3","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink_3","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir_3","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir_3","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file_3","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat_3","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir_3","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen_3","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute_3","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute_3","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri_3","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch_3","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob_3","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob_3","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk_3","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch_3","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename_3","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace_3","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir_3","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve_3","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile_3","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink_3","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink_3","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to_3","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree_3","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy_3","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree_3","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists_3","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes_3","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text_3","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes_3","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text_3","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink_3","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir_3","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir_3","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file_3","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat_3","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir_3","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob_3","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob_3","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk_3","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch_3","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename_3","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace_3","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve_3","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir_3","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink_3","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink_3","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to_3","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree_3","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy_3","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree_3","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open_3","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathnew_5","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_5","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_5","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_5","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_5","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathreduce_5","title":"<code>__reduce__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathsetstate_5","title":"<code>__setstate__</code><code>(</code><code>state</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_name_5","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathwith_suffix_5","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathjoinpath_5","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathtruediv_5","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathfspath_3","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathget_fspath_3","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpath","title":"<code>xqute.path.</code><code>SpecPath</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.speclocalpath | xqute.path.speccloudpath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_6","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathstr_2","title":"<code>__str__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_6","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_6","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_uri_2","title":"<code>as_uri</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_6","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_6","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_absolute_2","title":"<code>is_absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_6","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathmatch_2","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathstat_2","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_6","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexists_2","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_dir_2","title":"<code>is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_file_2","title":"<code>is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_6","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_symlink_2","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_6","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_6","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_6","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_6","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_6","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsamefile_2","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathopen_2","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_bytes_2","title":"<code>read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_text_2","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_bytes_2","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_text_2","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathiterdir_2","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathglob_2","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrglob_2","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_6","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_6","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathabsolute_2","title":"<code>absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathresolve_2","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_6","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_6","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreadlink_2","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathtouch_2","title":"<code>touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathmkdir_2","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_6","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_6","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathunlink_2","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrmdir_1","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrename_1","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreplace_2","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsymlink_to_2","title":"<code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_6","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_6","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_resolve_1","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_exists_1","title":"<code>a_exists</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_read_bytes_1","title":"<code>a_read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_read_text_1","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_write_bytes_1","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_write_text_1","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_unlink_1","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_iterdir_1","title":"<code>a_iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_is_dir_1","title":"<code>a_is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_is_file_1","title":"<code>a_is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_stat_1","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_mkdir_1","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_glob_1","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rglob_1","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_walk_1","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_touch_1","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rename_1","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_replace_1","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rmdir_1","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_is_symlink_1","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_readlink_1","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_symlink_to_1","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_rmtree_1","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_copy_1","title":"<code>a_copy</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_copytree_1","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpatha_open_1","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding='utf-8'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathbasepanpathwalk_1","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathget_fspath","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_name","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_suffix","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_stem","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathjoinpath","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathtruediv","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpath","title":"<code>xqute.path.</code><code>SpecLocalPath</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.speclocalpath | xqute.path.speccloudpath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_7","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathstr_3","title":"<code>__str__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_7","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_7","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_uri_3","title":"<code>as_uri</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_7","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_7","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_absolute_3","title":"<code>is_absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_7","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathmatch_3","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathstat_3","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_7","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexists_3","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_dir_3","title":"<code>is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_file_3","title":"<code>is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_7","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_symlink_3","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_7","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_7","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_7","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_7","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_7","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsamefile_3","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathopen_3","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_bytes_3","title":"<code>read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_text_3","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_bytes_3","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_text_3","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathiterdir_3","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathglob_3","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrglob_3","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_7","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_7","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathabsolute_3","title":"<code>absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathresolve_3","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_7","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_7","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreadlink_3","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathtouch_3","title":"<code>touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathmkdir_3","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_7","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_7","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathunlink_3","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreplace_3","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsymlink_to_3","title":"<code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_7","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_7","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_touch_1","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rename_1","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_replace_1","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_resolve_1","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_copy_1","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_copytree_1","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_walk_1","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_readlink_1","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_symlink_to_1","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_glob_1","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rglob_1","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_exists_1","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_is_file_1","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_is_dir_1","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_read_bytes_1","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_read_text_1","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_write_bytes_1","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_write_text_1","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_is_symlink_1","title":"<code>a_is_symlink</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_unlink_1","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_mkdir_1","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rmdir_1","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_rmtree_1","title":"<code>a_rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_iterdir_1","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_stat_1","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 stat_result","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpatha_open_1","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathrename_1","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathcopy_1","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathcopytree_1","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathrmdir_1","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathrmtree_1","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathlocal_pathlocalpathwalk_1","title":"<code>walk</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathnew_1","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathget_fspath_1","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_1","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_1","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_1","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_name_1","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_suffix_1","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_stem_1","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathjoinpath_1","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathtruediv_1","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpath","title":"<code>xqute.path.</code><code>SpecCloudPath</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.speclocalpath | xqute.path.speccloudpath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_8","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_8","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_8","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_8","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_8","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_8","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_8","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_8","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_8","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_8","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_8","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_8","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_8","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_8","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_8","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_8","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_8","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_8","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_8","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_8","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_8","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv_4","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr_4","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists_4","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes_4","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text_4","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes_4","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text_4","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink_4","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir_4","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir_4","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file_4","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat_4","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir_4","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen_4","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute_4","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute_4","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri_4","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch_4","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob_4","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob_4","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk_4","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch_4","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename_4","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace_4","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir_4","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve_4","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile_4","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink_4","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink_4","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to_4","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree_4","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy_4","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree_4","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists_4","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes_4","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text_4","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes_4","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text_4","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink_4","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir_4","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir_4","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file_4","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat_4","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir_4","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob_4","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob_4","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk_4","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch_4","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename_4","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace_4","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve_4","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir_4","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink_4","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink_4","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to_4","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree_4","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy_4","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree_4","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open_4","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathnew_2","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_2","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_2","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_2","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_name_2","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_suffix_2","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_stem_2","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathjoinpath_2","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathtruediv_2","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathfspath","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathget_fspath","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecgspath","title":"<code>xqute.path.</code><code>SpecGSPath</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.speclocalpath | xqute.path.speccloudpath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_9","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_9","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_9","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_9","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_9","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_9","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_9","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_9","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_9","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_9","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_9","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_9","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_9","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_9","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_9","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_9","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_9","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_9","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_9","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_9","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_9","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv_5","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr_5","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists_5","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes_5","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text_5","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes_5","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text_5","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink_5","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir_5","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir_5","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file_5","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat_5","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir_5","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen_5","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute_5","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute_5","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri_5","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch_5","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob_5","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob_5","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk_5","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch_5","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename_5","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace_5","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir_5","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve_5","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile_5","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink_5","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink_5","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to_5","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree_5","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy_5","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree_5","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists_5","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes_5","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text_5","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes_5","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text_5","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink_5","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir_5","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir_5","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file_5","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat_5","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir_5","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob_5","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob_5","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk_5","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch_5","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename_5","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace_5","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve_5","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir_5","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink_5","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink_5","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to_5","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree_5","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy_5","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree_5","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open_5","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathnew_3","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_3","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_3","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_3","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_name_3","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_suffix_3","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_stem_3","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathjoinpath_3","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathtruediv_3","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathfspath_1","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathget_fspath_1","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecazurepath","title":"<code>xqute.path.</code><code>SpecAzurePath</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.speclocalpath | xqute.path.speccloudpath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_10","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_10","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_10","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_10","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_10","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_10","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_10","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_10","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_10","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_10","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_10","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_10","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_10","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_10","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_10","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_10","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_10","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_10","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_10","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_10","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_10","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv_6","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr_6","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists_6","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes_6","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text_6","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes_6","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text_6","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink_6","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir_6","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir_6","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file_6","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat_6","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir_6","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen_6","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute_6","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute_6","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri_6","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch_6","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob_6","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob_6","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk_6","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch_6","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename_6","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace_6","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir_6","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve_6","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile_6","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink_6","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink_6","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to_6","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree_6","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy_6","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree_6","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists_6","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes_6","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text_6","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes_6","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text_6","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink_6","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir_6","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir_6","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file_6","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat_6","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir_6","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob_6","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob_6","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk_6","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch_6","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename_6","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace_6","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve_6","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir_6","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink_6","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink_6","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to_6","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree_6","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy_6","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree_6","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open_6","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathnew_4","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_4","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_4","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_4","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_name_4","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_suffix_4","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_stem_4","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathjoinpath_4","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathtruediv_4","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathfspath_2","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathget_fspath_2","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecs3path","title":"<code>xqute.path.</code><code>SpecS3Path</code><code>(</code><code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.speclocalpath | xqute.path.speccloudpath","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_segments_11","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_11","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_11","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_11","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_11","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_11","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_11","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_11","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_11","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_11","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_11","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_11","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_11","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_11","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_11","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_11","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_11","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_11","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_11","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_11","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_11","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrtruediv_7","title":"<code>__rtruediv__</code><code>(</code><code>other</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstr_7","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathexists_7","title":"<code>exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_bytes_7","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathread_text_7","title":"<code>read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_bytes_7","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwrite_text_7","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathunlink_7","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathiterdir_7","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_dir_7","title":"<code>is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_file_7","title":"<code>is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathstat_7","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmkdir_7","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathopen_7","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathabsolute_7","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 CloudPath","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_absolute_7","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathas_uri_7","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathmatch_7","title":"<code>match</code><code>(</code><code>pattern</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathglob_7","title":"<code>glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrglob_7","title":"<code>rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathwalk_7","title":"<code>walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathtouch_7","title":"<code>touch</code><code>(</code><code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrename_7","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreplace_7","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmdir_7","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathresolve_7","title":"<code>resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsamefile_7","title":"<code>samefile</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathis_symlink_7","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathreadlink_7","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathsymlink_to_7","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathrmtree_7","title":"<code>rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopy_7","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpathcopytree_7","title":"<code>copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_exists_7","title":"<code>a_exists</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_bytes_7","title":"<code>a_read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_read_text_7","title":"<code>a_read_text</code><code>(</code><code>encoding='utf-8'</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_bytes_7","title":"<code>a_write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_write_text_7","title":"<code>a_write_text</code><code>(</code><code>data</code>, <code>encoding='utf-8'</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_unlink_7","title":"<code>a_unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_iterdir_7","title":"<code>a_iterdir</code><code>(</code><code>)</code> \u2192 AsyncGenerator","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_dir_7","title":"<code>a_is_dir</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_file_7","title":"<code>a_is_file</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_stat_7","title":"<code>a_stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 Any","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_mkdir_7","title":"<code>a_mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_glob_7","title":"<code>a_glob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rglob_7","title":"<code>a_rglob</code><code>(</code><code>pattern</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_walk_7","title":"<code>a_walk</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_touch_7","title":"<code>a_touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rename_7","title":"<code>a_rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_replace_7","title":"<code>a_replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_resolve_7","title":"<code>a_resolve</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmdir_7","title":"<code>a_rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_is_symlink_7","title":"<code>a_is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_readlink_7","title":"<code>a_readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_symlink_to_7","title":"<code>a_symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_rmtree_7","title":"<code>a_rmtree</code><code>(</code><code>ignore_errors=False</code>, <code>onerror=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copy_7","title":"<code>a_copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_copytree_7","title":"<code>a_copytree</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#panpathcloudcloudpatha_open_7","title":"<code>a_open</code><code>(</code><code>mode='r'</code>, <code>encoding=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathnew_5","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>*args</code>, <code>mounted=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_5","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_5","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_5","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_name_5","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_suffix_5","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathwith_stem_5","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathjoinpath_5","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathtruediv_5","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathfspath_3","title":"<code>__fspath__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathget_fspath_3","title":"<code>get_fspath</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.plugin/","title":"xqute.plugin","text":"module &lt;/&gt; <p>Hook specifications for scheduler plugins</p> Functions <ul> <li><code>on_init</code><code>(</code><code>xqute</code><code>)</code> \u2014 When xqute is initialized&lt;/&gt;</li> <li><code>on_job_failed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is failed&lt;/&gt;</li> <li><code>on_job_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is initialized&lt;/&gt;</li> <li><code>on_job_killed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is killed&lt;/&gt;</li> <li><code>on_job_killing</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is being killed&lt;/&gt;</li> <li><code>on_job_polling</code><code>(</code><code>scheduler</code>, <code>job</code>, <code>counter</code><code>)</code> \u2014 When the system is polling job status&lt;/&gt;</li> <li><code>on_job_queued</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is queued&lt;/&gt;</li> <li><code>on_job_started</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job starts to run.&lt;/&gt;</li> <li><code>on_job_submitted</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is submitted&lt;/&gt;</li> <li><code>on_job_submitting</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is to be submitted&lt;/&gt;</li> <li><code>on_job_succeeded</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is succeeded&lt;/&gt;</li> <li><code>on_jobcmd_end</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command finishes and after the postscript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command wrapper script is initialized before the prescript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_prep</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command right about to be runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>. For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins. &lt;/&gt;</li> <li><code>on_shutdown</code><code>(</code><code>xqute</code>, <code>sig</code><code>)</code> \u2014 When xqute is shutting down&lt;/&gt;</li> </ul> function &lt;/&gt; <p>When xqute is initialized</p><p>Note that this hook will run at the same time when producer and consumer start. So they are not ensured to be started at this point.</p> Parameters <ul> <li><code>xqute</code> (Xqute) \u2014 The xqute object</li> </ul> function &lt;/&gt; <p>When xqute is shutting down</p><p>Return False to stop shutting down, but you have to shut it down by yourself, for example, <code>xqute.task.cancel()</code></p> <p>Only the first return value will be used.</p> Parameters <ul> <li><code>xqute</code> (Xqute) \u2014 The xqute object</li> <li><code>sig</code> (signal.signals | none) \u2014 The signal. <code>None</code> means a natural shutdown</li> </ul> function &lt;/&gt; <p>When the job is initialized</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is queued</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is to be submitted</p><p>Return False to cancel submitting. Only the first return value is used.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is submitted</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job starts to run.</p><p>Note that this is not when exactly the job starts to run, but when the scheduler starts to wait for the job to finish. So this hook is not suitable for measuring the time of the job.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the system is polling job status</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> <li><code>counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> function &lt;/&gt; <p>When the job is being killed</p><p>Return False to stop killing the job.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is killed</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is failed</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is succeeded</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job command wrapper script is initialized before the prescript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. For multiple plugins, the code will be inserted in the order of the plugin priority.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p> function &lt;/&gt; <p>When the job command right about to be runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>. For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p> function &lt;/&gt; <p>When the job command finishes and after the postscript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command. For multiple plugins, the code will be inserted in the order of the plugin priority.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p>"},{"location":"api/xqute.plugin/#xquteplugin","title":"xqute.plugin","text":""},{"location":"api/xqute.plugin/#xqutepluginon_init","title":"<code>xqute.plugin.</code><code>on_init</code><code>(</code><code>xqute</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_shutdown","title":"<code>xqute.plugin.</code><code>on_shutdown</code><code>(</code><code>xqute</code>, <code>sig</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_init","title":"<code>xqute.plugin.</code><code>on_job_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_queued","title":"<code>xqute.plugin.</code><code>on_job_queued</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_submitting","title":"<code>xqute.plugin.</code><code>on_job_submitting</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_submitted","title":"<code>xqute.plugin.</code><code>on_job_submitted</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_started","title":"<code>xqute.plugin.</code><code>on_job_started</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_polling","title":"<code>xqute.plugin.</code><code>on_job_polling</code><code>(</code><code>scheduler</code>, <code>job</code>, <code>counter</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_killing","title":"<code>xqute.plugin.</code><code>on_job_killing</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_killed","title":"<code>xqute.plugin.</code><code>on_job_killed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_failed","title":"<code>xqute.plugin.</code><code>on_job_failed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_succeeded","title":"<code>xqute.plugin.</code><code>on_job_succeeded</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_jobcmd_init","title":"<code>xqute.plugin.</code><code>on_jobcmd_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_jobcmd_prep","title":"<code>xqute.plugin.</code><code>on_jobcmd_prep</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_jobcmd_end","title":"<code>xqute.plugin.</code><code>on_jobcmd_end</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/","title":"xqute.scheduler","text":"module &lt;/&gt; <p>The scheduler to schedule jobs</p> Classes <ul> <li><code>Scheduler</code><code>(</code><code>workdir</code>, <code>forks</code>, <code>error_strategy</code>, <code>num_retries</code>, <code>prescript</code>, <code>postscript</code>, <code>jobname_prefix</code>, <code>submission_batch</code>, <code>recheck_interval</code>, <code>cwd</code>, <code>**kwargs</code><code>)</code> \u2014 The abstract class for scheduler&lt;/&gt;</li> </ul> abstract class &lt;/&gt; <p>The abstract class for scheduler</p> Attributes <ul> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>workdir</code> (str | pathlib.path) \u2014 The working directory</li> <li><code>forks</code> (int, optional) \u2014 Max number of job forks</li> <li><code>error_strategy</code> (str, optional) \u2014 The strategy when there is error happened</li> <li><code>num_retries</code> (int, optional) \u2014 Max number of retries when error_strategy is retry</li> <li><code>prescript</code> (str, optional) \u2014 The prescript to run before the job commandIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>postscript</code> (str, optional) \u2014 The postscript to run when job finishedIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>jobname_prefix</code> (str | none, optional) \u2014 The prefix for the job name</li> <li><code>submission_batch</code> (int | none, optional) \u2014 The number of consumers to submit jobs. This allowsmultiple jobs to be submitted in parallel. This is useful when there are many jobs to be submitted and the scheduler has a high latency for each submission. Set this to a smaller number if the scheduler cannot handle too many simultaneous submissions. </li> <li><code>recheck_interval</code> (int, optional) \u2014 The number of polling iterations between rechecks ofwhether a job is still running on the scheduler. Helps detect jobs that fail before the wrapped script updates status (e.g., resource allocation failures). Each iteration takes <code>xqute.defaults.SLEEP_INTERVAL_POLLING_JOBS</code> </li> <li><code>cwd</code> (str | pathlib.path, optional) \u2014 The working directory for the job command wrapper</li> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done (full polling with hooks)&lt;/&gt;</li> <li><code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code> (int) \u2014 Count currently running/active jobs (lightweight check)&lt;/&gt;</li> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is really running&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (int | str) \u2014 Submit a job&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status</code>, <code>flush</code>, <code>rc</code>, <code>error_msg</code>, <code>is_killed</code><code>)</code> \u2014 Centralized status transition handler&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Centralized status transition handler</p><p>Handles all aspects of job status transitions: <ul><li>- Status change logging</li><li>- Hook lifecycle management (ensuring on_job_started is called)</li><li>- Appropriate hook calls based on new status</li><li>- RC file updates</li><li>- Error message appending to stderr</li><li>- JID file cleanup for terminal states</li><li>- Pipeline halt on errors if configured</li></ul><p>Note that this method will not flush status changes to disk (job.status_file).You need to call job.set_status() separately if needed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to transition</li> <li><code>new_status</code> (int) \u2014 The new status to transition to</li> <li><code>old_status</code> (int | none, optional) \u2014 The previous status (if known).If None, will use job._status </li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to disk</li> <li><code>rc</code> (str | none, optional) \u2014 Optional return code to write to rc_file</li> <li><code>error_msg</code> (str | none, optional) \u2014 Optional error message to append to stderr_file</li> <li><code>is_killed</code> (bool, optional) \u2014 Whether this is a killed job (uses on_job_killed hook)</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Count currently running/active jobs (lightweight check)</p><p>This is optimized for the producer to check if new jobs can be submitted. It only counts jobs without refreshing status or calling hooks.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> Returns (int) <p>Number of jobs currently in active states</p> method &lt;/&gt; <p>Check if all jobs are done (full polling with hooks)</p><p>This does complete status refresh and calls all lifecycle hooks. Used by the main polling loop to track job completion.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>polling_counter</code> (int) \u2014 The polling counter for hook calls</li> </ul> Returns (bool) <p>True if all jobs are done, False otherwise</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> abstract method &lt;/&gt; <p>Submit a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (int | str) <p>The unique id in the scheduler system</p> abstract method &lt;/&gt; <p>Kill a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> abstract method &lt;/&gt; <p>Check if a job is really running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p>"},{"location":"api/xqute.scheduler/#xqutescheduler","title":"xqute.scheduler","text":""},{"location":"api/xqute.scheduler/#xquteschedulerscheduler","title":"<code>xqute.scheduler.</code><code>Scheduler</code><code>(</code><code>workdir</code>, <code>forks=1</code>, <code>error_strategy='ignore'</code>, <code>num_retries=3</code>, <code>prescript=''</code>, <code>postscript=''</code>, <code>jobname_prefix=None</code>, <code>submission_batch=None</code>, <code>recheck_interval=60</code>, <code>cwd=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulertransition_job_status","title":"<code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status=None</code>, <code>flush=True</code>, <code>rc=None</code>, <code>error_msg=None</code>, <code>is_killed=False</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulercount_running_jobs","title":"<code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulercheck_all_done","title":"<code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/","title":"xqute.schedulers.container_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs via containers</p> Classes <ul> <li><code>ContainerScheduler</code> \u2014 Scheduler to run jobs via containers (Docker/Podman/Apptainer)&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.schedulers.local_scheduler.LocalScheduler xqute.scheduler.Scheduler <p>Scheduler to run jobs via containers (Docker/Podman/Apptainer)</p><p>This scheduler can execute jobs inside containers using Docker, Podman, or Apptainer.</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Additional arguments passed to parent Scheduler</li> <li><code>image</code> (str) \u2014 Container image to use for running jobs</li> <li><code>entrypoint</code> (Union, optional) \u2014 Entrypoint command for the container</li> <li><code>bin</code> (str, optional) \u2014 Path to container runtime binary (e.g. /path/to/docker)</li> <li><code>volumes</code> (Union, optional) \u2014 host:container volume mapping string or stringsor named volume mapping like <code>MOUNTED=/path/on/host</code> then it will be mounted to <code>/mnt/disks/MOUNTED</code> in the container. You can use environment variable <code>MOUNTED</code> in your job scripts to refer to the mounted path. </li> <li><code>remove</code> (bool, optional) \u2014 Whether to remove the container after execution.Only applies to Docker/Podman. </li> <li><code>user</code> (str | none, optional) \u2014 User to run the container as (only for Docker/Podman)By default, it runs as the current user (os.getuid() and os.getgid()) </li> <li><code>bin_args</code> (Optional, optional) \u2014 Additional arguments to pass to the container runtime</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done (full polling with hooks)&lt;/&gt;</li> <li><code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code> (int) \u2014 Count currently running/active jobs (lightweight check)&lt;/&gt;</li> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job asynchronously&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (int) \u2014 Submit a job locally&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status</code>, <code>flush</code>, <code>rc</code>, <code>error_msg</code>, <code>is_killed</code><code>)</code> \u2014 Centralized status transition handler&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Centralized status transition handler</p><p>Handles all aspects of job status transitions: <ul><li>- Status change logging</li><li>- Hook lifecycle management (ensuring on_job_started is called)</li><li>- Appropriate hook calls based on new status</li><li>- RC file updates</li><li>- Error message appending to stderr</li><li>- JID file cleanup for terminal states</li><li>- Pipeline halt on errors if configured</li></ul><p>Note that this method will not flush status changes to disk (job.status_file).You need to call job.set_status() separately if needed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to transition</li> <li><code>new_status</code> (int) \u2014 The new status to transition to</li> <li><code>old_status</code> (int | none, optional) \u2014 The previous status (if known).If None, will use job._status </li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to disk</li> <li><code>rc</code> (str | none, optional) \u2014 Optional return code to write to rc_file</li> <li><code>error_msg</code> (str | none, optional) \u2014 Optional error message to append to stderr_file</li> <li><code>is_killed</code> (bool, optional) \u2014 Whether this is a killed job (uses on_job_killed hook)</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Count currently running/active jobs (lightweight check)</p><p>This is optimized for the producer to check if new jobs can be submitted. It only counts jobs without refreshing status or calling hooks.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> Returns (int) <p>Number of jobs currently in active states</p> method &lt;/&gt; <p>Check if all jobs are done (full polling with hooks)</p><p>This does complete status refresh and calls all lifecycle hooks. Used by the main polling loop to track job completion.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>polling_counter</code> (int) \u2014 The polling counter for hook calls</li> </ul> Returns (bool) <p>True if all jobs are done, False otherwise</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Kill a job asynchronously</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job locally</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (int) <p>The process id</p> method &lt;/&gt; <p>The job command init</p>"},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_scheduler","title":"xqute.schedulers.container_scheduler","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerscheduler","title":"<code>xqute.schedulers.container_scheduler.</code><code>ContainerScheduler</code><code>(</code><code>image</code>, <code>entrypoint='/bin/bash'</code>, <code>bin='docker'</code>, <code>volumes=None</code>, <code>remove=True</code>, <code>user=None</code>, <code>bin_args=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulertransition_job_status","title":"<code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status=None</code>, <code>flush=True</code>, <code>rc=None</code>, <code>error_msg=None</code>, <code>is_killed=False</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulercount_running_jobs","title":"<code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulercheck_all_done","title":"<code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerslocal_schedulerlocalschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerslocal_schedulerlocalschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerslocal_schedulerlocalschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/","title":"xqute.schedulers.gbatch_scheduler","text":"module &lt;/&gt; Classes <ul> <li><code>GbatchScheduler</code> \u2014 Scheduler for Google Cloud Batch&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>Scheduler for Google Cloud Batch</p><p>You can pass extra configuration parameters to the constructor that will be used in the job configuration file. For example, you can pass <code>taskGroups</code> to specify the task groups and their specifications.</p> <p>For using containers, it is a little bit tricky to specify the commands. When no <code>entrypoint</code> is specified, the <code>commands</code> should be a list with the first element being the interpreter (e.g. <code>/bin/bash</code>) and the second element being the path to the wrapped job script. If the <code>entrypoint</code> is specified, we can use the <code>{lang}</code> and <code>{script}</code> placeholders in the <code>commands</code> list, where <code>{lang}</code> will be replaced with the interpreter (e.g. <code>/bin/bash</code>) and <code>{script}</code> will be replaced with the path to the wrapped job script. With <code>entrypoint</code> specified and no <code>{script}</code> placeholder, the joined command will be the interpreter followed by the path to the wrapped job script will be appended to the <code>commands</code> list.</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> <li><code>project</code> (str) \u2014 GCP project ID</li> <li><code>location</code> (str) \u2014 GCP location (e.g. us-central1)</li> <li><code>mount</code> (Union, optional) \u2014 GCS path to mount (e.g. gs://my-bucket:/mnt/my-bucket)You can pass a list of mounts. You can also use named mount like <code>NAME=gs://bucket/dir</code> then it will be mounted to <code>/mnt/disks/NAME</code> in the container. You can use environment variable <code>NAME</code> in your job scripts to refer to the mounted path. </li> <li><code>service_account</code> (str | none, optional) \u2014 GCP service account email (e.g. test-account@example.com)</li> <li><code>network</code> (str | none, optional) \u2014 GCP network (e.g. default-network)</li> <li><code>subnetwork</code> (str | none, optional) \u2014 GCP subnetwork (e.g. regions/us-central1/subnetworks/default)</li> <li><code>no_external_ip_address</code> (bool | none, optional) \u2014 Whether to disable external IP address</li> <li><code>machine_type</code> (str | none, optional) \u2014 GCP machine type (e.g. e2-standard-4)</li> <li><code>provisioning_model</code> (str | none, optional) \u2014 GCP provisioning model (e.g. SPOT)</li> <li><code>image_uri</code> (str | none, optional) \u2014 Container image URI (e.g. ubuntu-2004-lts)</li> <li><code>entrypoint</code> (str, optional) \u2014 Container entrypoint (e.g. /bin/bash)</li> <li><code>commands</code> (Union, optional) \u2014 The command list to run in the container.There are three ways to specify the commands: 1. If no entrypoint is specified, the final command will be [commands, wrapped_script], where the entrypoint is the wrapper script interpreter that is determined by <code>JOBCMD_WRAPPER_LANG</code> (e.g. /bin/bash), commands is the list you provided, and wrapped_script is the path to the wrapped job script. 2. You can specify something like \"-c\", then the final command will be [\"-c\", \"wrapper_script_interpreter, wrapper_script\"] 3. You can use the placeholders <code>{lang}</code> and <code>{script}</code> in the commands list, where <code>{lang}</code> will be replaced with the interpreter (e.g. /bin/bash) and <code>{script}</code> will be replaced with the path to the wrapped job script. For example, you can specify [\"{lang} {script}\"] and the final command will be [\"wrapper_interpreter, wrapper_script\"] </li> <li><code>runnables</code> (Optional, optional) \u2014 Additional runnables to run before or after the main job.Each runnable should be a dictionary that follows the GCP Batch API specification. You can also specify an \"order\" key in the dictionary to control the execution order of the runnables. Runnables with negative order will be executed before the main job, and those with non-negative order will be executed after the main job. The main job runnable will always be executed in the order it is defined in the list. </li> </ul> Attributes <ul> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done (full polling with hooks)&lt;/&gt;</li> <li><code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code> (int) \u2014 Count currently running/active jobs (lightweight check)&lt;/&gt;</li> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is really running&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status</code>, <code>flush</code>, <code>rc</code>, <code>error_msg</code>, <code>is_killed</code><code>)</code> \u2014 Centralized status transition handler&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Centralized status transition handler</p><p>Handles all aspects of job status transitions: <ul><li>- Status change logging</li><li>- Hook lifecycle management (ensuring on_job_started is called)</li><li>- Appropriate hook calls based on new status</li><li>- RC file updates</li><li>- Error message appending to stderr</li><li>- JID file cleanup for terminal states</li><li>- Pipeline halt on errors if configured</li></ul><p>Note that this method will not flush status changes to disk (job.status_file).You need to call job.set_status() separately if needed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to transition</li> <li><code>new_status</code> (int) \u2014 The new status to transition to</li> <li><code>old_status</code> (int | none, optional) \u2014 The previous status (if known).If None, will use job._status </li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to disk</li> <li><code>rc</code> (str | none, optional) \u2014 Optional return code to write to rc_file</li> <li><code>error_msg</code> (str | none, optional) \u2014 Optional error message to append to stderr_file</li> <li><code>is_killed</code> (bool, optional) \u2014 Whether this is a killed job (uses on_job_killed hook)</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Count currently running/active jobs (lightweight check)</p><p>This is optimized for the producer to check if new jobs can be submitted. It only counts jobs without refreshing status or calling hooks.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> Returns (int) <p>Number of jobs currently in active states</p> method &lt;/&gt; <p>Check if all jobs are done (full polling with hooks)</p><p>This does complete status refresh and calls all lifecycle hooks. Used by the main polling loop to track job completion.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>polling_counter</code> (int) \u2014 The polling counter for hook calls</li> </ul> Returns (bool) <p>True if all jobs are done, False otherwise</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The unique id in the scheduler system</p> method &lt;/&gt; <p>Kill a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>Check if a job is really running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The job command init</p>"},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_scheduler","title":"xqute.schedulers.gbatch_scheduler","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchscheduler","title":"<code>xqute.schedulers.gbatch_scheduler.</code><code>GbatchScheduler</code><code>(</code><code>*args</code>, <code>project</code>, <code>location</code>, <code>mount=None</code>, <code>service_account=None</code>, <code>network=None</code>, <code>subnetwork=None</code>, <code>no_external_ip_address=None</code>, <code>machine_type=None</code>, <code>provisioning_model=None</code>, <code>image_uri=None</code>, <code>entrypoint=None</code>, <code>commands=None</code>, <code>runnables=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulertransition_job_status","title":"<code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status=None</code>, <code>flush=True</code>, <code>rc=None</code>, <code>error_msg=None</code>, <code>is_killed=False</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulercount_running_jobs","title":"<code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulercheck_all_done","title":"<code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/","title":"xqute.schedulers.local_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs locally</p> Classes <ul> <li><code>LocalScheduler</code> \u2014 The local scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>The local scheduler</p> Parameters <ul> <li><code>workdir</code> (str | Path) \u2014 The working directory</li> <li><code>forks</code> (int, optional) \u2014 Max number of job forks</li> <li><code>error_strategy</code> (str, optional) \u2014 The strategy when there is error happened</li> <li><code>num_retries</code> (int, optional) \u2014 Max number of retries when error_strategy is retry</li> <li><code>prescript</code> (str, optional) \u2014 The prescript to run before the job commandIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>postscript</code> (str, optional) \u2014 The postscript to run when job finishedIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>jobname_prefix</code> (str | none, optional) \u2014 The prefix for the job name</li> <li><code>submission_batch</code> (int | none, optional) \u2014 The number of consumers to submit jobs. This allowsmultiple jobs to be submitted in parallel. This is useful when there are many jobs to be submitted and the scheduler has a high latency for each submission. Set this to a smaller number if the scheduler cannot handle too many simultaneous submissions. </li> <li><code>recheck_interval</code> (int, optional) \u2014 The number of polling iterations between rechecks ofwhether a job is still running on the scheduler. Helps detect jobs that fail before the wrapped script updates status (e.g., resource allocation failures). Each iteration takes <code>xqute.defaults.SLEEP_INTERVAL_POLLING_JOBS</code> </li> <li><code>cwd</code> (str | Path, optional) \u2014 The working directory for the job command wrapper</li> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done (full polling with hooks)&lt;/&gt;</li> <li><code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code> (int) \u2014 Count currently running/active jobs (lightweight check)&lt;/&gt;</li> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job asynchronously&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (int) \u2014 Submit a job locally&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status</code>, <code>flush</code>, <code>rc</code>, <code>error_msg</code>, <code>is_killed</code><code>)</code> \u2014 Centralized status transition handler&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Centralized status transition handler</p><p>Handles all aspects of job status transitions: <ul><li>- Status change logging</li><li>- Hook lifecycle management (ensuring on_job_started is called)</li><li>- Appropriate hook calls based on new status</li><li>- RC file updates</li><li>- Error message appending to stderr</li><li>- JID file cleanup for terminal states</li><li>- Pipeline halt on errors if configured</li></ul><p>Note that this method will not flush status changes to disk (job.status_file).You need to call job.set_status() separately if needed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to transition</li> <li><code>new_status</code> (int) \u2014 The new status to transition to</li> <li><code>old_status</code> (int | none, optional) \u2014 The previous status (if known).If None, will use job._status </li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to disk</li> <li><code>rc</code> (str | none, optional) \u2014 Optional return code to write to rc_file</li> <li><code>error_msg</code> (str | none, optional) \u2014 Optional error message to append to stderr_file</li> <li><code>is_killed</code> (bool, optional) \u2014 Whether this is a killed job (uses on_job_killed hook)</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Count currently running/active jobs (lightweight check)</p><p>This is optimized for the producer to check if new jobs can be submitted. It only counts jobs without refreshing status or calling hooks.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> Returns (int) <p>Number of jobs currently in active states</p> method &lt;/&gt; <p>Check if all jobs are done (full polling with hooks)</p><p>This does complete status refresh and calls all lifecycle hooks. Used by the main polling loop to track job completion.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>polling_counter</code> (int) \u2014 The polling counter for hook calls</li> </ul> Returns (bool) <p>True if all jobs are done, False otherwise</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job locally</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (int) <p>The process id</p> method &lt;/&gt; <p>Kill a job asynchronously</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> method &lt;/&gt; <p>The job command preparation</p>"},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_scheduler","title":"xqute.schedulers.local_scheduler","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalscheduler","title":"<code>xqute.schedulers.local_scheduler.</code><code>LocalScheduler</code><code>(</code><code>workdir</code>, <code>forks=1</code>, <code>error_strategy='ignore'</code>, <code>num_retries=3</code>, <code>prescript=''</code>, <code>postscript=''</code>, <code>jobname_prefix=None</code>, <code>submission_batch=None</code>, <code>recheck_interval=60</code>, <code>cwd=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulertransition_job_status","title":"<code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status=None</code>, <code>flush=True</code>, <code>rc=None</code>, <code>error_msg=None</code>, <code>is_killed=False</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulercount_running_jobs","title":"<code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulercheck_all_done","title":"<code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers/","title":"xqute.schedulers","text":"package &lt;/&gt; <p>Builtin schedulers</p> Functions <ul> <li><code>get_scheduler</code><code>(</code><code>scheduler</code><code>)</code> (Type) \u2014 Get the scheduler class&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs locally</p> Classes <ul> <li><code>LocalScheduler</code> \u2014 The local scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs via containers</p> Classes <ul> <li><code>ContainerScheduler</code> \u2014 Scheduler to run jobs via containers (Docker/Podman/Apptainer)&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs on SGE</p> Classes <ul> <li><code>SgeScheduler</code> \u2014 The sge scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs on Slurm</p> Classes <ul> <li><code>SlurmScheduler</code> \u2014 The Slurm scheduler&lt;/&gt;</li> </ul>"},{"location":"api/xqute.schedulers/#xquteschedulers","title":"xqute.schedulers","text":""},{"location":"api/xqute.schedulers/#xquteschedulerslocal_scheduler","title":"xqute.schedulers.local_scheduler","text":""},{"location":"api/xqute.schedulers/#xquteschedulerscontainer_scheduler","title":"xqute.schedulers.container_scheduler","text":""},{"location":"api/xqute.schedulers/#xquteschedulerssge_scheduler","title":"xqute.schedulers.sge_scheduler","text":""},{"location":"api/xqute.schedulers/#xquteschedulersslurm_scheduler","title":"xqute.schedulers.slurm_scheduler","text":""},{"location":"api/xqute.schedulers.sge_scheduler/","title":"xqute.schedulers.sge_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs on SGE</p> Classes <ul> <li><code>SgeScheduler</code> \u2014 The sge scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>The sge scheduler</p> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done (full polling with hooks)&lt;/&gt;</li> <li><code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code> (int) \u2014 Count currently running/active jobs (lightweight check)&lt;/&gt;</li> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on SGE&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to SGE&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status</code>, <code>flush</code>, <code>rc</code>, <code>error_msg</code>, <code>is_killed</code><code>)</code> \u2014 Centralized status transition handler&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Centralized status transition handler</p><p>Handles all aspects of job status transitions: <ul><li>- Status change logging</li><li>- Hook lifecycle management (ensuring on_job_started is called)</li><li>- Appropriate hook calls based on new status</li><li>- RC file updates</li><li>- Error message appending to stderr</li><li>- JID file cleanup for terminal states</li><li>- Pipeline halt on errors if configured</li></ul><p>Note that this method will not flush status changes to disk (job.status_file).You need to call job.set_status() separately if needed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to transition</li> <li><code>new_status</code> (int) \u2014 The new status to transition to</li> <li><code>old_status</code> (int | none, optional) \u2014 The previous status (if known).If None, will use job._status </li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to disk</li> <li><code>rc</code> (str | none, optional) \u2014 Optional return code to write to rc_file</li> <li><code>error_msg</code> (str | none, optional) \u2014 Optional error message to append to stderr_file</li> <li><code>is_killed</code> (bool, optional) \u2014 Whether this is a killed job (uses on_job_killed hook)</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Count currently running/active jobs (lightweight check)</p><p>This is optimized for the producer to check if new jobs can be submitted. It only counts jobs without refreshing status or calling hooks.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> Returns (int) <p>Number of jobs currently in active states</p> method &lt;/&gt; <p>Check if all jobs are done (full polling with hooks)</p><p>This does complete status refresh and calls all lifecycle hooks. Used by the main polling loop to track job completion.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>polling_counter</code> (int) \u2014 The polling counter for hook calls</li> </ul> Returns (bool) <p>True if all jobs are done, False otherwise</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job to SGE</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on SGE</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p>"},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_scheduler","title":"xqute.schedulers.sge_scheduler","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgescheduler","title":"<code>xqute.schedulers.sge_scheduler.</code><code>SgeScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulertransition_job_status","title":"<code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status=None</code>, <code>flush=True</code>, <code>rc=None</code>, <code>error_msg=None</code>, <code>is_killed=False</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulercount_running_jobs","title":"<code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulercheck_all_done","title":"<code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/","title":"xqute.schedulers.slurm_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs on Slurm</p> Classes <ul> <li><code>SlurmScheduler</code> \u2014 The Slurm scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>The Slurm scheduler</p> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done (full polling with hooks)&lt;/&gt;</li> <li><code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code> (int) \u2014 Count currently running/active jobs (lightweight check)&lt;/&gt;</li> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on Slurm&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to Slurm&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status</code>, <code>flush</code>, <code>rc</code>, <code>error_msg</code>, <code>is_killed</code><code>)</code> \u2014 Centralized status transition handler&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Centralized status transition handler</p><p>Handles all aspects of job status transitions: <ul><li>- Status change logging</li><li>- Hook lifecycle management (ensuring on_job_started is called)</li><li>- Appropriate hook calls based on new status</li><li>- RC file updates</li><li>- Error message appending to stderr</li><li>- JID file cleanup for terminal states</li><li>- Pipeline halt on errors if configured</li></ul><p>Note that this method will not flush status changes to disk (job.status_file).You need to call job.set_status() separately if needed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to transition</li> <li><code>new_status</code> (int) \u2014 The new status to transition to</li> <li><code>old_status</code> (int | none, optional) \u2014 The previous status (if known).If None, will use job._status </li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to disk</li> <li><code>rc</code> (str | none, optional) \u2014 Optional return code to write to rc_file</li> <li><code>error_msg</code> (str | none, optional) \u2014 Optional error message to append to stderr_file</li> <li><code>is_killed</code> (bool, optional) \u2014 Whether this is a killed job (uses on_job_killed hook)</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Count currently running/active jobs (lightweight check)</p><p>This is optimized for the producer to check if new jobs can be submitted. It only counts jobs without refreshing status or calling hooks.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> Returns (int) <p>Number of jobs currently in active states</p> method &lt;/&gt; <p>Check if all jobs are done (full polling with hooks)</p><p>This does complete status refresh and calls all lifecycle hooks. Used by the main polling loop to track job completion.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>polling_counter</code> (int) \u2014 The polling counter for hook calls</li> </ul> Returns (bool) <p>True if all jobs are done, False otherwise</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job to Slurm</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on Slurm</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p>"},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_scheduler","title":"xqute.schedulers.slurm_scheduler","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmscheduler","title":"<code>xqute.schedulers.slurm_scheduler.</code><code>SlurmScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulertransition_job_status","title":"<code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status=None</code>, <code>flush=True</code>, <code>rc=None</code>, <code>error_msg=None</code>, <code>is_killed=False</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulercount_running_jobs","title":"<code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulercheck_all_done","title":"<code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler/","title":"xqute.schedulers.ssh_scheduler","text":"package &lt;/&gt; module &lt;/&gt; <p>The scheduler to run jobs on SSH</p> Classes <ul> <li><code>SshScheduler</code> \u2014 The ssh scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>This script is used to wrap the command for the scheduler to submit and run</p><p>It is used by the ssh scheduler to submit jobs to remote servers and print the pid of the job to stdout. The real command is run in a subprocess without waiting for the results.</p> <p>The script is executed by the scheduler, not the user. And it's not imported by xqute directly.</p> <p>Find a way to pass envs?</p>"},{"location":"api/xqute.schedulers.ssh_scheduler/#xquteschedulersssh_scheduler","title":"xqute.schedulers.ssh_scheduler","text":""},{"location":"api/xqute.schedulers.ssh_scheduler/#xquteschedulersssh_schedulerscheduler","title":"xqute.schedulers.ssh_scheduler.scheduler","text":""},{"location":"api/xqute.schedulers.ssh_scheduler/#xquteschedulersssh_schedulersubmitter","title":"xqute.schedulers.ssh_scheduler.submitter","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/","title":"xqute.schedulers.ssh_scheduler.scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs on SSH</p> Classes <ul> <li><code>SshScheduler</code> \u2014 The ssh scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.schedulers.local_scheduler.LocalScheduler xqute.scheduler.Scheduler <p>The ssh scheduler</p> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done (full polling with hooks)&lt;/&gt;</li> <li><code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code> (int) \u2014 Count currently running/active jobs (lightweight check)&lt;/&gt;</li> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on SSH&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to SSH&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status</code>, <code>flush</code>, <code>rc</code>, <code>error_msg</code>, <code>is_killed</code><code>)</code> \u2014 Centralized status transition handler&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Centralized status transition handler</p><p>Handles all aspects of job status transitions: <ul><li>- Status change logging</li><li>- Hook lifecycle management (ensuring on_job_started is called)</li><li>- Appropriate hook calls based on new status</li><li>- RC file updates</li><li>- Error message appending to stderr</li><li>- JID file cleanup for terminal states</li><li>- Pipeline halt on errors if configured</li></ul><p>Note that this method will not flush status changes to disk (job.status_file).You need to call job.set_status() separately if needed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to transition</li> <li><code>new_status</code> (int) \u2014 The new status to transition to</li> <li><code>old_status</code> (int | none, optional) \u2014 The previous status (if known).If None, will use job._status </li> <li><code>flush</code> (bool, optional) \u2014 Whether to flush the status to disk</li> <li><code>rc</code> (str | none, optional) \u2014 Optional return code to write to rc_file</li> <li><code>error_msg</code> (str | none, optional) \u2014 Optional error message to append to stderr_file</li> <li><code>is_killed</code> (bool, optional) \u2014 Whether this is a killed job (uses on_job_killed hook)</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Count currently running/active jobs (lightweight check)</p><p>This is optimized for the producer to check if new jobs can be submitted. It only counts jobs without refreshing status or calling hooks.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> Returns (int) <p>Number of jobs currently in active states</p> method &lt;/&gt; <p>Check if all jobs are done (full polling with hooks)</p><p>This does complete status refresh and calls all lifecycle hooks. Used by the main polling loop to track job completion.</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>polling_counter</code> (int) \u2014 The polling counter for hook calls</li> </ul> Returns (bool) <p>True if all jobs are done, False otherwise</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>Submit a job to SSH</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on SSH</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p>"},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerscheduler","title":"xqute.schedulers.ssh_scheduler.scheduler","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshscheduler","title":"<code>xqute.schedulers.ssh_scheduler.scheduler.</code><code>SshScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulertransition_job_status","title":"<code>transition_job_status</code><code>(</code><code>job</code>, <code>new_status</code>, <code>old_status=None</code>, <code>flush=True</code>, <code>rc=None</code>, <code>error_msg=None</code>, <code>is_killed=False</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulercount_running_jobs","title":"<code>count_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulercheck_all_done","title":"<code>check_all_done</code><code>(</code><code>jobs</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerslocal_schedulerlocalschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.submitter/","title":"xqute.schedulers.ssh_scheduler.submitter","text":"module &lt;/&gt; <p>This script is used to wrap the command for the scheduler to submit and run</p><p>It is used by the ssh scheduler to submit jobs to remote servers and print the pid of the job to stdout. The real command is run in a subprocess without waiting for the results.</p> <p>The script is executed by the scheduler, not the user. And it's not imported by xqute directly.</p> <p>Find a way to pass envs?</p>"},{"location":"api/xqute.schedulers.ssh_scheduler.submitter/#xquteschedulersssh_schedulersubmitter","title":"xqute.schedulers.ssh_scheduler.submitter","text":""},{"location":"api/xqute.utils/","title":"xqute.utils","text":"module &lt;/&gt; <p>Utilities for xqute</p>"},{"location":"api/xqute.utils/#xquteutils","title":"xqute.utils","text":""},{"location":"api/xqute.xqute/","title":"xqute.xqute","text":"module &lt;/&gt; <p>The xqute module</p> Classes <ul> <li><code>Xqute</code> \u2014 The main class of the package&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The main class of the package</p> Attributes <ul> <li><code>EMPTY_BUFFER_SLEEP_TIME</code> \u2014 The time to sleep while waiting whenthe buffer is empty to wait for the jobs to be pushed </li> <li><code>_cancelling</code> \u2014 A mark to mark whether a shutting down eventis triggered (True for natural cancelling, the signal for cancelling with a signal, SIGINT for example) </li> <li><code>buffer_queue</code> \u2014 A buffer queue to save the pushed jobs</li> <li><code>jobs</code> \u2014 The jobs registry</li> <li><code>name</code> \u2014 The name, used in logger</li> <li><code>plugins</code> \u2014 The plugins to be enabled or disabledto disable a plugin, using <code>-plugin_name</code> either all plugin names should be prefixed with '+'/'-' or none of them should </li> <li><code>queue</code> \u2014 The job queue</li> <li><code>scheduler</code> \u2014 The scheduler</li> <li><code>task</code> \u2014 The task of producer and consumers</li> </ul> Parameters <ul> <li><code>scheduler</code> (str | Type[Scheduler], optional) \u2014 The scheduler class or name</li> <li><code>plugins</code> (Optional, optional) \u2014 The plugins to be enabled or disabledto disable a plugin, using <code>-plugin_name</code> either all plugin names should be prefixed with '+'/'-' or none of them should </li> <li><code>workdir</code> (str | PathType, optional) \u2014 The job meta directory</li> <li><code>submission_batch</code> (int | none, optional) \u2014 The number of consumers to submit jobs. This allowsmultiple jobs to be submitted in parallel. This is useful when there are many jobs to be submitted and the scheduler has a high latency for each submission. Set this to a smaller number if the scheduler cannot handle too many simultaneous submissions. </li> <li><code>error_strategy</code> (str, optional) \u2014 The strategy when there is error happened</li> <li><code>num_retries</code> (int, optional) \u2014 Max number of retries when error_strategy is retry</li> <li><code>forks</code> (int, optional) \u2014 Max number of job forks for scheduler</li> <li><code>scheduler_opts</code> (Optional, optional) \u2014 Additional keyword arguments for scheduler</li> </ul> Methods <ul> <li><code>__del__</code><code>(</code><code>)</code> \u2014 Destructor to warn if stop_feeding was not called&lt;/&gt;</li> <li><code>cancel</code><code>(</code><code>sig</code><code>)</code> \u2014 Cancel the producer-consumer task&lt;/&gt;</li> <li><code>feed</code><code>(</code><code>cmd</code>, <code>envs</code><code>)</code> \u2014 Put a command into the buffer&lt;/&gt;</li> <li><code>is_feeding</code><code>(</code><code>)</code> (bool) \u2014 Check if the system is in keep_feeding mode.&lt;/&gt;</li> <li><code>run_until_complete</code><code>(</code><code>keep_feeding</code><code>)</code> \u2014 Wait until all jobs complete&lt;/&gt;</li> <li><code>stop_feeding</code><code>(</code><code>)</code> \u2014 Stop feeding mode and wait for all jobs to complete.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Destructor to warn if stop_feeding was not called</p> method &lt;/&gt; <p>Cancel the producer-consumer task</p><p><code>self._cancelling</code> will be set to <code>signaled</code> if sig is provided, otherwise it will be set to <code>True</code></p> Parameters <ul> <li><code>sig</code> (signal.signals | none, optional) \u2014 Whether this cancelling is caused by a signal</li> </ul> method &lt;/&gt; <p>Put a command into the buffer</p> Parameters <ul> <li><code>cmd</code> (CommandType | Job) \u2014 The command</li> <li><code>envs</code> (dict, optional) \u2014 The environment variables for the job</li> </ul> method &lt;/&gt; <p>Check if the system is in keep_feeding mode.</p> Returns (bool) <p>True if in keep_feeding mode and waiting for stop_feeding() to be called.</p> method &lt;/&gt; <p>Stop feeding mode and wait for all jobs to complete.</p><p>After calling this method, the producer will exit once the buffer queue is empty, and this method will wait for all jobs to complete. This should be called after all jobs have been submitted when using run_until_complete(keep_feeding=True).</p> Raises <ul> <li><code>RuntimeError</code> \u2014 If called without first callingrun_until_complete(keep_feeding=True) </li> </ul> method &lt;/&gt; <p>Wait until all jobs complete</p> Parameters <ul> <li><code>keep_feeding</code> (bool, optional) \u2014 If True, starts running in background and returns immediately,allowing jobs to be added after calling this method. You must call stop_feeding() when done adding jobs, which will wait for all jobs to complete. If False (default), waits for all current jobs to complete immediately. </li> </ul> Examples <p>Traditional usage:<pre><code>xqute = Xqute()\nawait xqute.feed(['echo', '1'])\nawait xqute.feed(['echo', '2'])\nawait xqute.run_until_complete()\n</code></pre></p> <p>Keep feeding mode: <pre><code>xqute = Xqute()\nawait xqute.feed(['echo', '1'])\nawait xqute.run_until_complete(keep_feeding=True)  # Returns immediately\nawait xqute.feed(['echo', '2'])  # Can add more jobs\nawait xqute.stop_feeding()  # Waits for completion\n</code></pre></p>"},{"location":"api/xqute.xqute/#xqutexqute","title":"xqute.xqute","text":""},{"location":"api/xqute.xqute/#xqutexqutexqute","title":"<code>xqute.xqute.</code><code>Xqute</code><code>(</code><code>scheduler='local'</code>, <code>plugins=None</code>, <code>workdir='./.xqute'</code>, <code>submission_batch=None</code>, <code>error_strategy='ignore'</code>, <code>num_retries=3</code>, <code>forks=1</code>, <code>scheduler_opts=None</code>, <code>jobname_prefix=None</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexqutedel","title":"<code>__del__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexqutecancel","title":"<code>cancel</code><code>(</code><code>sig=None</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexqutefeed","title":"<code>feed</code><code>(</code><code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexquteis_feeding","title":"<code>is_feeding</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexqutestop_feeding","title":"<code>stop_feeding</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexquterun_until_complete","title":"<code>run_until_complete</code><code>(</code><code>keep_feeding=False</code><code>)</code>","text":""},{"location":"api/source/xqute.defaults/","title":"xqute.defaults","text":""},{"location":"api/source/xqute.defaults/","title":"SOURCE CODE xqute.defaults DOCS","text":"<pre><code>\"\"\"Default settings and utilities for xqute\n\nAttributes:\n    DEFAULT_WORKDIR: The default work directory for jobs to save the metadata\n    DEFAULT_ERROR_STRATEGY: The default strategy when there is\n        error happened\n    DEFAULT_NUM_RETRIES: Default number of retries when\n        DEFAULT_ERROR_STRATEGY is retry\n    DEFAULT_JOB_CMD_WRAPPER_SHELL: The default shell for job wrapper\n    DEFAULT_SCHEDULER_FORKS: Default number of job forks for scheduler\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport asyncio\nimport textwrap\nfrom typing import Tuple\nimport uvloop\n\nasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n\n\nclass JobErrorStrategy:DOCS\n    \"\"\"The strategy when error happen from jobs\n\n    Attributes:\n        IGNORE: ignore and run next jobs\n        RETRY: retry the job\n        HALT: halt the whole program\n    \"\"\"\n\n    IGNORE: str = \"ignore\"\n    RETRY: str = \"retry\"\n    HALT: str = \"halt\"\n\n\nclass JobStatus:DOCS\n    \"\"\"The status of a job\n\n    Life cycles:\n    ........................queued in scheduler\n    INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; FINISHED (FAILED)\n    INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; KILLING -&gt; FINISHED\n    INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; KILLING -&gt; FINISHED\n    INIT -&gt; QUEUED -&gt; (CANCELLED)\n\n    Note that RUNNING, FINISHED and FAILED are the statuses that are polled\n    from the scheduler.\n    They can not be set directly by xqute; they are set in the job wrapper script.\n\n    Attributes:\n        INIT: When a job is initialized\n        # RETRYING: When a job is to be retried\n        QUEUED: When a job is queued\n        SUBMITTED: When a job is submitted\n        RUNNING: When a job is running\n        KILLING: When a job is being killed\n        FINISHED: When a job is finished\n        FAILED: When a job is failed\n    \"\"\"\n\n    INIT: int = 0\n    # RETRYING: int = 1\n    QUEUED: int = 2\n    SUBMITTED: int = 3\n    RUNNING: int = 4\n    KILLING: int = 5\n    FINISHED: int = 6\n    FAILED: int = 7\n\n    @classmethodDOCS\n    def get_name(cls, *statuses: int) -&gt; Tuple[str, ...] | str:\n        \"\"\"Get the name of the status\n\n        Args:\n            *statuses: The status values\n\n        Returns:\n            The name of the status if a single status is passed, otherwise\n            a tuple of names\n        \"\"\"\n        ret_dict = {}\n        for name, value in cls.__dict__.items():\n            if value in statuses:\n                ret_dict[value] = name\n        ret_tuple = tuple(ret_dict[status] for status in statuses)\n        if len(ret_tuple) &gt; 1:\n            return ret_tuple\n        return ret_tuple[0]\n\n\nLOGGER_NAME = \"XQUTE\"\nLOGGER_LEVEL = \"INFO\"\n\nDEFAULT_SCHEDULER_FORKS: int = 1\nDEFAULT_WORKDIR = \"./.xqute\"\nDEFAULT_ERROR_STRATEGY: str = JobErrorStrategy.IGNORE\nDEFAULT_NUM_RETRIES: int = 3\nDEFAULT_SUBMISSION_BATCH: int = 8\nDEFAULT_CLOUD_FSPATH: str = (\n    \"/tmp/xqute_cloud_cache_\"\n    f\"{os.getenv('USER', 'u' + str(os.getuid()))}\"\n)\nDEFAULT_RECHECK_INTERVAL: int = 60\n# DEFAULT_SUBMISSION_BATCH: int = 8\nJOBCMD_WRAPPER_LANG: str = \"/bin/bash\"\n\n# Sleep intervals (in seconds)\n# When producer hits max forks\nSLEEP_INTERVAL_PRODUCER_MAX_FORKS: float = 1.0\n# Polling interval for job status\nSLEEP_INTERVAL_POLLING_JOBS: float = 1.0\n# Polling interval for keep_feeding mode\nSLEEP_INTERVAL_KEEP_FEEDING: float = 0.1\n# Wait after job submission to ensure process is running\n# Wait for cloud file existence check\nSLEEP_INTERVAL_CLOUD_FILE_CHECK: float = 2.0\n# Wait for GBatch status check\nSLEEP_INTERVAL_GBATCH_STATUS_CHECK: float = 1.0\nJOBCMD_WRAPPER_TEMPLATE: str = r\"\"\"#!{shebang}\nset -x -u -E -o pipefail\n# exec &gt;\"{job.metadir.mounted}/job.wrapped.log\" 2&gt;&amp;1\n# TODO: make it work for cloud workdir\n\n{scheduler.jobcmd_wrapper_init}\n\nupdate_metafile \"{status.RUNNING}\" \"{job.status_file.mounted}\"\nupdate_metafile \"\" \"{job.stdout_file.mounted}\"\n\n# plugins.on_jobcmd_init\n{jobcmd_init}\n\n\ncleanup() {{\n    rc=$?\n    update_metafile \"$rc\" \"{job.rc_file.mounted}\"\n    if [[ $rc -eq 0 ]]; then\n        update_metafile \"{status.FINISHED}\" \"{job.status_file.mounted}\"\n    else\n        update_metafile \"{status.FAILED}\" \"{job.status_file.mounted}\"\n    fi\n\n    remove_metafile \"{job.jid_file.mounted}\"\n\n    # postscript\n    {scheduler.postscript}\n\n    # plugins.on_jobcmd_end\n    {jobcmd_end}\n\n    exit $rc\n}}\n\n# register trap\ntrap \"cleanup\" EXIT\n\n# prescript\n{scheduler.prescript}\n\ncmd=$(compose_cmd \"{cmd}\" \"{job.stdout_file.mounted}\" \"{job.stderr_file.mounted}\")\n\n# plugins.on_jobcmd_prep\n{jobcmd_prep}\n\n# Run the command, the real job\neval \"$cmd\"\n\"\"\"  # noqa: E501\n\n\ndef get_jobcmd_wrapper_init(local: bool) -&gt; str:DOCS\n    \"\"\"Get the job command wrapper initialization script\n\n    Args:\n        local: Whether the job is running locally\n\n    Returns:\n        The job command wrapper initialization script\n    \"\"\"\n    if local:\n        rm_file = 'mv \"$file\" \"${file}.used\"'\n        return textwrap.dedent(\n            f\"\"\"\n            export META_ON_CLOUD=0\n\n            update_metafile() {{\n                local content=$1\n                local file=$2\n                echo \"$content\" &gt; \"$file\"\n            }}\n\n            remove_metafile() {{\n                local file=$1\n                {rm_file}\n            }}\n\n            compose_cmd() {{\n                local cmd=$1\n                local stdout_file=$2\n                local stderr_file=$3\n                echo \"$cmd 1&gt;$stdout_file 2&gt;$stderr_file\"\n            }}\n            \"\"\"\n        )\n    else:\n        rm_file = 'cloudsh mv \"$file\" \"${file}_used\"'\n        return textwrap.dedent(\n            f\"\"\"\n            export META_ON_CLOUD=1\n\n            # Check if cloudsh is installed\n            if ! command -v cloudsh &amp;&gt; /dev/null; then\n                echo \"cloudsh is not installed to support cloud workdir, please install it first\" 1&gt;&amp;2\n                exit 1\n            fi\n\n            update_metafile() {{\n                local content=$1\n                local file=$2\n                echo \"$content\" | cloudsh sink \"$file\"\n            }}\n\n            remove_metafile() {{\n                local file=$1\n                {rm_file}\n            }}\n\n            compose_cmd() {{\n                local cmd=$1\n                local stdout_file=$2\n                local stderr_file=$3\n                # create temp files to save stderr\n                stderrtmp=$(mktemp)\n                echo \"$cmd 2&gt;$stderrtmp | cloudsh sink $stdout_file; \\\\\n                    rc=\\\\$?; \\\\\n                    cloudsh mv $stderrtmp $stderr_file; \\\\\n                    exit \\\\$rc\"\n            }}\n            \"\"\"  # noqa: E501\n        )\n</code></pre>"},{"location":"api/source/xqute.job/","title":"xqute.job","text":""},{"location":"api/source/xqute.job/","title":"SOURCE CODE xqute.job DOCS","text":"<pre><code>\"\"\"Job to execute\"\"\"\n\nfrom __future__ import annotations\n\nimport shlex\nfrom typing import Any, Tuple\n\nfrom .defaults import JobStatus\nfrom .utils import logger, CommandType\nfrom .path import SpecPath\n\n\nclass Job:DOCS\n    \"\"\"The class for job\n\n    Attributes:\n\n        cmd: The command\n        index: The index of the job\n        metadir: The metadir of the job\n        jid: The jid of the job in scheduler system\n        trial_count: The count for re-tries\n        _status: The status of the job\n        _rc: The return code of the job\n        _error_retry: Whether we should retry if error happened\n        _num_retries: Total number of retries\n\n    Args:\n        index: The index of the job\n        cmd: The command of the job\n        metadir: The meta directory of the Job\n        error_retry: Whether we should retry if error happened\n        num_retries: Total number of retries\n    \"\"\"\n\n    __slots__ = (\n        \"cmd\",\n        \"index\",\n        \"metadir\",\n        \"trial_count\",\n        \"_jid\",\n        \"_status\",\n        \"_rc\",\n        \"_error_retry\",\n        \"_num_retries\",\n        \"envs\",\n    )\n\n    def __init__(\n        self,\n        index: int,\n        cmd: CommandType,\n        workdir: SpecPath,\n        error_retry: bool | None = None,\n        num_retries: int | None = None,\n        envs: dict[str, Any] | None = None,\n    ):\n        \"\"\"Construct a new Job\n\n        Args:\n            index: The index of the job\n            cmd: The command of the job\n            metadir: The meta directory of the Job\n            error_retry: Whether we should retry if error happened\n            num_retries: Total number of retries\n        \"\"\"\n        self.cmd: Tuple[str, ...] = tuple(\n            map(\n                str,\n                (cmd if isinstance(cmd, (tuple, list)) else shlex.split(cmd)),\n            )\n        )\n        self.index = index\n        self.envs = envs or {}\n        self.envs[\"XQUTE_JOB_INDEX\"] = str(self.index)\n        self.envs[\"XQUTE_METADIR\"] = str(workdir)\n        self.metadir = workdir / str(self.index)  # type: ignore\n        self.envs[\"XQUTE_JOB_METADIR\"] = str(self.metadir)\n        # For cloud paths, this requires cloud client\n        # self.metadir.mkdir(exist_ok=True, parents=True)\n        # Let Scheduler.create_job handle metadir creation\n\n        # The name of the job, should be the unique id from the scheduler\n        self.trial_count = 0\n\n        self._jid: int | str | None = None\n        self._status = JobStatus.INIT\n        self._error_retry = error_retry\n        self._num_retries = num_retries\n\n    def __repr__(self) -&gt; str:DOCS\n        \"\"\"repr of the job\"\"\"\n        prefix = f\"{self.__class__.__name__}-{self.index}\"\n        if not self._jid:\n            return f\"&lt;{prefix}: ({self.cmd})&gt;\"\n        return f\"&lt;{prefix}({self._jid}): ({self.cmd})&gt;\"\n\n    @propertyDOCS\n    def stdout_file(self) -&gt; SpecPath:\n        \"\"\"The stdout file of the job\"\"\"\n        return self.metadir / \"job.stdout\"\n\n    @propertyDOCS\n    def stderr_file(self) -&gt; SpecPath:\n        \"\"\"The stderr file of the job\"\"\"\n        return self.metadir / \"job.stderr\"\n\n    @propertyDOCS\n    def status_file(self) -&gt; SpecPath:\n        \"\"\"The status file of the job\"\"\"\n        return self.metadir / \"job.status\"\n\n    @propertyDOCS\n    def rc_file(self) -&gt; SpecPath:\n        \"\"\"The rc file of the job\"\"\"\n        return self.metadir / \"job.rc\"\n\n    @propertyDOCS\n    def jid_file(self) -&gt; SpecPath:\n        \"\"\"The jid file of the job\"\"\"\n        return self.metadir / \"job.jid\"\n\n    @propertyDOCS\n    def retry_dir(self) -&gt; SpecPath:\n        \"\"\"The retry directory of the job\"\"\"\n        return self.metadir / \"job.retry\"\n\n    async def get_jid(self) -&gt; int | str | None:DOCS\n        \"\"\"Get the jid of the job in scheduler system\"\"\"\n        if self._jid is None and not await self.jid_file.a_is_file():\n            return None\n        if self._jid is not None:\n            return self._jid\n        self._jid = await self.jid_file.a_read_text()\n        return self._jid\n\n    async def set_jid(self, uniqid: int | str):\n        self._jid = uniqid\n        await self.jid_file.a_write_text(str(uniqid))\n\n    async def get_status(self, refresh: bool = False) -&gt; int:DOCS\n        \"\"\"Query the status of the job\n\n        If the job is submitted, try to query it from the status file\n        Make sure the status is updated by trap in wrapped script\n\n        Uses caching to avoid excessive file I/O. Cache is invalidated\n        when status is explicitly set.\n\n        Args:\n            refresh: Whether to refresh the status from file\n        \"\"\"\n        if not refresh:\n            return self._status\n\n        if await self.status_file.a_is_file() and self._status in (\n            JobStatus.SUBMITTED,\n            JobStatus.RUNNING,\n            JobStatus.KILLING,\n        ):\n            try:\n                status_text = await self.status_file.a_read_text()\n                self._status = int(status_text)\n            except (\n                FileNotFoundError,\n                ValueError,\n                TypeError,\n            ):  # pragma: no cover\n                pass\n\n        # Don't log here - let scheduler handle transition logging\n        return self._status\n\n    async def set_status(self, stat: int, flush: bool = True) -&gt; None:DOCS\n        \"\"\"Set the status manually\n\n        Args:\n            stat: The status to set\n            flush: Whether to flush the status to file\n        \"\"\"\n        # Only log if status is actually changing\n        prev_status = self._status\n\n        if stat != prev_status:\n            logger.info(\n                \"/Job-%s Status changed: %r -&gt; %r\",\n                self.index,\n                *JobStatus.get_name(prev_status, stat),\n            )\n            self._status = stat\n            if flush:\n                await self.status_file.a_write_text(str(stat))\n\n    async def get_rc(self) -&gt; int:DOCS\n        \"\"\"The return code of the job\"\"\"\n        if not await self.rc_file.a_is_file():\n            return -9\n        return int(await self.rc_file.a_read_text())\n\n    async def set_rc(self, rc: int | str) -&gt; None:DOCS\n        \"\"\"Set the return code of the job\n\n        Args:\n            rc: The return code\n        \"\"\"\n        await self.rc_file.a_write_text(str(rc))\n\n    async def clean(self, retry: bool = False) -&gt; None:DOCS\n        \"\"\"Clean up the meta files\n\n        Args:\n            retry: Whether clean it for retrying\n        \"\"\"\n        files_to_clean = [\n            self.stdout_file,\n            self.stderr_file,\n            self.status_file,\n            self.rc_file,\n        ]\n\n        if retry:\n            retry_dir = self.retry_dir / str(self.trial_count)  # type: ignore\n            if await retry_dir.a_exists():\n                await retry_dir.a_rmtree()\n            await retry_dir.a_mkdir(parents=True)\n\n            for file in files_to_clean:\n                if await file.a_is_file():\n                    await file.a_rename(retry_dir / file.name)\n        else:\n            for file in files_to_clean:\n                if await file.a_is_file():\n                    await file.a_unlink()\n</code></pre>"},{"location":"api/source/xqute/","title":"xqute","text":""},{"location":"api/source/xqute/","title":"SOURCE CODE xqute DOCS","text":"<pre><code>\"\"\"A job management system for python\"\"\"\n\nfrom .defaults import JobStatus, JobErrorStrategy\nfrom .xqute import Xqute\nfrom .plugin import plugin\nfrom .utils import logger\nfrom .job import Job\nfrom .scheduler import Scheduler\n\n__version__ = \"2.0.6\"\n</code></pre>"},{"location":"api/source/xqute.path/","title":"xqute.path","text":""},{"location":"api/source/xqute.path/","title":"SOURCE CODE xqute.path DOCS","text":"<pre><code>\"\"\"Provides the SpecPath and MountedPath classes.\n\nIt is used to represent paths of jobs and it is useful when a job is running in a\nremote system (a VM, a container, etc.), where we need to mount the paths into\nthe remote system (MountedPath).\n\nBut in the system where this framework is running, we need to use the paths\n(specified directly) that are used in the framework, where we also need to carry\nthe information of the mounted path (SpecPath).\n\nThe module provides two main abstract base classes:\n- `MountedPath`: Represents a path as it appears in the remote execution environment.\n- `SpecPath`: Represents a path as it appears in the local environment where the\nframework runs.\n\nBoth classes have implementations for local paths and various cloud storage paths,\nincluding:\n- Google Cloud Storage\n- Azure Blob Storage\n- Amazon S3\n\nThese classes maintain the relationship between the local and remote path\nrepresentations, allowing transparent path operations while preserving both path\ncontexts.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\nimport os\nfrom pathlib import Path\nfrom panpath import PanPath, LocalPath, CloudPath, GSPath, AzurePath, S3Path\n\nfrom .defaults import DEFAULT_CLOUD_FSPATH\n\n__all__ = [\"SpecPath\", \"MountedPath\"]\n\n\nclass MountedPath(PanPath):DOCS\n    \"\"\"A router class to instantiate the correct path based on the path type\n    for the mounted path.\n\n    This abstract base class serves as a factory that creates appropriate mounted path\n    instances based on the input path type. It represents a path as it exists in a\n    remote execution environment (e.g., container, VM) while maintaining a reference to\n    the corresponding path in the local environment.\n\n    Attributes:\n        _spec: The corresponding path in the local environment (SpecPath).\n\n    Examples:\n        &gt;&gt;&gt; # Create a mounted path with corresponding spec path\n        &gt;&gt;&gt; mounted_path = MountedPath(\n        &gt;&gt;&gt;   \"/container/data/file.txt\", spec=\"/local/data/file.txt\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; str(mounted_path)\n        '/container/data/file.txt'\n        &gt;&gt;&gt; str(mounted_path.spec)\n        '/local/data/file.txt'\n\n        &gt;&gt;&gt; # Create a GCS mounted path\n        &gt;&gt;&gt; gs_path = MountedPath(\"gs://bucket/file.txt\", spec=\"/local/file.txt\")\n        &gt;&gt;&gt; type(gs_path)\n        &lt;class 'xqute.path.MountedGSPath'&gt;\n\n        &gt;&gt;&gt; # Serialize and deserialize a mounted path\n        &gt;&gt;&gt; import pickle\n        &gt;&gt;&gt; mounted_path = MountedPath(\"/container/data/file.txt\",\n        ...                            spec=\"/local/data/file.txt\")\n        &gt;&gt;&gt; serialized = pickle.dumps(mounted_path)\n        &gt;&gt;&gt; restored = pickle.loads(serialized)\n        &gt;&gt;&gt; str(restored) == str(mounted_path)\n        True\n        &gt;&gt;&gt; str(restored.spec) == str(mounted_path.spec)\n        True\n    \"\"\"\n\n    def __new__(  # type: ignoreDOCS\n        cls,\n        path: str | Path,\n        spec: str | Path | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; MountedPath:\n        \"\"\"Factory method to create the appropriate MountedPath subclass instance.\n\n        Args:\n            path: The path string or object representing the mounted path location.\n            spec: The path string or object representing the corresponding spec path.\n                If None, the mounted path itself will be used as the spec path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            An instance of the appropriate MountedPath subclass based on the path type:\n            - MountedGSPath for Google Cloud Storage paths\n            - MountedAzurePath for Azure Blob Storage paths\n            - MountedS3Path for Amazon S3 paths\n            - MountedLocalPath for local filesystem paths\n        \"\"\"\n\n        if cls is MountedPath:\n            path = PanPath(path)  # type: ignore\n            if isinstance(path, GSPath):\n                mounted_class = MountedGSPath\n            elif isinstance(path, AzurePath):\n                mounted_class = MountedAzurePath  # type: ignore\n            elif isinstance(path, S3Path):\n                mounted_class = MountedS3Path  # type: ignore\n            else:\n                mounted_class = MountedLocalPath  # type: ignore\n\n            obj = mounted_class(path, *args, **kwargs)\n            obj._spec = PanPath(spec) if spec is not None else obj\n            return obj\n\n        # Ensure the underlying Path initialization receives the path so\n        # internal parts like `_parts` are populated on older Python versions.\n        return super().__new__(cls, path, *args, **kwargs)  # type: ignore\n\n    async def get_fspath(self) -&gt; str:DOCS\n        \"\"\"Get the corresponding local filesystem path and copy from cloud.\n\n        Returns:\n            PanPath: The path as it appears in the local filesystem.\n        \"\"\"\n        return self.__fspath__()\n\n    @propertyDOCS\n    def spec(self) -&gt; SpecPath:\n        \"\"\"Get the corresponding spec path in the local environment.\n\n        Returns:\n            SpecPath: The path as it appears in the local environment.\n        \"\"\"\n        return SpecPath(self._spec, mounted=self)  # type: ignore\n\n    def is_mounted(self) -&gt; bool:DOCS\n        \"\"\"Check if this path is actually mounted (different from spec path).\n\n        Returns:\n            bool: True if the mounted path is different from the spec path, False\n            otherwise.\n        \"\"\"\n        # Direct string comparison instead of using equality operator\n        return str(self._spec) != str(self)\n\n    def __repr__(self):DOCS\n        \"\"\"Generate a string representation of the MountedPath.\n\n        Returns:\n            str: A string showing the class name, path, and spec path (if different).\n        \"\"\"\n        # Check if spec is different by string comparison rather than using is_mounted()\n        if self.is_mounted():\n            return f\"{type(self).__name__}('{self}', spec='{self._spec}')\"\n        else:\n            return f\"{type(self).__name__}('{self}')\"\n\n    def __eq__(self, other: Any) -&gt; bool:DOCS\n        \"\"\"Check equality with another path object.\n\n        Two MountedPath objects are equal if they have the same path string\n        and the same spec path string.\n\n        Args:\n            other: Another object to compare with.\n\n        Returns:\n            bool: True if the paths are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, Path):\n            return False\n\n        if isinstance(other, MountedPath):\n            return str(self) == str(other) and str(self.spec) == str(other.spec)\n\n        return str(self) == str(other)\n\n    def __hash__(self) -&gt; int:DOCS\n        \"\"\"Generate a hash for the MountedPath.\n\n        Returns:\n            int: A hash value based on the path string and spec path string.\n        \"\"\"\n        return hash((str(self), str(self.spec)))\n\n    def __reduce__(self):DOCS\n        \"\"\"Support for pickling and serialization.\n\n        Returns a tuple of (callable, args, state) so that the\n        underlying path is reconstructed from its string, and the\n        spec relationship is restored via state.\n        \"\"\"\n        return (type(self), (str(self),), {\"_spec\": str(self._spec)})\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:DOCS\n        \"\"\"Restore internal state after unpickling.\"\"\"\n        spec_str = state.get(\"_spec\")\n        self._spec = PanPath(spec_str) if spec_str is not None else self\n\n    def with_name(self, name):DOCS\n        \"\"\"Return a new path with the name changed.\n\n        Args:\n            name: The new name for the path.\n\n        Returns:\n            MountedPath: A new mounted path with the name changed in both\n                the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.with_name(self, name)\n        new_spec = PanPath(str(self._spec)).with_name(name)\n\n        return MountedPath(new_path, spec=new_spec)\n\n    def with_suffix(self, suffix):DOCS\n        \"\"\"Return a new path with the suffix changed.\n\n        Args:\n            suffix: The new suffix for the path.\n\n        Returns:\n            MountedPath: A new mounted path with the suffix changed in both\n                the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.with_suffix(self, suffix)\n        new_spec = PanPath(str(self._spec)).with_suffix(suffix)\n\n        return MountedPath(new_path, spec=new_spec)\n\n    def joinpath(self, *pathsegments) -&gt; MountedPath:DOCS\n        \"\"\"Join path components to this path.\n\n        Args:\n            *pathsegments: The path segments to append to this path.\n\n        Returns:\n            MountedPath: A new mounted path with the segments appended to both\n                the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.joinpath(self, *pathsegments)\n        new_spec = PanPath(str(self._spec)).joinpath(*pathsegments)\n\n        return MountedPath(new_path, spec=new_spec)\n\n    def __truediv__(self, key):DOCS\n        \"\"\"Implement the / operator for paths.\n\n        Args:\n            key: The path segment to append to this path.\n\n        Returns:\n            MountedPath: A new mounted path with the segment appended.\n        \"\"\"\n        # it was not implemented with .with_segments()\n        return self.joinpath(key)\n\n    @propertyDOCS\n    def parent(self):\n        \"\"\"Get the parent directory of this path.\n\n        Returns:\n            MountedPath: A new mounted path representing the parent directory\n                of both the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.parent.fget(self)\n        new_spec = PanPath(str(self._spec)).parent\n\n        return MountedPath(new_path, spec=new_spec)\n\n\nclass MountedLocalPath(MountedPath, LocalPath):  # type: ignoreDOCS\n    \"\"\"A class to represent a mounted local path\n\n    This class represents a path in a local filesystem as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Attributes:\n        _spec: The corresponding path in the local environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedLocalPath(\"/container/data/file.txt\",\n        ...                               spec=\"/local/data/file.txt\")\n        &gt;&gt;&gt; str(mounted_path)\n        '/container/data/file.txt'\n        &gt;&gt;&gt; str(mounted_path.spec)\n        '/local/data/file.txt'\n        &gt;&gt;&gt; mounted_path.name\n        'file.txt'\n    \"\"\"\n\n\nclass MountedCloudPath(MountedPath, CloudPath):DOCS\n    \"\"\"A class to represent a mounted cloud path\n\n    This class represents a cloud storage path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Attributes:\n        _spec: The corresponding path in the local environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",\n        ...    spec=\"gs://local-bucket/file.txt\")\n        &gt;&gt;&gt; str(mounted_path)\n        'gs://bucket/file.txt'\n        &gt;&gt;&gt; str(mounted_path.spec)\n        'gs://local-bucket/file.txt'\n    \"\"\"\n\n    def __fspath__(self) -&gt; str:DOCS\n        \"\"\"Return the filesystem path representation.\n\n        Returns:\n            str: The filesystem path as a string.\n        \"\"\"\n        cloud_fspath = os.getenv(\"XQUTE_CLOUD_FSPATH\", DEFAULT_CLOUD_FSPATH)\n        parts = [\n            cloud_fspath,\n            self.parts[0].replace(\":\", \"\"),\n            *self.parts[1:],\n        ]\n        return os.path.join(*parts)\n\n    async def get_fspath(self) -&gt; str:DOCS\n        \"\"\"Get the corresponding local filesystem path and copy from cloud.\n\n        Returns:\n            PanPath: The path as it appears in the local filesystem.\n        \"\"\"\n        p = PanPath(self.__fspath__())\n        await p.parent.a_mkdir(parents=True, exist_ok=True)\n\n        if await self.a_is_dir():\n            await self.a_copytree(p)\n        else:\n            await self.a_copy(p)\n\n        return str(p)\n\n\nclass MountedGSPath(MountedCloudPath, GSPath):DOCS\n    \"\"\"A class to represent a mounted Google Cloud Storage path\n\n    This class represents a Google Cloud Storage path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",\n        ...                          spec=\"gs://local-bucket/file.txt\")\n        &gt;&gt;&gt; isinstance(mounted_path, MountedGSPath)\n        True\n    \"\"\"\n\n\nclass MountedAzurePath(MountedCloudPath, AzurePath):DOCS\n    \"\"\"A class to represent a mounted Azure Blob Storage path\n\n    This class represents an Azure Blob Storage path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"az://container/blob\",\n        ...                          spec=\"az://local-container/blob\")\n        &gt;&gt;&gt; isinstance(mounted_path, MountedAzurePath)\n        True\n    \"\"\"\n\n\nclass MountedS3Path(MountedCloudPath, S3Path):DOCS\n    \"\"\"A class to represent a mounted Amazon S3 path\n\n    This class represents an Amazon S3 path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"s3://bucket/key\",\n        ...                          spec=\"s3://local-bucket/key\")\n        &gt;&gt;&gt; isinstance(mounted_path, MountedS3Path)\n        True\n    \"\"\"\n\n\nclass SpecPath(PanPath):DOCS\n    \"\"\"A router class to instantiate the correct path based on the path type\n    for the spec path.\n\n    This abstract base class serves as a factory that creates appropriate spec path\n    instances based on the input path type. It represents a path in the local\n    environment where the framework runs, while maintaining a reference to the\n    corresponding path in the remote execution environment.\n\n    Attributes:\n        _mounted: The corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; # Create a spec path with corresponding mounted path\n        &gt;&gt;&gt; spec_path = SpecPath(\n        &gt;&gt;&gt;   \"/local/data/file.txt\", mounted=\"/container/data/file.txt\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; str(spec_path)\n        '/local/data/file.txt'\n        &gt;&gt;&gt; str(spec_path.mounted)\n        '/container/data/file.txt'\n\n        &gt;&gt;&gt; # Create a GCS spec path\n        &gt;&gt;&gt; gs_path = SpecPath(\n        &gt;&gt;&gt;   \"gs://bucket/file.txt\", mounted=\"gs://container-bucket/file.txt\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; type(gs_path)\n        &lt;class 'xqute.path.SpecGSPath'&gt;\n    \"\"\"\n\n    def __new__(  # type: ignoreDOCS\n        cls,\n        path: str | Path,\n        *args: Any,\n        mounted: str | Path | None = None,\n        **kwargs: Any,\n    ) -&gt; SpecLocalPath | SpecCloudPath:\n        \"\"\"Factory method to create the appropriate SpecPath subclass instance.\n\n        Args:\n            path: The path string or object representing the spec path.\n            mounted: The path string or object representing the corresponding mounted\n                path. If None, the spec path itself will be used as the mounted path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            An instance of the appropriate SpecPath subclass based on the path type:\n            - SpecGSPath for Google Cloud Storage paths\n            - SpecAzurePath for Azure Blob Storage paths\n            - SpecS3Path for Amazon S3 paths\n            - SpecLocalPath for local filesystem paths\n        \"\"\"\n        if cls is SpecPath:\n            path = PanPath(path)  # type: ignore\n            if isinstance(path, GSPath):\n                spec_class = SpecGSPath\n            elif isinstance(path, AzurePath):\n                spec_class = SpecAzurePath  # type: ignore\n            elif isinstance(path, S3Path):\n                spec_class = SpecS3Path  # type: ignore\n            else:\n                spec_class = SpecLocalPath\n\n            obj = spec_class(path, *args, **kwargs)  # type: ignore\n            obj._mounted = PanPath(mounted) if mounted is not None else obj\n            return obj\n\n        # Ensure Path internals are initialized with the provided path\n        return super().__new__(cls, path, *args, **kwargs)  # type: ignore\n\n    async def get_fspath(self) -&gt; str:DOCS\n        \"\"\"Get the corresponding local filesystem path and copy from cloud.\n\n        Returns:\n            PanPath: The path as it appears in the local filesystem.\n        \"\"\"\n        return self.__fspath__()\n\n    @propertyDOCS\n    def mounted(self) -&gt; MountedPath:\n        \"\"\"Get the corresponding mounted path in the remote environment.\n\n        Returns:\n            MountedPath: The path as it appears in the remote execution environment.\n        \"\"\"\n        # Make sure we handle the case where _mounted might not be set\n        return MountedPath(self._mounted, spec=self)  # type: ignore\n\n    def __repr__(self) -&gt; str:DOCS\n        \"\"\"Generate a string representation of the SpecPath.\n\n        Returns:\n            str: A string showing the class name, path, and mounted path (if different).\n        \"\"\"\n        if self.mounted.is_mounted():\n            return f\"{type(self).__name__}('{self}', mounted='{self._mounted}')\"\n        else:\n            return f\"{type(self).__name__}('{self}')\"\n\n    def __eq__(self, other: Any) -&gt; bool:DOCS\n        \"\"\"Check equality with another path object.\n\n        Two SpecPath objects are equal if they have the same path string\n        and the same mounted path string.\n\n        Args:\n            other: Another object to compare with.\n\n        Returns:\n            bool: True if the paths are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, Path):\n            return False\n\n        if isinstance(other, SpecPath):\n            return str(self) == str(other) and str(self.mounted) == str(other.mounted)\n\n        return str(self) == str(other)\n\n    def __hash__(self) -&gt; int:DOCS\n        \"\"\"Generate a hash for the SpecPath.\n\n        Returns:\n            int: A hash value based on the path string and mounted path string.\n        \"\"\"\n        return hash((str(self), str(self.mounted)))\n\n    def with_name(self, name) -&gt; SpecPath:DOCS\n        \"\"\"Return a new path with the name changed.\n\n        Args:\n            name: The new name for the path.\n\n        Returns:\n            SpecPath: A new spec path with the name changed in both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.with_name(self, name)\n        new_mounted = PanPath(str(self._mounted)).with_name(name)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def with_suffix(self, suffix) -&gt; SpecPath:DOCS\n        \"\"\"Return a new path with the suffix changed.\n\n        Args:\n            suffix: The new suffix for the path.\n\n        Returns:\n            SpecPath: A new spec path with the suffix changed in both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.with_suffix(self, suffix)\n        new_mounted = PanPath(str(self._mounted)).with_suffix(suffix)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def with_stem(self, stem) -&gt; SpecPath:DOCS\n        \"\"\"Return a new path with the stem changed.\n\n        The stem is the filename without the suffix.\n\n        Args:\n            stem: The new stem for the path.\n\n        Returns:\n            SpecPath: A new spec path with the stem changed in both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.with_stem(self, stem)\n        new_mounted = PanPath(str(self._mounted)).with_stem(stem)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def joinpath(self, *pathsegments) -&gt; SpecPath:DOCS\n        \"\"\"Join path components to this path.\n\n        Args:\n            *pathsegments: The path segments to append to this path.\n\n        Returns:\n            SpecPath: A new spec path with the segments appended to both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.joinpath(self, *pathsegments)\n        new_mounted = PanPath(str(self._mounted)).joinpath(*pathsegments)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def __truediv__(self, key):DOCS\n        \"\"\"Implement the / operator for paths.\n\n        Args:\n            key: The path segment to append to this path.\n\n        Returns:\n            SpecPath: A new spec path with the segment appended.\n        \"\"\"\n        # it was not implemented with .with_segments()\n        return self.joinpath(key)\n\n    @propertyDOCS\n    def parent(self) -&gt; SpecPath:\n        \"\"\"Get the parent directory of this path.\n\n        Returns:\n            SpecPath: A new spec path representing the parent directory\n                of both the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.parent.fget(self)\n        new_mounted = PanPath(str(self._mounted)).parent\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n\nclass SpecLocalPath(SpecPath, LocalPath):  # type: ignoreDOCS\n    \"\"\"A class to represent a spec local path\n\n    This class represents a path in the local filesystem as it appears in the\n    framework's environment, while maintaining a reference to its corresponding\n    path in the remote execution environment.\n\n    Attributes:\n        _mounted: The corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecLocalPath(\"/local/data/file.txt\",\n        ...                         mounted=\"/container/data/file.txt\")\n        &gt;&gt;&gt; str(spec_path)\n        '/local/data/file.txt'\n        &gt;&gt;&gt; str(spec_path.mounted)\n        '/container/data/file.txt'\n        &gt;&gt;&gt; spec_path.name\n        'file.txt'\n    \"\"\"\n\n\nclass SpecCloudPath(SpecPath, CloudPath):DOCS\n    \"\"\"A class to represent a spec cloud path\n\n    This class represents a cloud storage path as it appears in the local\n    environment where the framework runs, while maintaining a reference to its\n    corresponding path in the remote execution environment.\n\n    Attributes:\n        _mounted: The corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",\n        ...                    mounted=\"gs://container-bucket/file.txt\")\n        &gt;&gt;&gt; str(spec_path)\n        'gs://bucket/file.txt'\n        &gt;&gt;&gt; str(spec_path.mounted)\n        'gs://container-bucket/file.txt'\n    \"\"\"\n\n    def __fspath__(self) -&gt; str:DOCS\n        \"\"\"Return the filesystem path representation.\n\n        Returns:\n            str: The filesystem path as a string.\n        \"\"\"\n        cloud_fspath = os.getenv(\"XQUTE_CLOUD_FSPATH\", DEFAULT_CLOUD_FSPATH)\n        parts = [\n            cloud_fspath,\n            self.parts[0].replace(\":\", \"\"),\n            *self.parts[1:],\n        ]\n        return os.path.join(*parts)\n\n    async def get_fspath(self) -&gt; str:DOCS\n        \"\"\"Get the corresponding local filesystem path and copy from cloud.\n\n        Returns:\n            PanPath: The path as it appears in the local filesystem.\n        \"\"\"\n        p = PanPath(self.__fspath__())\n        await p.parent.a_mkdir(parents=True, exist_ok=True)\n\n        if await self.a_is_dir():\n            await self.a_copytree(p)\n        else:\n            await self.a_copy(p)\n\n        return str(p)\n\n\nclass SpecGSPath(SpecCloudPath, GSPath):DOCS\n    \"\"\"A class to represent a spec Google Cloud Storage path\n\n    This class represents a Google Cloud Storage path as it appears in the\n    local environment where the framework runs, while maintaining a reference\n    to its corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",\n        ...                    mounted=\"gs://container-bucket/file.txt\")\n        &gt;&gt;&gt; isinstance(spec_path, SpecGSPath)\n        True\n    \"\"\"\n\n\nclass SpecAzurePath(SpecCloudPath, AzurePath):DOCS\n    \"\"\"A class to represent a spec Azure Blob Storage path\n\n    This class represents an Azure Blob Storage path as it appears in the\n    local environment where the framework runs, while maintaining a reference\n    to its corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"az://container/blob\",\n        ...                    mounted=\"az://remote-container/blob\")\n        &gt;&gt;&gt; isinstance(spec_path, SpecAzurePath)\n        True\n    \"\"\"\n\n\nclass SpecS3Path(SpecCloudPath, S3Path):DOCS\n    \"\"\"A class to represent a spec Amazon S3 path\n\n    This class represents an Amazon S3 path as it appears in the\n    local environment where the framework runs, while maintaining a reference\n    to its corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"s3://bucket/key\",\n        ...                    mounted=\"s3://remote-bucket/key\")\n        &gt;&gt;&gt; isinstance(spec_path, SpecS3Path)\n        True\n    \"\"\"\n</code></pre>"},{"location":"api/source/xqute.plugin/","title":"xqute.plugin","text":""},{"location":"api/source/xqute.plugin/","title":"SOURCE CODE xqute.plugin DOCS","text":"<pre><code>\"\"\"Hook specifications for scheduler plugins\"\"\"\n\nfrom __future__ import annotations\n\nimport signal\nfrom typing import TYPE_CHECKING\nfrom simplug import Simplug, SimplugResult  # type: ignore\n\nif TYPE_CHECKING:\n    from .xqute import Xqute\n    from .job import Job\n    from .scheduler import Scheduler\n\n\nplugin = Simplug(\"xqute\")\n\n\n@plugin.specDOCS\ndef on_init(xqute: Xqute):\n    \"\"\"When xqute is initialized\n\n    Note that this hook will run at the same time when producer and consumer\n    start. So they are not ensured to be started at this point.\n\n    Args:\n        xqute: The xqute object\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\ndef on_shutdown(xqute: Xqute, sig: signal.Signals | None):\n    \"\"\"When xqute is shutting down\n\n    Return False to stop shutting down, but you have to shut it down\n    by yourself, for example, `xqute.task.cancel()`\n\n    Only the first return value will be used.\n\n    Args:\n        xqute: The xqute object\n        sig: The signal. `None` means a natural shutdown\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_init(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is initialized\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_queued(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is queued\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\nasync def on_job_submitting(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is to be submitted\n\n    Return False to cancel submitting. Only the first return value is used.\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_submitted(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is submitted\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_started(scheduler: Scheduler, job: Job):\n    \"\"\"When the job starts to run.\n\n    Note that this is not when exactly the job starts to run, but when the\n    scheduler starts to wait for the job to finish. So this hook is not\n    suitable for measuring the time of the job.\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_polling(scheduler: Scheduler, job: Job, counter: int):\n    \"\"\"When the system is polling job status\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n        counter: The polling counter, used to limit the number of polls or\n            skip some polls if the scheduler is busy.\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\nasync def on_job_killing(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is being killed\n\n    Return False to stop killing the job.\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_killed(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is killed\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_failed(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is failed\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_succeeded(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is succeeded\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_init(scheduler: Scheduler, job: Job) -&gt; str:\n    \"\"\"When the job command wrapper script is initialized before the prescript is run\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_prep(scheduler: Scheduler, job: Job) -&gt; str:\n    \"\"\"When the job command right about to be run\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n    The bash variable `$cmd` is accessible in the context. It is also possible to\n    modify the `cmd` variable. Just remember to assign the modified value to `cmd`.\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n    Keep in mind that the `$cmd` may be modified by other plugins.\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_end(scheduler: Scheduler, job: Job) -&gt; str:\n    \"\"\"When the job command finishes and after the postscript is run\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n    The bash variable `$rc` is accessible in the context, which is the return code\n    of the job command.\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\nplugin.load_entrypoints()\n</code></pre>"},{"location":"api/source/xqute.scheduler/","title":"xqute.scheduler","text":""},{"location":"api/source/xqute.scheduler/","title":"SOURCE CODE xqute.scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to schedule jobs\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport shlex\nimport signal\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import Any, List, Type\n\nfrom panpath import CloudPath\nfrom diot import Diot  # type: ignore\n\nfrom .defaults import (\n    JobStatus,\n    JobErrorStrategy,\n    JOBCMD_WRAPPER_LANG,\n    JOBCMD_WRAPPER_TEMPLATE,\n    DEFAULT_ERROR_STRATEGY,\n    DEFAULT_NUM_RETRIES,\n    DEFAULT_SUBMISSION_BATCH,\n    DEFAULT_RECHECK_INTERVAL,\n    get_jobcmd_wrapper_init,\n)\nfrom .utils import logger, CommandType\nfrom .path import SpecPath\nfrom .job import Job\nfrom .plugin import plugin\n\n\nclass Scheduler(ABC):DOCS\n    \"\"\"The abstract class for scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        jobcmd_wrapper_init: The init script for the job command wrapper\n\n    Args:\n        workdir: The working directory\n        forks: Max number of job forks\n        error_strategy: The strategy when there is error happened\n        num_retries: Max number of retries when error_strategy is retry\n        prescript: The prescript to run before the job command\n            It is a piece of script that inserted into the wrapper script, running\n            on the scheduler system.\n        postscript: The postscript to run when job finished\n            It is a piece of script that inserted into the wrapper script, running\n            on the scheduler system.\n        jobname_prefix: The prefix for the job name\n        submission_batch: The number of consumers to submit jobs. This allows\n            multiple jobs to be submitted in parallel. This is useful when\n            there are many jobs to be submitted and the scheduler has a high\n            latency for each submission. Set this to a smaller number if the\n            scheduler cannot handle too many simultaneous submissions.\n        recheck_interval: The number of polling iterations between rechecks of\n            whether a job is still running on the scheduler. Helps detect jobs\n            that fail before the wrapped script updates status (e.g., resource\n            allocation failures). Each iteration takes\n            `xqute.defaults.SLEEP_INTERVAL_POLLING_JOBS`\n        cwd: The working directory for the job command wrapper\n        **kwargs: Other arguments for the scheduler\n    \"\"\"\n\n    __slots__ = (\n        \"config\",\n        \"forks\",\n        \"workdir\",\n        \"error_strategy\",\n        \"num_retries\",\n        \"prescript\",\n        \"postscript\",\n        \"jobname_prefix\",\n        \"recheck_interval\",\n        \"subm_batch\",\n        \"cwd\",\n    )\n\n    # The name of the scheduler\n    name: str\n    # The number of consumers to submit jobs in parallel\n    submission_batch: int = DEFAULT_SUBMISSION_BATCH\n    job_class: Type[Job] = Job\n\n    def __init__(\n        self,\n        workdir: str | Path,\n        forks: int = 1,\n        error_strategy: str = DEFAULT_ERROR_STRATEGY,\n        num_retries: int = DEFAULT_NUM_RETRIES,\n        prescript: str = \"\",\n        postscript: str = \"\",\n        jobname_prefix: str | None = None,\n        submission_batch: int | None = None,\n        recheck_interval: int = DEFAULT_RECHECK_INTERVAL,\n        cwd: str | Path = None,\n        **kwargs,\n    ):\n        self.forks = forks\n        mounted_workdir = kwargs.pop(\"mounted_workdir\", None)\n        self.workdir = SpecPath(workdir, mounted=mounted_workdir)\n\n        self.error_strategy = error_strategy\n        self.num_retries = num_retries\n        self.prescript = prescript\n        self.postscript = postscript\n        self.jobname_prefix = jobname_prefix or self.name\n        self.subm_batch = submission_batch or self.__class__.submission_batch\n        self.recheck_interval = recheck_interval\n        self.cwd = None if cwd is None else str(cwd)\n\n        self.config = Diot(**kwargs)\n\n    async def create_job(DOCS\n        self,\n        index: int,\n        cmd: CommandType,\n        envs: dict[str, Any] | None = None,\n    ) -&gt; Job:\n        \"\"\"Create a job\n\n        Args:\n            index: The index of the job\n            cmd: The command of the job\n\n        Returns:\n            The job\n        \"\"\"\n        job = self.job_class(\n            index=index,\n            cmd=cmd,\n            workdir=self.workdir,\n            error_retry=self.error_strategy == JobErrorStrategy.RETRY,\n            num_retries=self.num_retries,\n            envs=envs,\n        )\n        logger.debug(\"/Job-%s Creating metadir: %s\", job.index, job.metadir)\n        await job.metadir.a_mkdir(parents=True, exist_ok=True)\n        return job\n\n    async def submit_job_and_update_status(self, job: Job):DOCS\n        \"\"\"Submit and update the status\n\n        1. Check if the job is already submitted or running\n        2. If not, run the hook\n        3. If the hook is not cancelled, clean the job\n        4. Submit the job, raising an exception if it fails\n        5. If the job is submitted successfully, update the status\n        6. If the job fails to submit, update the status and write stderr to\n            the job file\n\n        Args:\n            job: The job\n        \"\"\"\n        if await self.job_is_submitted_or_running(job):\n            logger.warning(\n                \"/Job-%s Skip submitting, already submitted or running.\",\n                job.index,\n            )\n            return\n\n        exception: Exception | None = None\n        try:\n            logger.debug(\"/Job-%s Calling on_job_submitting hook ...\", job.index)\n            if await plugin.hooks.on_job_submitting(self, job) is False:\n                logger.info(\"/Job-%s submission cancelled by hook.\", job.index)\n                return\n\n            logger.debug(\"/Job-%s Cleaning up before submission\", job.index)\n            await job.clean()\n\n            try:\n                # raise the exception immediately\n                # it somehow cannot be catched immediately\n                logger.debug(\n                    \"/Job-%s Submitting to scheduler '%s' ...\",\n                    job.index,\n                    self.name,\n                )\n                await job.set_jid(await self.submit_job(job))\n            except Exception as exc:\n                exception = RuntimeError(f\"Failed to submit job: {exc}\")\n                exception.__traceback__ = exc.__traceback__\n            else:\n                await self.transition_job_status(job, JobStatus.SUBMITTED)\n\n        except Exception as exc:  # pragma: no cover\n            exception = exc\n\n        if exception is not None:\n            from traceback import format_exception\n\n            error_msg = \"\".join(\n                format_exception(\n                    type(exception),\n                    exception,\n                    exception.__traceback__,\n                )\n            )\n            await job.stderr_file.a_write_text(error_msg)\n            await self.transition_job_status(job, JobStatus.FAILED, rc=\"-2\")\n\n    async def transition_job_status(DOCS\n        self,\n        job: Job,\n        new_status: int,\n        old_status: int | None = None,\n        flush: bool = True,\n        rc: str | None = None,\n        error_msg: str | None = None,\n        is_killed: bool = False,\n    ):\n        \"\"\"Centralized status transition handler\n\n        Handles all aspects of job status transitions:\n        - Status change logging\n        - Hook lifecycle management (ensuring on_job_started is called)\n        - Appropriate hook calls based on new status\n        - RC file updates\n        - Error message appending to stderr\n        - JID file cleanup for terminal states\n        - Pipeline halt on errors if configured\n\n        Note that this method will not flush status changes to disk (job.status_file).\n        You need to call job.set_status() separately if needed.\n\n        Args:\n            job: The job to transition\n            new_status: The new status to transition to\n            old_status: The previous status (if known).\n                If None, will use job._status\n            flush: Whether to flush the status to disk\n            rc: Optional return code to write to rc_file\n            error_msg: Optional error message to append to stderr_file\n            is_killed: Whether this is a killed job (uses on_job_killed hook)\n        \"\"\"\n        # Save the previous status before updating\n        # (setter will update prev_status, so we need to save it first)\n        old_status = job._status if old_status is None else old_status\n        await job.set_status(new_status, flush=flush)\n\n        # Handle killed jobs specially\n        if is_killed:\n            logger.debug(\"/Job-%s Calling on_job_killed hook ...\", job.index)\n            await plugin.hooks.on_job_killed(self, job)\n            return\n\n        # Handle status-specific logic\n        if new_status == JobStatus.FAILED:\n            # Ensure lifecycle hook was called\n            # Job may go from SUBMITTED to FAILED directly (finished too soon)\n            if old_status != JobStatus.RUNNING:\n                await self.transition_job_status(\n                    job,\n                    JobStatus.RUNNING,\n                    old_status=old_status,\n                    flush=False,\n                )\n                await self.transition_job_status(\n                    job,\n                    new_status,\n                    old_status=JobStatus.RUNNING,\n                    flush=False,\n                )\n                return\n\n            # Write rc file if provided\n            if rc is not None:  # pragma: no cover\n                await job.set_rc(rc)\n\n            # Append error message if provided\n            if error_msg is not None:  # pragma: no cover\n                async with job.stderr_file.a_open(\"a\") as f:\n                    f.write(f\"\\n{error_msg}\\n\")\n\n            # Call failure hook\n            logger.debug(\"/Job-%s Calling on_job_failed hook ...\", job.index)\n            await plugin.hooks.on_job_failed(self, job)\n\n            # Clean up jid file\n            await job.jid_file.a_unlink(missing_ok=True)\n\n            # Handle halt strategy\n            if self.error_strategy == JobErrorStrategy.HALT:\n                logger.error(\n                    \"/Sched-%s Pipeline will halt since job failed: %r\",\n                    self.name,\n                    job,\n                )\n                os.kill(os.getpid(), signal.SIGTERM)\n\n        elif new_status == JobStatus.FINISHED:\n            # Ensure lifecycle hook was called\n            if old_status != JobStatus.RUNNING:  # pragma: no cover\n                await self.transition_job_status(\n                    job,\n                    JobStatus.RUNNING,\n                    old_status=old_status,\n                    flush=False,\n                )\n                await self.transition_job_status(\n                    job,\n                    new_status,\n                    old_status=JobStatus.RUNNING,\n                    flush=False,\n                )\n                return\n\n            # Call success hook\n            logger.debug(\"/Job-%s Calling on_job_succeeded hook ...\", job.index)\n            await plugin.hooks.on_job_succeeded(self, job)\n\n            # Clean up jid file\n            await job.jid_file.a_unlink(missing_ok=True)\n\n        elif new_status == JobStatus.RUNNING:\n            # Call started hook\n            logger.debug(\"/Job-%s Calling on_job_started hook ...\", job.index)\n            await plugin.hooks.on_job_started(self, job)\n\n        elif new_status == JobStatus.SUBMITTED:\n            # Call submitted hook\n            logger.info(\n                \"/Sched-%s Job %s submitted (jid: %s, wrapped: %s)\",\n                self.name,\n                job.index,\n                await job.get_jid(),\n                await self.wrapped_job_script(job),\n            )\n            logger.debug(\"/Job-%s Calling on_job_submitted hook ...\", job.index)\n            await plugin.hooks.on_job_submitted(self, job)\n\n    async def kill_job_and_update_status(self, job: Job):DOCS\n        \"\"\"Kill a job and update its status\n\n        Args:\n            job: The job\n        \"\"\"\n        await job.set_status(JobStatus.KILLING)\n        logger.debug(\"/Job-%s Calling on_job_killing hook ...\", job.index)\n        ret = await plugin.hooks.on_job_killing(self, job)\n        if ret is False:\n            logger.info(\n                \"/Sched-%s Job %s killing cancelled by hook.\",\n                self.name,\n                job.index,\n            )\n            return\n\n        logger.warning(\"/Sched-%s Killing job %s ...\", self.name, job.index)\n        await self.kill_job(job)\n\n        await self.transition_job_status(job, JobStatus.FINISHED, is_killed=True)\n\n    async def retry_job(self, job: Job):DOCS\n        \"\"\"Retry a job\n\n        Args:\n            job: The job\n        \"\"\"\n        await job.set_jid(\"\")\n        await job.clean(retry=True)\n        job.trial_count += 1\n        logger.warning(\n            \"/Sched-%s Retrying (#%s) job: %r\",\n            self.name,\n            job.trial_count,\n            job,\n        )\n        await self.transition_job_status(job, JobStatus.QUEUED, flush=False)\n        await plugin.hooks.on_job_queued(self, job)\n        await self.submit_job_and_update_status(job)\n\n    async def count_running_jobs(self, jobs: List[Job]) -&gt; int:DOCS\n        \"\"\"Count currently running/active jobs (lightweight check)\n\n        This is optimized for the producer to check if new jobs can be submitted.\n        It only counts jobs without refreshing status or calling hooks.\n\n        Args:\n            jobs: The list of jobs\n\n        Returns:\n            Number of jobs currently in active states\n        \"\"\"\n        # check_job_done() has updated _status already\n        # statuses = await asyncio.gather(*(job.get_status() for job in jobs))\n        return sum(\n            1\n            for job in jobs\n            if job._status\n            in (\n                JobStatus.QUEUED,\n                JobStatus.SUBMITTED,\n                JobStatus.RUNNING,\n                JobStatus.KILLING,\n            )\n        )\n\n    async def _check_job_done(self, job: Job, polling_counter: int) -&gt; bool | str:\n        \"\"\"Check if a single job is done (lightweight check)\n\n        This is optimized for the producer to check if new jobs can be submitted.\n        It only checks the status without refreshing or calling hooks.\n\n        Args:\n            job: The job\n            polling_counter: The polling counter for hook calls\n\n        Returns:\n            True if the job is done, False if not.\n            If the job failed, return the \"failed\".\n        \"\"\"\n        prev_status = job._status\n        status = await job.get_status(refresh=True)\n        # Keep the previous status, which will be updated later\n        # So that later parts can know the previous status\n        job._status = prev_status\n\n        # Status changed\n        if status != prev_status:\n            await self.transition_job_status(\n                job,\n                status,\n                old_status=prev_status,\n                flush=False,\n            )\n\n        elif status == JobStatus.SUBMITTED:\n            # Status keep being SUBMITTED\n            # Check if the job fails before running\n            if await self.job_fails_before_running(job):  # pragma: no cover\n                logger.warning(\n                    \"/Sched-%s Job %s seems to fail before running, \"\n                    \"check your scheduler logs if necessary.\",\n                    self.name,\n                    job.index,\n                )\n                await self.transition_job_status(\n                    job,\n                    JobStatus.FAILED,\n                    old_status=prev_status,\n                    flush=False,\n                    rc=\"-3\",\n                    error_msg=(\n                        \"Error: job seems to fail before running.\\n\"\n                        \"Check your scheduler logs if necessary.\"\n                    ),\n                )\n                # transition_job_status handles the HALT, but we still need to break\n                if self.error_strategy == JobErrorStrategy.HALT:\n                    return \"failed\"\n\n        elif status == JobStatus.RUNNING:\n            # Status keep being RUNNING\n            logger.debug(\n                \"/Sched-%s Job %s is running, calling polling hook ...\",\n                self.name,\n                job.index,\n            )\n            # Call the polling hook\n            logger.debug(\"/Job-%s Calling on_job_polling hook ...\", job.index)\n            await plugin.hooks.on_job_polling(self, job, polling_counter)\n            # Let's make sure the job is really running\n            if (\n                not await job.rc_file.a_is_file()\n                and (polling_counter + 1) % self.recheck_interval == 0\n                and not await self.job_is_running(job)\n            ):  # pragma: no cover\n                logger.warning(\n                    \"/Sched-%s Job %s is not running in the scheduler, \"\n                    \"but its status is still RUNNING, setting it to FAILED\",\n                    self.name,\n                    job.index,\n                )\n                await self.transition_job_status(\n                    job,\n                    JobStatus.FAILED,\n                    old_status=prev_status,\n                    flush=False,\n                    rc=\"-3\",\n                    error_msg=(\n                        \"Error: job is not running in the scheduler, \"\n                        \"but its status is still RUNNING.\\n\"\n                        \"It is likely that the resource is preempted.\"\n                    ),\n                )\n                # transition_job_status handles the HALT, but we still need to break\n                if self.error_strategy == JobErrorStrategy.HALT:\n                    return \"failed\"\n\n        # Check if we need to halt - this catches any FAILED status\n        # transition_job_status already sent SIGTERM, we just need to break the loop\n        if self.error_strategy == JobErrorStrategy.HALT and status == JobStatus.FAILED:\n            return \"failed\"\n\n        if status not in (JobStatus.FINISHED, JobStatus.FAILED):\n            logger.debug(\n                \"/Sched-%s Not all jobs are done yet, job %s is %s\",\n                self.name,\n                job.index,\n                JobStatus.get_name(status),\n            )\n            return False\n\n        # Try to resubmit the job for retrying\n        if (\n            status == JobStatus.FAILED\n            and job._error_retry\n            and job.trial_count &lt; job._num_retries\n        ):\n            logger.debug(\n                \"/Sched-%s Job %s is retrying ...\",\n                self.name,\n                job.index,\n            )\n            await self.retry_job(job)\n            return False\n\n        return True\n\n    async def check_all_done(DOCS\n        self,\n        jobs: List[Job],\n        polling_counter: int,\n    ) -&gt; bool:\n        \"\"\"Check if all jobs are done (full polling with hooks)\n\n        This does complete status refresh and calls all lifecycle hooks.\n        Used by the main polling loop to track job completion.\n\n        Args:\n            jobs: The list of jobs\n            polling_counter: The polling counter for hook calls\n\n        Returns:\n            True if all jobs are done, False otherwise\n        \"\"\"\n        ret = True\n        logger.debug(\n            \"/Sched-%s Checking if all jobs are done (#%s) ...\",\n            self.name,\n            polling_counter,\n        )\n\n        for job in jobs:\n            # We don't use gather here, since we may break the loop early\n            job_done = await self._check_job_done(job, polling_counter)\n            if job_done == \"failed\":\n                ret = False\n                break\n\n            if not job_done:\n                ret = False\n\n        return ret\n\n    async def kill_running_jobs(self, jobs: List[Job]):DOCS\n        \"\"\"Try to kill all running jobs\n\n        Args:\n            jobs: The list of jobs\n        \"\"\"\n        logger.warning(\"/Sched-%s Killing running jobs ...\", self.name)\n        for job in jobs:\n            status = await job.get_status()\n            if status in (JobStatus.SUBMITTED, JobStatus.RUNNING):\n                await self.kill_job_and_update_status(job)\n\n    async def job_is_submitted_or_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Check if a job is already submitted or running\n\n        Args:\n            job: The job\n\n        Returns:\n            True if yes otherwise False.\n        \"\"\"\n        if await job.jid_file.a_is_file():\n            if await self.job_is_running(job):\n                await job.set_status(JobStatus.SUBMITTED)\n                return True\n        return False\n\n    async def job_fails_before_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Check if a job fails before running.\n\n        For some schedulers, the job might fail before running (after submission).\n        For example, the job might fail to allocate resources. In such a case,\n        the wrapped script might not be executed, and the job status will not be\n        updated (stays in SUBMITTED). We need to check such jobs and mark them as\n        FAILED.\n\n        For the instant scheduler, for example, the local scheduler, the failure will\n        be immediately reported when submitting the job, so we don't need to check\n        such jobs.\n\n        Args:\n            job: The job to check\n\n        Returns:\n            True if the job fails before running, otherwise False.\n        \"\"\"\n        return False\n\n    @propertyDOCS\n    def jobcmd_wrapper_init(self) -&gt; str:\n        \"\"\"The init script for the job command wrapper\"\"\"\n        wrapper_init = get_jobcmd_wrapper_init(\n            not isinstance(self.workdir.mounted, CloudPath)\n        )\n        if self.cwd:\n            # Some schedulers (e.g. Google Cloud Batch) doesn't support changing the\n            # working directory via configuration, so we need to change it in the\n            # wrapper script.\n            # See: https://issuetracker.google.com/issues/336164416\n            wrapper_init = f\"cd {shlex.quote(self.cwd)}\\n\\n{wrapper_init}\"\n\n        return wrapper_init\n\n    def jobcmd_shebang(self, job: Job) -&gt; str:DOCS\n        \"\"\"The shebang of the wrapper script\"\"\"\n        wrapper_lang = (\n            JOBCMD_WRAPPER_LANG\n            if isinstance(JOBCMD_WRAPPER_LANG, (tuple, list))\n            else [JOBCMD_WRAPPER_LANG]\n        )\n        return shlex.join(wrapper_lang)\n\n    def jobcmd_init(self, job) -&gt; str:DOCS\n        \"\"\"The job command init\"\"\"\n        init_code = []\n        if job.envs:\n            init_code.append(\"# Environment variables\")\n            init_code.extend(\n                [\n                    f\"export {key}={shlex.quote(str(value))}\"\n                    for key, value in job.envs.items()\n                ]\n            )\n\n        codes = plugin.hooks.on_jobcmd_init(self, job)\n        init_code.extend([code for code in codes if code])\n        return \"\\n\".join(init_code)\n\n    def jobcmd_prep(self, job) -&gt; str:DOCS\n        \"\"\"The job command preparation\"\"\"\n        codes = plugin.hooks.on_jobcmd_prep(self, job)\n        codes = [code for code in codes if code]\n        return \"\\n\".join(codes)\n\n    def jobcmd_end(self, job) -&gt; str:DOCS\n        \"\"\"The job command end\"\"\"\n        codes = plugin.hooks.on_jobcmd_end(self, job)\n        codes = [code for code in codes if code]\n        return \"\\n\".join(codes)\n\n    def wrap_job_script(self, job: Job) -&gt; str:DOCS\n        \"\"\"Wrap the job script\n\n        Args:\n            job: The job\n\n        Returns:\n            The wrapped script\n        \"\"\"\n        return JOBCMD_WRAPPER_TEMPLATE.format(\n            scheduler=self,\n            shebang=self.jobcmd_shebang(job),\n            status=JobStatus,\n            job=job,\n            cmd=shlex.join(job.cmd),\n            jobcmd_init=self.jobcmd_init(job),\n            jobcmd_prep=self.jobcmd_prep(job),\n            jobcmd_end=self.jobcmd_end(job),\n        )\n\n    async def wrapped_job_script(self, job: Job) -&gt; SpecPath:DOCS\n        \"\"\"Get the wrapped job script\n\n        Args:\n            job: The job\n\n        Returns:\n            The path of the wrapped job script\n        \"\"\"\n        base = f\"job.wrapped.{self.name}\"\n        wrapt_script = job.metadir / base\n        await wrapt_script.a_write_text(self.wrap_job_script(job))\n\n        return wrapt_script\n\n    @abstractmethodDOCS\n    async def submit_job(self, job: Job) -&gt; int | str:\n        \"\"\"Submit a job\n\n        Args:\n            job: The job\n\n        Returns:\n            The unique id in the scheduler system\n        \"\"\"\n\n    @abstractmethodDOCS\n    async def kill_job(self, job: Job):\n        \"\"\"Kill a job\n\n        Args:\n            job: The job\n        \"\"\"\n\n    @abstractmethodDOCS\n    async def job_is_running(self, job: Job) -&gt; bool:\n        \"\"\"Check if a job is really running\n\n        Args:\n            job: The job\n\n        Returns:\n            True if yes otherwise False.\n        \"\"\"\n</code></pre>"},{"location":"api/source/xqute.schedulers.container_scheduler/","title":"xqute.schedulers.container_scheduler","text":""},{"location":"api/source/xqute.schedulers.container_scheduler/","title":"SOURCE CODE xqute.schedulers.container_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs via containers\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport os\nimport shlex\nimport shutil\nfrom pathlib import Path\nfrom typing import List, Sequence\n\nfrom ..job import Job\nfrom ..path import SpecPath\nfrom ..defaults import JOBCMD_WRAPPER_LANG\nfrom .local_scheduler import LocalScheduler\nfrom .gbatch_scheduler import NAMED_MOUNT_RE, DEFAULT_MOUNTED_ROOT\n\nCONTAINER_TYPES = {\n    \"docker\": \"docker\",\n    \"podman\": \"podman\",\n    \"apptainer\": \"apptainer\",\n    \"singularity\": \"apptainer\",\n}\n\n\nclass ContainerScheduler(LocalScheduler):DOCS\n    \"\"\"Scheduler to run jobs via containers (Docker/Podman/Apptainer)\n\n    This scheduler can execute jobs inside containers using Docker, Podman,\n    or Apptainer.\n\n    Args:\n        image: Container image to use for running jobs\n        entrypoint: Entrypoint command for the container\n        bin: Path to container runtime binary (e.g. /path/to/docker)\n        volumes: host:container volume mapping string or strings\n            or named volume mapping like `MOUNTED=/path/on/host`\n            then it will be mounted to `/mnt/disks/MOUNTED` in the container.\n            You can use environment variable `MOUNTED` in your job scripts to\n            refer to the mounted path.\n        user: User to run the container as (only for Docker/Podman)\n            By default, it runs as the current user (os.getuid() and os.getgid())\n        remove: Whether to remove the container after execution.\n            Only applies to Docker/Podman.\n        bin_args: Additional arguments to pass to the container runtime\n        **kwargs: Additional arguments passed to parent Scheduler\n    \"\"\"\n\n    name = \"container\"\n\n    __slots__ = (\n        \"image\",\n        \"entrypoint\",\n        \"bin\",\n        \"volumes\",\n        # \"envs\",\n        \"remove\",\n        \"user\",\n        \"bin_args\",\n        \"_container_type\",\n        \"_path_envs\",\n    )\n\n    def __init__(\n        self,\n        image: str,\n        entrypoint: str | List[str] = JOBCMD_WRAPPER_LANG,\n        bin: str = \"docker\",\n        volumes: str | Sequence[str] | None = None,\n        # envs: Dict[str, str] | None = None,\n        remove: bool = True,\n        user: str | None = None,\n        bin_args: List[str] | None = None,\n        **kwargs,\n    ):\n        if \"mount\" in kwargs:\n            raise ValueError(\n                \"You used 'mount' argument for container scheduler, \"\n                \"did you mean 'volumes'?\"\n            )\n\n        kwargs.setdefault(\"mounted_workdir\", f\"{DEFAULT_MOUNTED_ROOT}/xqute_workdir\")\n        super().__init__(**kwargs)\n\n        self.bin = shutil.which(bin)\n        if not self.bin:\n            raise ValueError(f\"Container runtime binary '{bin}' not found in PATH\")\n\n        self.image = image\n        self.entrypoint = (\n            list(entrypoint) if isinstance(entrypoint, (list, tuple)) else [entrypoint]\n        )\n        self._path_envs = {}\n        self.volumes = volumes or []\n        self.volumes = (\n            [self.volumes] if isinstance(self.volumes, str) else list(self.volumes)\n        )\n        for i, vol in enumerate(self.volumes):\n            if NAMED_MOUNT_RE.match(vol):\n                name, host_path = vol.split(\"=\", 1)\n                host_path_obj = Path(host_path).expanduser().resolve()\n                if not host_path_obj.exists():\n                    raise FileNotFoundError(\n                        f\"Volume host path '{host_path}' does not exist\"\n                    )\n                if host_path_obj.is_file():\n                    host_path = str(host_path_obj.parent)\n                    mount_path = (\n                        f\"{DEFAULT_MOUNTED_ROOT}/{name}/{host_path_obj.parent.name}\"\n                    )\n                    self._path_envs[name] = f\"{mount_path}/{host_path_obj.name}\"\n                    self.volumes[i] = f\"{host_path}:{mount_path}\"\n                else:\n                    host_path = str(host_path_obj)\n                    mount_path = f\"{DEFAULT_MOUNTED_ROOT}/{name}\"\n                    self._path_envs[name] = mount_path\n                    self.volumes[i] = f\"{host_path}:{mount_path}\"\n\n        # self.envs = envs or {}\n        self.remove = remove\n        self.user = user or f\"{os.getuid()}:{os.getgid()}\"\n        self.bin_args = bin_args or []\n        self.volumes.append(f\"{self.workdir}:{self.workdir.mounted}\")\n\n        self._container_type = CONTAINER_TYPES.get(\n            Path(self.bin).name.lower(),\n            \"docker\",\n        )\n        if self._container_type in (\"docker\", \"podman\") and self.image.startswith(\n            \"docker://\"\n        ):\n            # Convert docker://image to image name\n            self.image = self.image[9:]\n\n    async def wrapped_job_script(self, job: Job) -&gt; SpecPath:DOCS\n        \"\"\"Get the wrapped job script\n\n        Args:\n            job: The job\n\n        Returns:\n            The path of the wrapped job script\n        \"\"\"\n        base = f\"job.wrapped.{self.name}-{self._container_type}\"\n        wrapt_script = job.metadir / base\n        await wrapt_script.a_write_text(self.wrap_job_script(job))\n\n        return wrapt_script\n\n    def jobcmd_shebang(self, job: Job) -&gt; str:DOCS\n        \"\"\"The shebang of the wrapper script\"\"\"\n        cmd = [self.bin, \"run\"]\n        if self._container_type == \"apptainer\":\n            if self.cwd:  # pragma: no cover\n                cmd.extend([\"--pwd\", self.cwd])\n            else:\n                cmd.extend([\"--pwd\", str(self.workdir.mounted)])\n            for key, value in job.envs.items():\n                cmd.extend([\"--env\", f\"{key}={value}\"])\n            for vol in self.volumes:\n                cmd.extend([\"--bind\", f\"{vol}\"])\n        else:\n            if self.remove:\n                cmd.append(\"--rm\")\n            cmd.extend([\"--user\", self.user])\n            for key, value in job.envs.items():\n                cmd.extend([\"-e\", f\"{key}={value}\"])\n            for vol in self.volumes:\n                cmd.extend([\"-v\", vol])\n\n            if self.cwd:\n                cmd.extend([\"--workdir\", self.cwd])\n            else:\n                cmd.extend([\"--workdir\", str(self.workdir.mounted)])\n\n        cmd.extend(self.bin_args)\n        cmd.append(self.image)\n        cmd.extend(self.entrypoint)\n\n        return shlex.join(cmd)\n\n    async def submit_job(self, job: Job) -&gt; int:  # type: ignore[override]DOCS\n        \"\"\"Submit a job locally\n\n        Args:\n            job: The job\n\n        Returns:\n            The process id\n        \"\"\"\n        wrapt_script_path = (await self.wrapped_job_script(job)).mounted\n        # In case the process exits very quickly\n        if not await job.jid_file.a_exists():\n            await job.jid_file.a_write_text(\"0\")\n\n        proc = await asyncio.create_subprocess_exec(\n            *shlex.split(self.jobcmd_shebang(job)),\n            wrapt_script_path,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.STDOUT,\n            start_new_session=True,\n            # Changing the working directory here may cause wrapped_job_script to fail\n            # to be found, so we don't set cwd here.\n            # The cwd is changed in the wrapper script instead.\n            # cwd=self.cwd\n        )\n\n        # wait for a while to make sure the process is running\n        # this is to avoid the real command is not run when proc is recycled too early\n        # this happens for python &lt; 3.12\n        await asyncio.sleep(0.1)\n\n        if await job.stdout_file.a_exists():  # pragma: no cover\n            # job submitted successfully and already started very soon\n            return proc.pid\n\n        if proc.returncode is not None and proc.returncode != 0:\n            # The process has already finished and no stdout/stderr files are\n            # generated\n            # Something went wrong with the wrapper script?\n            stderr = await proc.stdout.read()\n            raise RuntimeError(\n                f\"Failed to submit job #{job.index} (rc={proc.returncode}): \"\n                f\"{stderr.decode()}\\n\"\n                f\"Command: {self.jobcmd_shebang(job)} \"\n                f\"{wrapt_script_path}\\n\"\n            )\n\n        # don't await for the results, as this will run the real command\n        return proc.pid\n\n    def jobcmd_init(self, job) -&gt; str:DOCS\n        init_cmd = super().jobcmd_init(job)\n        path_envs_exports = [\n            f\"export {key}={shlex.quote(value)}\"\n            for key, value in self._path_envs.items()\n        ]\n        if path_envs_exports:\n            path_envs_exports.insert(0, \"# Mounted paths\")\n            init_cmd = \"\\n\".join(path_envs_exports) + \"\\n\" + init_cmd\n\n        return init_cmd\n</code></pre>"},{"location":"api/source/xqute.schedulers.gbatch_scheduler/","title":"xqute.schedulers.gbatch_scheduler","text":""},{"location":"api/source/xqute.schedulers.gbatch_scheduler/","title":"SOURCE CODE xqute.schedulers.gbatch_scheduler DOCS","text":"<pre><code>from __future__ import annotations\n\nimport asyncio\nimport json\nimport re\nimport shlex\nimport getpass\nfrom typing import Sequence\nfrom copy import deepcopy\nfrom hashlib import sha256\nfrom panpath import GSPath, PanPath\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\nfrom ..defaults import (\n    JOBCMD_WRAPPER_LANG,\n    # get_jobcmd_wrapper_init,\n    # JOBCMD_WRAPPER_TEMPLATE,\n    # JobStatus,\n    SLEEP_INTERVAL_GBATCH_STATUS_CHECK,\n)\nfrom ..utils import logger\nfrom ..path import SpecPath\n\n\nJOBNAME_PREFIX_RE = re.compile(r\"^[a-zA-Z][a-zA-Z0-9-]{0,47}$\")\nNAMED_MOUNT_RE = re.compile(r\"^[A-Za-z][A-Za-z0-9_]*=.+$\")\nDEFAULT_MOUNTED_ROOT = \"/mnt/disks\"\n\n\nclass GbatchScheduler(Scheduler):DOCS\n    \"\"\"Scheduler for Google Cloud Batch\n\n    You can pass extra configuration parameters to the constructor\n    that will be used in the job configuration file.\n    For example, you can pass `taskGroups` to specify the task groups\n    and their specifications.\n\n    For using containers, it is a little bit tricky to specify the commands.\n    When no `entrypoint` is specified, the `commands` should be a list\n    with the first element being the interpreter (e.g. `/bin/bash`)\n    and the second element being the path to the wrapped job script.\n    If the `entrypoint` is specified, we can use the `{lang}` and `{script}`\n    placeholders in the `commands` list, where `{lang}` will be replaced\n    with the interpreter (e.g. `/bin/bash`) and `{script}` will be replaced\n    with the path to the wrapped job script.\n    With `entrypoint` specified and no `{script}` placeholder, the joined command\n    will be the interpreter followed by the path to the wrapped job script will be\n    appended to the `commands` list.\n\n    Args:\n        project: GCP project ID\n        location: GCP location (e.g. us-central1)\n        mount: GCS path to mount (e.g. gs://my-bucket:/mnt/my-bucket)\n            You can pass a list of mounts.\n            You can also use named mount like `NAME=gs://bucket/dir`\n            then it will be mounted to `/mnt/disks/NAME` in the container.\n            You can use environment variable `NAME` in your job scripts to\n            refer to the mounted path.\n        service_account: GCP service account email (e.g. test-account@example.com)\n        network: GCP network (e.g. default-network)\n        subnetwork: GCP subnetwork (e.g. regions/us-central1/subnetworks/default)\n        no_external_ip_address: Whether to disable external IP address\n        machine_type: GCP machine type (e.g. e2-standard-4)\n        provisioning_model: GCP provisioning model (e.g. SPOT)\n        image_uri: Container image URI (e.g. ubuntu-2004-lts)\n        entrypoint: Container entrypoint (e.g. /bin/bash)\n        commands: The command list to run in the container.\n            There are three ways to specify the commands:\n            1. If no entrypoint is specified, the final command will be\n            [commands, wrapped_script], where the entrypoint is the wrapper script\n            interpreter that is determined by `JOBCMD_WRAPPER_LANG` (e.g. /bin/bash),\n            commands is the list you provided, and wrapped_script is the path to the\n            wrapped job script.\n            2. You can specify something like \"-c\", then the final command\n            will be [\"-c\", \"wrapper_script_interpreter, wrapper_script\"]\n            3. You can use the placeholders `{lang}` and `{script}` in the commands\n            list, where `{lang}` will be replaced with the interpreter (e.g. /bin/bash)\n            and `{script}` will be replaced with the path to the wrapped job script.\n            For example, you can specify [\"{lang} {script}\"] and the final command\n            will be [\"wrapper_interpreter, wrapper_script\"]\n        runnables: Additional runnables to run before or after the main job.\n            Each runnable should be a dictionary that follows the\n            [GCP Batch API specification](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#runnable).\n            You can also specify an \"order\" key in the dictionary to control the\n            execution order of the runnables. Runnables with negative order\n            will be executed before the main job, and those with non-negative\n            order will be executed after the main job. The main job runnable\n            will always be executed in the order it is defined in the list.\n        *args, **kwargs: Other arguments passed to base Scheduler class\n    \"\"\"  # noqa: E501\n\n    name = \"gbatch\"\n\n    __slots__ = Scheduler.__slots__ + (\n        \"gcloud\",\n        \"project\",\n        \"location\",\n        \"runnable_index\",\n        \"_path_envs\",\n    )\n\n    def __init__(\n        self,\n        *args,\n        project: str,\n        location: str,\n        mount: str | Sequence[str] | None = None,\n        service_account: str | None = None,\n        network: str | None = None,\n        subnetwork: str | None = None,\n        no_external_ip_address: bool | None = None,\n        machine_type: str | None = None,\n        provisioning_model: str | None = None,\n        image_uri: str | None = None,\n        entrypoint: str = None,\n        commands: str | Sequence[str] | None = None,\n        runnables: Sequence[dict] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Construct the gbatch scheduler\"\"\"\n        self.gcloud = kwargs.pop(\"gcloud\", \"gcloud\")\n        self.project = project\n        self.location = location\n        kwargs.setdefault(\"mounted_workdir\", f\"{DEFAULT_MOUNTED_ROOT}/xqute_workdir\")\n        super().__init__(*args, **kwargs)\n\n        if not isinstance(self.workdir, GSPath):\n            raise ValueError(\n                \"'gbatch' scheduler requires google cloud storage 'workdir'.\"\n            )\n\n        if not JOBNAME_PREFIX_RE.match(self.jobname_prefix):\n            raise ValueError(\n                \"'jobname_prefix' for gbatch scheduler doesn't follow pattern \"\n                f\"'^[a-zA-Z][a-zA-Z0-9-]{{0,47}}$', got '{self.jobname_prefix}'.\"\n            )\n\n        self._path_envs = {}\n        task_groups = self.config.setdefault(\"taskGroups\", [])\n        if not task_groups:\n            task_groups.append({})\n        if not task_groups[0]:\n            task_groups[0] = {}\n\n        task_spec = task_groups[0].setdefault(\"taskSpec\", {})\n        task_runnables = task_spec.setdefault(\"runnables\", [])\n\n        # Process additional runnables with ordering\n        additional_runnables = []\n        if runnables:\n            for runnable_dict in runnables:\n                runnable_copy = deepcopy(runnable_dict)\n                order = runnable_copy.pop(\"order\", 0)\n                additional_runnables.append((order, runnable_copy))\n\n        # Sort by order\n        additional_runnables.sort(key=lambda x: x[0])\n\n        # Create main job runnable\n        if not task_runnables:\n            task_runnables.append({})\n        if not task_runnables[0]:\n            task_runnables[0] = {}\n\n        job_runnable = task_runnables[0]\n        if \"container\" in job_runnable or image_uri:\n            job_runnable.setdefault(\"container\", {})\n            if not isinstance(job_runnable[\"container\"], dict):  # pragma: no cover\n                raise ValueError(\n                    \"'taskGroups[0].taskSpec.runnables[0].container' should be a \"\n                    \"dictionary for gbatch configuration.\"\n                )\n            if image_uri:\n                job_runnable[\"container\"].setdefault(\"image_uri\", image_uri)\n            if entrypoint:\n                job_runnable[\"container\"].setdefault(\"entrypoint\", entrypoint)\n\n            job_runnable[\"container\"].setdefault(\"commands\", commands or [])\n        else:\n            job_runnable[\"script\"] = {\n                \"text\": None,  # placeholder for job command\n                \"_commands\": commands,  # Store commands for later use\n            }\n\n        # Clear existing runnables and rebuild with proper ordering\n        task_runnables.clear()\n\n        # Add runnables with negative order (before job)\n        for order, runnable_dict in additional_runnables:\n            if order &lt; 0:\n                task_runnables.append(runnable_dict)\n\n        # Add the main job runnable\n        task_runnables.append(job_runnable)\n        self.runnable_index = len(task_runnables) - 1\n\n        # Add runnables with positive order (after job)\n        for order, runnable_dict in additional_runnables:\n            if order &gt;= 0:\n                task_runnables.append(runnable_dict)\n\n        # Only logs the stdout/stderr of submission (when wrapped script doesn't run)\n        # The logs of the wrapped script are logged to stdout/stderr files\n        # in the workdir.\n        logs_policy = self.config.setdefault(\"logsPolicy\", {})\n        logs_policy.setdefault(\"destination\", \"CLOUD_LOGGING\")\n\n        volumes = task_spec.setdefault(\"volumes\", [])\n        if not isinstance(volumes, list):\n            raise ValueError(\n                \"'taskGroups[0].taskSpec.volumes' should be a list for \"\n                \"gbatch configuration.\"\n            )\n\n        volumes.insert(\n            0,\n            {\n                \"gcs\": {\"remotePath\": str(self.workdir).split(\"://\", 1)[1]},\n                \"mountPath\": str(self.workdir.mounted),\n            },\n        )\n\n        if mount and not isinstance(mount, (tuple, list)):\n            mount = [mount]  # type: ignore\n        if mount:\n            for m in mount:\n                # Let's check if mount is provided as \"OUTDIR=gs://bucket/dir\"\n                # If so, we mounted it to $DEFAULT_MOUNTED_ROOT/OUTDIR\n                # and set OUTDIR env variable to the mounted path in self._path_envs\n                if NAMED_MOUNT_RE.match(m):\n                    name, gcs = m.split(\"=\", 1)\n                    if not gcs.startswith(\"gs://\"):\n                        raise ValueError(\n                            \"When using named mount, it should be in the format \"\n                            \"'NAME=gs://bucket/dir', where NAME matches \"\n                            \"^[A-Za-z][A-Za-z0-9_]*$\"\n                        )\n                    gcs_path = PanPath(gcs)\n                    # Check if it is a file path\n                    if gcs_path.is_file():\n                        # Mount the parent directory\n                        gcs = str(gcs_path.parent._no_prefix)\n                        mount_path = (\n                            f\"{DEFAULT_MOUNTED_ROOT}/{name}/{gcs_path.parent.name}\"\n                        )\n                        self._path_envs[name] = f\"{mount_path}/{gcs_path.name}\"\n                    else:\n                        gcs = gcs[5:]\n                        mount_path = f\"{DEFAULT_MOUNTED_ROOT}/{name}\"\n                        self._path_envs[name] = mount_path\n\n                    volumes.append(\n                        {\n                            \"gcs\": {\"remotePath\": gcs},\n                            \"mountPath\": mount_path,\n                        }\n                    )\n                else:\n                    # Or, we expect a literal mount \"gs://bucket/dir:/mount/path\"\n                    gcs, mount_path = m.rsplit(\":\", 1)\n                    if gcs.startswith(\"gs://\"):\n                        gcs = gcs[5:]\n                    volumes.append(\n                        {\n                            \"gcs\": {\"remotePath\": gcs},\n                            \"mountPath\": mount_path,\n                        }\n                    )\n\n        # Add some labels for filtering by `gcloud batch jobs list`\n        labels = self.config.setdefault(\"labels\", {})\n\n        labels.setdefault(\"xqute\", \"true\")\n        labels.setdefault(\"user\", getpass.getuser())\n\n        allocation_policy = self.config.setdefault(\"allocationPolicy\", {})\n\n        if service_account:\n            allocation_policy.setdefault(\"serviceAccount\", {}).setdefault(\n                \"email\", service_account\n            )\n\n        if network or subnetwork or no_external_ip_address is not None:\n            network_interface = allocation_policy.setdefault(\"network\", {}).setdefault(\n                \"networkInterfaces\", []\n            )\n            if not network_interface:\n                network_interface.append({})\n            network_interface = network_interface[0]\n            if network:\n                network_interface.setdefault(\"network\", network)\n            if subnetwork:\n                network_interface.setdefault(\"subnetwork\", subnetwork)\n            if no_external_ip_address is not None:\n                network_interface.setdefault(\n                    \"noExternalIpAddress\", no_external_ip_address\n                )\n\n        if machine_type or provisioning_model:\n            instances = allocation_policy.setdefault(\"instances\", [])\n            if not instances:\n                instances.append({})\n            policy = instances[0].setdefault(\"policy\", {})\n            if machine_type:\n                policy.setdefault(\"machineType\", machine_type)\n            if provisioning_model:\n                policy.setdefault(\"provisioningModel\", provisioning_model)\n\n        email = allocation_policy.get(\"serviceAccount\", {}).get(\"email\")\n        if email:\n            # 63 character limit, '@' is not allowed in labels\n            # labels.setdefault(\"email\", email[:63])\n            labels.setdefault(\"sacct\", email.split(\"@\", 1)[0][:63])\n\n    async def job_config_file(self, job: Job) -&gt; SpecPath:\n        base = f\"job.wrapped.{self.name}.json\"\n        conf_file = job.metadir / base\n\n        wrapt_script = await self.wrapped_job_script(job)\n        config = deepcopy(self.config)\n        runnable = config[\"taskGroups\"][0][\"taskSpec\"][\"runnables\"][self.runnable_index]\n        if \"container\" in runnable:\n            container = runnable[\"container\"]\n            if \"entrypoint\" not in container:\n                # supports only /bin/bash, but not /bin/bash -u\n                container[\"entrypoint\"] = JOBCMD_WRAPPER_LANG\n                container[\"commands\"].append(str(wrapt_script.mounted))\n            elif any(\"{script}\" in cmd for cmd in container[\"commands\"]):\n                # If the entrypoint is already set, we assume it is a script\n                # that will be executed with the job command.\n                container[\"commands\"] = [\n                    cmd.replace(\"{lang}\", str(JOBCMD_WRAPPER_LANG)).replace(\n                        \"{script}\", str(wrapt_script.mounted)\n                    )\n                    for cmd in container[\"commands\"]\n                ]\n            else:\n                container[\"commands\"].append(\n                    shlex.join(\n                        shlex.split(JOBCMD_WRAPPER_LANG) + [str(wrapt_script.mounted)]\n                    )\n                )\n        else:\n            # Apply commands for script runnables as well\n            stored_commands = runnable[\"script\"].pop(\"_commands\", None)\n            if stored_commands:\n                if any(\"{script}\" in str(cmd) for cmd in stored_commands):\n                    # Use commands with script placeholder replacement\n                    command_parts = [\n                        shlex.quote(cmd)\n                        .replace(\"{lang}\", str(JOBCMD_WRAPPER_LANG))\n                        .replace(\"{script}\", str(wrapt_script.mounted))\n                        for cmd in stored_commands\n                    ]\n                else:\n                    # Append script to commands\n                    command_parts = [\n                        *(shlex.quote(str(cmd)) for cmd in stored_commands),\n                        shlex.quote(\n                            shlex.join(\n                                (\n                                    *shlex.split(JOBCMD_WRAPPER_LANG),\n                                    str(wrapt_script.mounted),\n                                )\n                            )\n                        ),\n                    ]\n            else:\n                command_parts = [\n                    *shlex.split(JOBCMD_WRAPPER_LANG),\n                    str(wrapt_script.mounted),\n                ]\n\n            runnable[\"script\"][\"text\"] = \" \".join(command_parts)\n\n        async with conf_file.a_open(\"w\") as f:\n            jsons = json.dumps(config, indent=2)\n            await f.write(jsons)\n\n        return SpecPath(conf_file, mounted=await conf_file.get_fspath())\n\n    async def _delete_job(self, job: Job) -&gt; None:\n        \"\"\"Try to delete the job from google cloud's registry\n\n        As google doesn't allow jobs to have the same id.\n\n        Args:\n            job: The job to delete\n        \"\"\"\n        logger.debug(\n            \"/Sched-%s Try deleting job %r on GCP.\",\n            self.name,\n            job,\n        )\n        status = await self._get_job_status(job)\n        while status.endswith(\"_IN_PROGRESS\"):  # pragma: no cover\n            await asyncio.sleep(SLEEP_INTERVAL_GBATCH_STATUS_CHECK)\n            status = await self._get_job_status(job)\n\n        command = [\n            self.gcloud,\n            \"batch\",\n            \"jobs\",\n            \"delete\",\n            await job.get_jid(),\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n        ]\n\n        try:\n            proc = await asyncio.create_subprocess_exec(\n                *command,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n            )\n        except Exception:\n            pass\n        else:\n            await proc.wait()\n\n        status = await self._get_job_status(job)\n        while status == \"DELETION_IN_PROGRESS\":  # pragma: no cover\n            await asyncio.sleep(SLEEP_INTERVAL_GBATCH_STATUS_CHECK)\n            status = await self._get_job_status(job)\n\n        if status != \"UNKNOWN\":\n            logger.warning(\n                \"/Sched-%s Failed to delete job %r on GCP, submision may fail.\",\n                self.name,\n                job,\n            )\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n\n        sha = sha256(str(self.workdir).encode()).hexdigest()[:8]\n        jid = f\"{self.jobname_prefix}-{sha}-{job.index}\".lower()\n        await job.set_jid(jid)\n        await self._delete_job(job)\n\n        conf_file = await self.job_config_file(job)\n        proc = await asyncio.create_subprocess_exec(\n            self.gcloud,\n            \"batch\",\n            \"jobs\",\n            \"submit\",\n            jid,\n            \"--config\",\n            conf_file.mounted,\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.STDOUT,\n        )\n\n        stdout, _ = await proc.communicate()\n        if proc.returncode != 0:  # pragma: no cover\n            raise RuntimeError(\n                \"Can't submit job to Google Cloud Batch: \\n\"\n                f\"{stdout.decode()}\\n\"\n                \"Check the configuration file:\\n\"\n                f\"{conf_file}\"\n            )\n\n        return jid\n\n    async def kill_job(self, job: Job):DOCS\n        command = [\n            self.gcloud,\n            \"alpha\",\n            \"batch\",\n            \"jobs\",\n            \"cancel\",\n            await job.get_jid(),\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n            \"--quiet\",\n        ]\n        proc = await asyncio.create_subprocess_exec(\n            *command,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n\n    async def _get_job_status(self, job: Job) -&gt; str:\n        if not await job.jid_file.a_is_file():\n            return \"UNKNOWN\"\n\n        # Do not rely on _jid, as it can be a obolete job.\n        jid = (await job.jid_file.a_read_text()).strip()\n\n        command = [\n            self.gcloud,\n            \"batch\",\n            \"jobs\",\n            \"describe\",\n            jid,\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n        ]\n\n        try:\n            proc = await asyncio.create_subprocess_exec(\n                *command,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n            )\n        except Exception:\n            return \"UNKNOWN\"\n\n        if await proc.wait() != 0:\n            return \"UNKNOWN\"\n\n        stdout = (await proc.stdout.read()).decode()\n        return re.search(r\"state: (.+)\", stdout).group(1)\n\n    async def job_fails_before_running(self, job: Job) -&gt; bool:  # pragma: no coverDOCS\n        status = await self._get_job_status(job)\n        return status in (\"FAILED\", \"DELETION_IN_PROGRESS\", \"CANCELLED\")\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        status = await self._get_job_status(job)\n        return status in (\"RUNNING\", \"QUEUED\", \"SCHEDULED\")\n\n    def jobcmd_init(self, job) -&gt; str:DOCS\n        init_cmd = super().jobcmd_init(job)\n        path_envs_exports = [\n            f\"export {key}={shlex.quote(value)}\"\n            for key, value in self._path_envs.items()\n        ]\n        if path_envs_exports:\n            path_envs_exports.insert(0, \"# Mounted paths\")\n            init_cmd = \"\\n\".join(path_envs_exports) + \"\\n\" + init_cmd\n\n        return init_cmd\n</code></pre>"},{"location":"api/source/xqute.schedulers.local_scheduler/","title":"xqute.schedulers.local_scheduler","text":""},{"location":"api/source/xqute.schedulers.local_scheduler/","title":"SOURCE CODE xqute.schedulers.local_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs locally\"\"\"\n\nimport asyncio\nimport os\nimport shlex\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\n\n\ndef _pid_exists(pid: int) -&gt; bool:\n    \"\"\"Check if a process with a given pid exists\"\"\"\n    try:\n        os.kill(pid, 0)\n    except Exception:  # pragma: no cover\n        return False\n    return True\n\n\nclass LocalScheduler(Scheduler):DOCS\n    \"\"\"The local scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n    \"\"\"\n\n    name = \"local\"\n\n    async def submit_job(self, job: Job) -&gt; int:DOCS\n        \"\"\"Submit a job locally\n\n        Args:\n            job: The job\n\n        Returns:\n            The process id\n        \"\"\"\n        job_script = await self.wrapped_job_script(job)\n        wrapt_script_path = await job_script.get_fspath()\n        # In case the process exits very quickly\n        if not await job.jid_file.a_exists():\n            await job.jid_file.a_write_text(\"0\")\n\n        proc = await asyncio.create_subprocess_exec(\n            *shlex.split(self.jobcmd_shebang(job)),\n            wrapt_script_path,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.STDOUT,\n            start_new_session=True,\n            # Changing the working directory here may cause wrapped_job_script to fail\n            # to be found, so we don't set cwd here.\n            # The cwd is changed in the wrapper script instead.\n            # cwd=self.cwd\n        )\n\n        # wait for a while to make sure the process is running\n        # this is to avoid the real command is not run when proc is recycled too early\n        # this happens for python &lt; 3.12\n        await asyncio.sleep(0.1)\n\n        if await job.stdout_file.a_exists():  # pragma: no cover\n            # job submitted successfully and already started very soon\n            return proc.pid\n\n        if proc.returncode is not None and proc.returncode != 0:\n            # The process has already finished and no stdout/stderr files are\n            # generated\n            # Something went wrong with the wrapper script?\n            stderr = await proc.stdout.read()\n            raise RuntimeError(\n                f\"Failed to submit job #{job.index} (rc={proc.returncode}): \"\n                f\"{stderr.decode()}\\n\"\n                f\"Command: {self.jobcmd_shebang(job)} \"\n                f\"{wrapt_script_path}\\n\"\n            )\n\n        # don't await for the results, as this will run the real command\n        return proc.pid\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job asynchronously\n\n        Args:\n            job: The job\n        \"\"\"\n        try:\n            os.killpg(int(await job.get_jid()), 9)\n        except Exception:  # pragma: no cover\n            pass\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        try:\n            jid = int((await job.jid_file.a_read_text()).strip())\n        except (ValueError, TypeError, FileNotFoundError):\n            return False\n\n        if jid &lt;= 0:\n            return False\n\n        return _pid_exists(jid)\n\n    @propertyDOCS\n    def jobcmd_wrapper_init(self) -&gt; str:\n        \"\"\"The init script for the job command wrapper\"\"\"\n        wrapper_init = super().jobcmd_wrapper_init\n        wrapper_init += \"\\n\"\n        # give some time for xqute to update job status to submitted first\n        wrapper_init += \"sleep 1\\n\"\n        return wrapper_init\n\n    def jobcmd_prep(self, job) -&gt; str:DOCS\n        \"\"\"The job command preparation\"\"\"\n        codes = super().jobcmd_prep(job)\n        codes += \"\\n\"\n        # give some time for xqute to update job status to running\n        codes += \"sleep 1\\n\"\n        return codes\n</code></pre>"},{"location":"api/source/xqute.schedulers/","title":"xqute.schedulers","text":""},{"location":"api/source/xqute.schedulers/","title":"SOURCE CODE xqute.schedulers DOCS","text":"<pre><code>\"\"\"Builtin schedulers\"\"\"\n\nfrom __future__ import annotations\n\nfrom importlib import import_module\nfrom typing import Type\n\nfrom ..scheduler import Scheduler\n\n\ndef get_scheduler(scheduler: str | Type[Scheduler]) -&gt; Type[Scheduler]:DOCS\n    \"\"\"Get the scheduler class\n\n    Args:\n        sched_name: The scheduler name\n            Defined in the scheduler class\n\n    Returns:\n        The scheduler class\n    \"\"\"\n    if isinstance(scheduler, str):\n        module = import_module(f\"{__name__}.{scheduler}_scheduler\")\n        return getattr(module, f\"{scheduler[0].upper()}{scheduler[1:]}Scheduler\")\n    return scheduler\n</code></pre>"},{"location":"api/source/xqute.schedulers.sge_scheduler/","title":"xqute.schedulers.sge_scheduler","text":""},{"location":"api/source/xqute.schedulers.sge_scheduler/","title":"SOURCE CODE xqute.schedulers.sge_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs on SGE\"\"\"\n\nimport asyncio\nimport hashlib\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\n\n\nclass SgeScheduler(Scheduler):DOCS\n    \"\"\"The sge scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n\n    Args:\n        qsub: path to qsub command\n        qstat: path to qstat command\n        qdel: path to qdel command\n        ...: other Scheduler args. List or tuple options will be expanded.\n            For example: `sge_l=['hvmem=2G', 'gpu=1']` will be expaned into\n            `-l h_vmem=2G -l gpu=1`\n    \"\"\"\n\n    name: str = \"sge\"\n\n    __slots__ = Scheduler.__slots__ + (\"qsub\", \"qdel\", \"qstat\")\n\n    def __init__(self, *args, **kwargs):\n        self.qsub = kwargs.pop(\"qsub\", \"qsub\")\n        self.qdel = kwargs.pop(\"qdel\", \"qdel\")\n        self.qstat = kwargs.pop(\"qstat\", \"qstat\")\n        super().__init__(*args, **kwargs)\n\n    def jobcmd_shebang(self, job) -&gt; str:DOCS\n        options = self.config.copy()\n        sha = hashlib.sha256(str(self.workdir).encode()).hexdigest()[:8]\n        options[\"N\"] = f\"{self.jobname_prefix}-{sha}-{job.index}\"\n        if self.cwd:\n            options[\"wd\"] = self.cwd\n        else:\n            options[\"cwd\"] = True\n        # options[\"o\"] = self.stdout_file\n        # options[\"e\"] = self.stderr_file\n\n        options_list = []\n        for key, val in options.items():\n            if val is True:\n                options_list.append(f\"#$ -{key}\")\n            elif isinstance(val, (tuple, list)):\n                for optval in val:\n                    options_list.append(f\"#$ -{key} {optval}\")\n            else:\n                options_list.append(f\"#$ -{key} {val}\")\n\n        return super().jobcmd_shebang(job) + \"\\n\" + \"\\n\".join(options_list)\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n        \"\"\"Submit a job to SGE\n\n        Args:\n            job: The job\n\n        Returns:\n            The job id\n        \"\"\"\n        job_script = await self.wrapped_job_script(job)\n        proc = await asyncio.create_subprocess_exec(\n            self.qsub,\n            job_script.mounted,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        stdout, stderr = await proc.communicate()\n        if proc.returncode != 0:  # pragma: no cover\n            raise RuntimeError(f\"Can't submit job to SGE: {stderr.decode()}\")\n\n        # Your job 613815 (...) has been submitted\n        try:\n            job_id = stdout.decode().split()[2]\n        except Exception:  # pragma: no cover\n            raise RuntimeError(\"Can't get job id from qsub output.\", stdout, stderr)\n\n        return job_id\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job on SGE\n\n        Args:\n            job: The job\n        \"\"\"\n        proc = await asyncio.create_subprocess_exec(\n            self.qdel,\n            str(await job.get_jid()),\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        try:\n            jid = (await job.jid_file.a_read_text()).strip()\n        except FileNotFoundError:\n            return False\n\n        if not jid:\n            return False\n\n        proc = await asyncio.create_subprocess_exec(\n            self.qstat,\n            \"-j\",\n            jid,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        return await proc.wait() == 0\n</code></pre>"},{"location":"api/source/xqute.schedulers.slurm_scheduler/","title":"xqute.schedulers.slurm_scheduler","text":""},{"location":"api/source/xqute.schedulers.slurm_scheduler/","title":"SOURCE CODE xqute.schedulers.slurm_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs on Slurm\"\"\"\n\nimport asyncio\nimport hashlib\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\n\n\nclass SlurmScheduler(Scheduler):DOCS\n    \"\"\"The Slurm scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n\n    Args:\n        sbatch: path to sbatch command\n        squeue: path to squeue command\n        scancel: path to scancel command\n        ... other Scheduler args\n    \"\"\"\n\n    name: str = \"slurm\"\n\n    __slots__ = Scheduler.__slots__ + (\"sbatch\", \"squeue\", \"scancel\")\n\n    def __init__(self, *args, **kwargs):\n        self.sbatch = kwargs.pop(\"sbatch\", \"sbatch\")\n        self.squeue = kwargs.pop(\"squeue\", \"squeue\")\n        self.scancel = kwargs.pop(\"scancel\", \"scancel\")\n        super().__init__(*args, **kwargs)\n\n    def jobcmd_shebang(self, job) -&gt; str:DOCS\n        options = self.config.copy()\n\n        sha = hashlib.sha256(str(self.workdir).encode()).hexdigest()[:8]\n        options[\"job-name\"] = f\"{self.jobname_prefix}-{sha}-{job.index}\"\n        options[\"chdir\"] = self.cwd\n        # options[\"output\"] = self.stdout_file\n        # options[\"error\"] = self.stderr_file\n\n        options_list = []\n        for key, val in options.items():\n            key = key.replace(\"_\", \"-\")\n            if len(key) == 1:\n                fmt = \"#SBATCH -{key} {val}\"\n            else:\n                fmt = \"#SBATCH --{key}={val}\"\n            options_list.append(fmt.format(key=key, val=val))\n\n        return super().jobcmd_shebang(job) + \"\\n\" + \"\\n\".join(options_list) + \"\\n\"\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n        \"\"\"Submit a job to Slurm\n\n        Args:\n            job: The job\n\n        Returns:\n            The job id\n        \"\"\"\n        job_script = await self.wrapped_job_script(job)\n        proc = await asyncio.create_subprocess_exec(\n            self.sbatch,\n            job_script.mounted,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.STDOUT,\n        )\n        rc = await proc.wait()\n        if rc != 0:  # pragma: no cover\n            stderr = await proc.stdout.read()\n            raise Exception(stderr.decode().strip())\n\n        stdout = await proc.stdout.read()\n        # salloc: Granted job allocation 65537\n        # sbatch: Submitted batch job 65537\n        return stdout.decode().strip().split()[-1]\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job on Slurm\n\n        Args:\n            job: The job\n        \"\"\"\n        proc = await asyncio.create_subprocess_exec(\n            self.scancel,\n            str(await job.get_jid()),\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n\n    async def _get_job_status(self, job: Job) -&gt; str:\n        \"\"\"Tell the status of a job on Slurm\n\n        Args:\n            job: The job\n\n        Returns:\n            The status string\n        \"\"\"\n        try:\n            jid = (await job.jid_file.a_read_text()).strip()\n        except FileNotFoundError:\n            return \"UNKNOWN\"\n\n        if not jid:\n            return \"UNKNOWN\"\n\n        proc = await asyncio.create_subprocess_exec(\n            self.squeue,\n            \"-j\",\n            jid,\n            \"--noheader\",\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n        if proc.returncode != 0:\n            return \"UNKNOWN\"\n\n        # ['8792', 'queue', 'merge', 'user', 'R', '7:34:34', '1', 'server']\n        stdout = await proc.stdout.read()\n        return stdout.decode().strip().split()[4].upper()  # type: ignore\n\n    async def job_fails_before_running(self, job: Job) -&gt; bool:  # pragma: no coverDOCS\n        status = await self._get_job_status(job)\n        return status in (\n            \"CA\",\n            \"CANCELLED\",\n            \"F\",\n            \"FAILED\",\n            \"NF\",\n            \"NODE_FAIL\",\n            \"PR\",\n            \"PREEMPTED\",\n            \"BF\",\n            \"BOOT_FAIL\",\n            \"SE\",\n            \"SPECIAL_EXIT\",\n            \"ST\",\n            \"STOPPED\",\n            \"TO\",\n            \"TIMEOUT\",\n            \"SI\",\n            \"SIGNALING\",\n        )\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        status = await self._get_job_status(job)\n        return status in (\n            \"R\",\n            \"RUNNING\",\n            \"PD\",\n            \"PENDING\",\n            \"CG\",\n            \"COMPLETING\",\n            \"S\",\n            \"SUSPENDED\",\n            \"CF\",\n            \"CONFIGURING\",\n            # Job is being held after requested reservation was deleted.\n            \"RD\",\n            \"RESV_DEL_HOLD\",\n            # Job is being requeued by a federation.\n            \"RF\",\n            \"REQUEUE_FED\",\n            # Held job is being requeued.\n            \"RH\",\n            \"REQUEUE_HOLD\",\n            # Completing job is being requeued.\n            \"RQ\",\n            \"REQUEUED\",\n            # Job is about to change size.\n            \"RS\",\n            \"RESIZING\",\n            # Sibling was removed from cluster due to other cluster\n            # starting the job.\n            \"RV\",\n            \"REVOKED\",\n            # The job was requeued in a special state. This state can be set by\n            # users, typically in EpilogSlurmctld, if the job has terminated\n            # with a particular exit value.\n            \"SE\",\n            \"SPECIAL_EXIT\",\n            # Job is staging out files.\n            \"SO\",\n            \"STAGE_OUT\",\n            # Job has an allocation, but execution has been stopped with\n            # SIGSTOP signal. CPUS have been retained by this job.\n            \"ST\",\n            \"STOPPED\",\n        )\n</code></pre>"},{"location":"api/source/xqute.schedulers.ssh_scheduler/","title":"xqute.schedulers.ssh_scheduler","text":""},{"location":"api/source/xqute.schedulers.ssh_scheduler/","title":"SOURCE CODE xqute.schedulers.ssh_scheduler DOCS","text":"<pre><code>from .scheduler import SshScheduler\n</code></pre>"},{"location":"api/source/xqute.schedulers.ssh_scheduler.scheduler/","title":"xqute.schedulers.ssh_scheduler.scheduler","text":""},{"location":"api/source/xqute.schedulers.ssh_scheduler.scheduler/","title":"SOURCE CODE xqute.schedulers.ssh_scheduler.scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs on SSH\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport shlex\n\nfrom panpath import CloudPath\n\nfrom ...schedulers.local_scheduler import LocalScheduler\nfrom ...job import Job\nfrom ...defaults import SLEEP_INTERVAL_CLOUD_FILE_CHECK\n\nfrom .client import SSHClient\n\n\nclass SshScheduler(LocalScheduler):DOCS\n    \"\"\"The ssh scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n\n    Args:\n        ...: other Scheduler args\n    \"\"\"\n\n    name: str = \"ssh\"\n\n    __slots__ = LocalScheduler.__slots__ + (\"ssh\", \"servers\")\n\n    def __init__(self, *args, **kwargs):\n        self.ssh = kwargs.pop(\"ssh\", \"ssh\")\n        ssh_servers = kwargs.pop(\"servers\", {})\n        super().__init__(*args, **kwargs)\n        self.servers = {}\n        if isinstance(ssh_servers, (tuple, list)):\n            ssh_servers = {server: {} for server in ssh_servers}\n        for key, val in ssh_servers.items():\n            client = SSHClient(self.ssh, key, **val)\n            self.servers[client.name] = client\n\n        if not self.servers:\n            raise ValueError(\n                \"No ssh_servers defined in config, \"\n                \"please define at least one server\",\n            )\n\n        loop = asyncio.get_running_loop()\n        loop.shutdown_asyncgens = self._disconnect_all\n\n    async def _disconnect_all(self):\n        for server in self.servers.values():\n            await server.disconnect()\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n        \"\"\"Submit a job to SSH\n\n        Args:\n            job: The job\n\n        Returns:\n            The job id\n        \"\"\"\n        server = list(self.servers.values())[job.index % len(self.servers)]\n        await server.connect()\n\n        job_script = await self.wrapped_job_script(job)\n        rc, stdout, stderr = await server.submit(\n            *shlex.split(self.jobcmd_shebang(job)),\n            job_script,\n        )\n\n        if rc != 0:\n            # job.stdout_file.write_bytes(stdout)\n            # job.stderr_file.write_bytes(stderr)\n            raise RuntimeError(f\"Failed to submit job #{job.index}: {stderr.decode()}\")\n\n        try:\n            pid, srvname = stdout.decode().split(\"@\", 1)\n        except (ValueError, TypeError):  # pragma: no cover\n            raise RuntimeError(\n                f\"Failed to submit job #{job.index}: \"\n                f\"expecting 'pid@server', got {stdout.decode()}\"\n            )\n        else:\n            # wait for a while to make sure the process is running\n            # this is to avoid the real command is not run when proc is recycled\n            # too early\n            # this happens for python &lt; 3.12\n            while (\n                not await job.stdout_file.a_exists()\n                and not await job.stderr_file.a_exists()\n            ):\n                print(f\"Checking if SSH job #{job.index} is running...\")\n                if not await self.servers[srvname].is_running(pid):\n                    # job.stdout_file.write_bytes(stdout)\n                    # job.stderr_file.write_bytes(stderr)\n\n                    raise RuntimeError(\n                        f\"Failed to submit job #{job.index}: {stderr.decode()}\"\n                    )\n\n                if isinstance(job.stdout_file, CloudPath):  # pragma: no cover\n                    await asyncio.sleep(SLEEP_INTERVAL_CLOUD_FILE_CHECK)\n                else:  # pragma: no cover\n                    await asyncio.sleep(0.1)\n\n        return stdout.decode()\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job on SSH\n\n        Args:\n            job: The job\n        \"\"\"\n        try:\n            pid, server = str(await job.get_jid()).split(\"@\", 1)\n            await self.servers[server].kill(pid)\n        except Exception:  # pragma: no cover\n            pass\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        try:\n            jid = (await job.jid_file.a_read_text()).strip()\n        except FileNotFoundError:\n            return False\n\n        if not jid:\n            return False\n\n        try:\n            pid, server = jid.split(\"@\", 1)\n        except (ValueError, TypeError):  # pragma: no cover\n            # Can be the jid file by a different scheduler from previous runs\n            return False\n\n        if server not in self.servers:\n            return False\n\n        try:\n            return await self.servers[server].is_running(pid)\n        except Exception:  # pragma: no cover\n            return False\n</code></pre>"},{"location":"api/source/xqute.schedulers.ssh_scheduler.submitter/","title":"xqute.schedulers.ssh_scheduler.submitter","text":""},{"location":"api/source/xqute.schedulers.ssh_scheduler.submitter/","title":"SOURCE CODE xqute.schedulers.ssh_scheduler.submitter DOCS","text":"<pre><code>\"\"\"This script is used to wrap the command for the scheduler to submit and run\n\nIt is used by the ssh scheduler to submit jobs to remote servers\nand print the pid of the job to stdout.\nThe real command is run in a subprocess without waiting for the results.\n\nThe script is executed by the scheduler, not the user. And it's not imported\nby xqute directly.\n\nFind a way to pass envs?\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport subprocess\n\nif __name__ == \"__main__\":\n    server, cwd, *cmds = sys.argv[1:]\n\n    proc = subprocess.Popen(\n        cmds,\n        cwd=cwd,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        preexec_fn=os.setpgrp,\n    )\n    stdout = proc.stdout.read().decode()\n    stderr = proc.stderr.read().decode()\n    sys.stdout.write(f\"{proc.pid}@{server}\")\n    # wait for a while to make sure the process is running\n    time.sleep(0.1)\n    rc = proc.poll()\n    if rc is None or rc == 0:\n        # still running or already finished\n        sys.exit(0)\n    else:\n        sys.stderr.write(f\"STDOUT: {stdout}\\nSTDERR: {stderr}\")\n        sys.exit(rc)\n</code></pre>"},{"location":"api/source/xqute.utils/","title":"xqute.utils","text":""},{"location":"api/source/xqute.utils/","title":"SOURCE CODE xqute.utils DOCS","text":"<pre><code>\"\"\"Utilities for xqute\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport logging\nfrom typing import Union, Tuple, List\n\nfrom rich.logging import RichHandler\n\nfrom .defaults import LOGGER_NAME, LOGGER_LEVEL\n\nCommandType = Union[str, Tuple[str], List[str]]\n\n\nlogger = logging.getLogger(LOGGER_NAME)\nlogger.addHandler(RichHandler(show_path=False, omit_repeated_times=False))\n\nloglevel = os.getenv(\"XQUTE_LOG_LEVEL\", LOGGER_LEVEL).upper()\nlogger.setLevel(loglevel)\n</code></pre>"},{"location":"api/source/xqute.xqute/","title":"xqute.xqute","text":""},{"location":"api/source/xqute.xqute/","title":"SOURCE CODE xqute.xqute DOCS","text":"<pre><code>\"\"\"The xqute module\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport functools\nimport signal\nfrom collections import deque\nfrom typing import TYPE_CHECKING, Any, List, Mapping, Type\n\nfrom .defaults import (\n    DEFAULT_WORKDIR,\n    DEFAULT_ERROR_STRATEGY,\n    DEFAULT_NUM_RETRIES,\n    DEFAULT_SCHEDULER_FORKS,\n    # DEFAULT_SUBMISSION_BATCH,\n    JobStatus,\n    SLEEP_INTERVAL_PRODUCER_MAX_FORKS,\n    SLEEP_INTERVAL_POLLING_JOBS,\n    SLEEP_INTERVAL_KEEP_FEEDING,\n)\nfrom .utils import logger, CommandType\nfrom .plugin import plugin\nfrom .schedulers import get_scheduler\n\nif TYPE_CHECKING:\n    from .path import PathType\n    from .scheduler import Scheduler\n    from .job import Job\n\n\nclass Xqute:DOCS\n    \"\"\"The main class of the package\n\n    Attributes:\n        name: The name, used in logger\n        EMPTY_BUFFER_SLEEP_TIME: The time to sleep while waiting when\n            the buffer is empty to wait for the jobs to be pushed\n\n        jobs: The jobs registry\n        plugins: The plugins to be enabled or disabled\n            to disable a plugin, using `-plugin_name`\n            either all plugin names should be prefixed with '+'/'-' or none\n            of them should\n\n        _cancelling: A mark to mark whether a shutting down event\n            is triggered (True for natural cancelling, the signal for\n            cancelling with a signal, SIGINT for example)\n\n        buffer_queue: A buffer queue to save the pushed jobs\n        queue: The job queue\n        scheduler: The scheduler\n        task: The task of producer and consumers\n\n    Args:\n        scheduler: The scheduler class or name\n        plugins: The plugins to be enabled or disabled\n            to disable a plugin, using `-plugin_name`\n            either all plugin names should be prefixed with '+'/'-' or none\n            of them should\n        workdir: The job meta directory\n        submission_batch: The number of consumers to submit jobs. This allows\n            multiple jobs to be submitted in parallel. This is useful when\n            there are many jobs to be submitted and the scheduler has a high\n            latency for each submission. Set this to a smaller number if the\n            scheduler cannot handle too many simultaneous submissions.\n        error_strategy: The strategy when there is error happened\n        num_retries: Max number of retries when error_strategy is retry\n        forks: Max number of job forks for scheduler\n        scheduler_opts: Additional keyword arguments for scheduler\n    \"\"\"\n\n    name: str = \"Xqute\"\n    EMPTY_BUFFER_SLEEP_TIME: int = 1\n\n    def __init__(\n        self,\n        scheduler: str | Type[Scheduler] = \"local\",\n        *,\n        plugins: List[Any] | None = None,\n        workdir: str | PathType = DEFAULT_WORKDIR,\n        submission_batch: int | None = None,\n        error_strategy: str = DEFAULT_ERROR_STRATEGY,\n        num_retries: int = DEFAULT_NUM_RETRIES,\n        forks: int = DEFAULT_SCHEDULER_FORKS,\n        scheduler_opts: Mapping[str, Any] | None = None,\n        jobname_prefix: str | None = None,\n    ) -&gt; None:\n        self.jobs: List[Job] = []\n\n        self.plugin_context = plugin.plugins_context(plugins)\n\n        self.plugin_context.__enter__()\n\n        logger.info(\n            \"/%s Enabled plugins: %s\",\n            self.name,\n            plugin.get_enabled_plugin_names(),\n        )\n\n        self._cancelling: bool | signal.Signals = False\n        self._keep_feeding: bool = False\n        self._completion_task: asyncio.Task | None = None\n\n        self.buffer_queue: deque = deque()\n        self._buffer_event: asyncio.Event = asyncio.Event()\n        self.queue: asyncio.Queue = asyncio.Queue()\n\n        scheduler_opts = scheduler_opts or {}\n        self.scheduler = get_scheduler(scheduler)(\n            workdir=workdir,\n            forks=forks,\n            error_strategy=error_strategy,\n            num_retries=num_retries,\n            jobname_prefix=jobname_prefix,\n            submission_batch=submission_batch,\n            **scheduler_opts,\n        )\n\n        # requires to be defined in a loop\n        loop = asyncio.get_running_loop()\n        for sig in (signal.SIGTERM, signal.SIGINT):\n            loop.add_signal_handler(sig, functools.partial(self.cancel, sig))\n\n        self._tasks: asyncio.Task | None = None\n\n        logger.debug(\"/%s Calling on_init hook ...\", self.name)\n        plugin.hooks.on_init(self)\n\n    def __del__(self) -&gt; None:DOCS\n        \"\"\"Destructor to warn if stop_feeding was not called\"\"\"\n        if hasattr(self, \"is_feeding\") and self.is_feeding():\n            logger.warning(\n                \"/%s Instance destroyed while still in keep_feeding mode. \"\n                \"Did you forget to call 'await xqute.stop_feeding()'?\",\n                self.name,\n            )\n\n    def cancel(self, sig: signal.Signals | None = None) -&gt; None:DOCS\n        \"\"\"Cancel the producer-consumer task\n\n        `self._cancelling` will be set to `signaled` if sig is provided,\n        otherwise it will be set to `True`\n\n        Args:\n            sig: Whether this cancelling is caused by a signal\n        \"\"\"\n        self._cancelling = True\n        if sig:\n            self._cancelling = sig\n            logger.warning(\n                \"/%s Got signal %r, trying a graceful \" \"shutdown ...\",\n                self.name,\n                sig.name,\n            )\n\n        logger.debug(\"/%s Calling on_shutdown hook ...\", self.name)\n\n        # Always cancel tasks if not already cancelled, regardless of hook result\n        # This prevents plugins from accidentally leaving tasks running\n        if plugin.hooks.on_shutdown(self, sig) is not False:\n            if self._tasks:\n                self._tasks.cancel()\n\n    async def _producer(self) -&gt; None:\n        \"\"\"The producer\"\"\"\n        polling_counter = 0\n\n        try:\n            while True:\n                if not self.buffer_queue:\n                    # If not in keep_feeding mode and buffer is empty, exit\n                    if not self._keep_feeding:\n                        logger.debug(\n                            \"/Producer Buffer empty and not in keep_feeding mode, \"\n                            \"exiting ...\"\n                        )\n                        break\n                    logger.debug(\"/Producer Buffer queue is empty, waiting ...\")\n                    # Wait for buffer event instead of sleep polling\n                    await self._buffer_event.wait()\n                    self._buffer_event.clear()\n                    continue\n\n                job = self.buffer_queue.popleft()\n                # Lightweight check: just count running jobs, no hooks\n                n_running = await self.scheduler.count_running_jobs(self.jobs)\n                if n_running &gt;= self.scheduler.forks:\n                    logger.debug(\"/Producer Hit max forks of scheduler ...\")\n                    self.buffer_queue.appendleft(job)\n                    # Wait longer when hitting max forks to reduce polling overhead\n                    await asyncio.sleep(SLEEP_INTERVAL_PRODUCER_MAX_FORKS)\n                    polling_counter += 1\n                    continue\n\n                await job.set_status(JobStatus.QUEUED)\n                await self.queue.put(job)\n                polling_counter = 0  # Reset counter after successful queuing\n\n            # Send sentinel values to stop consumers\n            logger.debug(\"/Producer Finished, sending sentinels to consumers ...\")\n            for _ in range(self.scheduler.subm_batch):\n                await self.queue.put(None)\n        except asyncio.CancelledError:\n            logger.debug(\"/Producer Cancelled ...\")\n\n    async def _consumer(self, index: int) -&gt; None:\n        \"\"\"The consumer\n\n        Args:\n            index: The index of the consumer\n        \"\"\"\n        try:\n            while True:\n                job = await self.queue.get()\n                # Check for sentinel value to exit gracefully\n                if job is None:\n                    logger.debug(\"/Consumer-%s Received sentinel, exiting ...\", index)\n                    self.queue.task_done()\n                    break\n\n                logger.debug(\"/Consumer-%s submitting %s\", index, job)\n                await self.scheduler.submit_job_and_update_status(job)\n                self.queue.task_done()\n        except asyncio.CancelledError:\n            logger.warning(\"/Consumer-%s Cancelled while submitting ...\", index)\n\n    async def feed(self, cmd: CommandType | Job, envs: dict[str, Any] = None) -&gt; None:DOCS\n        \"\"\"Put a command into the buffer\n\n        Args:\n            cmd: The command\n            envs: The environment variables for the job\n        \"\"\"\n        from .job import Job\n\n        envs = envs or {}\n\n        if isinstance(cmd, Job):\n            job = cmd\n            job.envs.update(envs)\n        else:\n            job = await self.scheduler.create_job(len(self.jobs), cmd, envs)\n\n        logger.debug(\"/Job-%s Calling on_job_init hook ...\", job.index)\n        await plugin.hooks.on_job_init(self.scheduler, job)\n        self.jobs.append(job)\n        logger.info(\"/%s Pushing job: %r\", self.name, job)\n\n        self.buffer_queue.append(job)\n        # Signal producer that buffer has new jobs\n        self._buffer_event.set()\n        logger.debug(\"/Job-%s Calling on_job_queued hook ...\", job.index)\n        await plugin.hooks.on_job_queued(self.scheduler, job)\n\n    def is_feeding(self) -&gt; bool:DOCS\n        \"\"\"Check if the system is in keep_feeding mode.\n\n        Returns:\n            True if in keep_feeding mode and waiting for stop_feeding() to be called.\n        \"\"\"\n        return (\n            hasattr(self, \"_keep_feeding\")\n            and self._keep_feeding\n            and hasattr(self, \"_completion_task\")\n            and self._completion_task\n        )\n\n    async def stop_feeding(self) -&gt; None:DOCS\n        \"\"\"Stop feeding mode and wait for all jobs to complete.\n\n        After calling this method, the producer will exit once the buffer\n        queue is empty, and this method will wait for all jobs to complete.\n        This should be called after all jobs have been submitted when using\n        run_until_complete(keep_feeding=True).\n\n        Raises:\n            RuntimeError: If called without first calling\n                run_until_complete(keep_feeding=True)\n        \"\"\"\n        if not self.is_feeding():\n            logger.error(\n                \"/%s stop_feeding() called but keep_feeding mode was not started. \"\n                \"Ignoring ...\",\n                self.name,\n            )\n            return\n\n        logger.debug(\"/%s Stopping feeding mode\", self.name)\n        self._keep_feeding = False\n\n        # Wait for completion if we started in keep_feeding mode\n        try:\n            await self._completion_task\n        except asyncio.CancelledError:  # pragma: no cover\n            if self._tasks:\n                self._tasks.cancel()\n\n        self._completion_task = None\n\n    async def _polling_jobs(self) -&gt; None:\n        \"\"\"Polling the jobs to see if they are all done.\n\n        If yes, cancel the producer-consumer task naturally.\n        \"\"\"\n        try:\n            # Wait for feeding to stop if in keep_feeding mode\n            while self._keep_feeding:\n                await asyncio.sleep(SLEEP_INTERVAL_KEEP_FEEDING)\n\n            polling_counter = 0\n            while self._cancelling is False and not await self.scheduler.check_all_done(\n                self.jobs, polling_counter\n            ):\n                await asyncio.sleep(SLEEP_INTERVAL_POLLING_JOBS)\n                polling_counter += 1\n\n            if self._cancelling is False:\n                self.cancel()\n        except asyncio.CancelledError:\n            logger.debug(\"/%s Polling cancelled ...\", self.name)\n            if self._cancelling not in (True, False):  # signaled\n                await self.scheduler.kill_running_jobs(self.jobs)\n\n    async def run_until_complete(self, keep_feeding: bool = False) -&gt; None:DOCS\n        \"\"\"Wait until all jobs complete\n\n        Args:\n            keep_feeding: If True, starts running in background and returns immediately,\n                allowing jobs to be added after calling this method.\n                You must call stop_feeding() when done adding jobs, which will\n                wait for all jobs to complete.\n                If False (default), waits for all current jobs to complete immediately.\n\n        Examples:\n            Traditional usage:\n            ```python\n            xqute = Xqute()\n            await xqute.feed(['echo', '1'])\n            await xqute.feed(['echo', '2'])\n            await xqute.run_until_complete()\n            ```\n\n            Keep feeding mode:\n            ```python\n            xqute = Xqute()\n            await xqute.feed(['echo', '1'])\n            await xqute.run_until_complete(keep_feeding=True)  # Returns immediately\n            await xqute.feed(['echo', '2'])  # Can add more jobs\n            await xqute.stop_feeding()  # Waits for completion\n            ```\n        \"\"\"\n        self._keep_feeding = keep_feeding\n\n        if keep_feeding:\n            # Start completion tasks in background\n            logger.debug(\"/%s Starting in keep_feeding mode ...\", self.name)\n            self._completion_task = asyncio.create_task(self._run_completion_tasks())\n            # Return immediately to allow more jobs to be added\n            return\n\n        # Traditional mode - wait for completion\n        logger.debug(\n            \"/%s Done feeding jobs, waiting for jobs to be done ...\", self.name\n        )\n        await self._run_completion_tasks()\n\n    async def _run_completion_tasks(self) -&gt; None:\n        \"\"\"Run the completion tasks (polling and await)\"\"\"\n        self._tasks = asyncio.gather(\n            self._producer(),\n            *(self._consumer(i) for i in range(self.scheduler.subm_batch)),\n            self._polling_jobs(),\n        )\n        try:\n            await self._tasks\n        except asyncio.CancelledError:\n            logger.debug(\"/%s Completion tasks cancelled ...\", self.name)\n        finally:\n            logger.info(\"/%s Done!\", self.name)\n            if self.plugin_context:\n                self.plugin_context.__exit__()\n</code></pre>"}]}