{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#xqute","title":"xqute","text":"<p>A job management system for Python, designed to simplify job scheduling and execution with support for multiple schedulers and plugins.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Written in async for high performance</li> <li>Plugin system for extensibility</li> <li>Scheduler adaptor for various backends</li> <li>Job retrying and pipeline halting on failure</li> <li>Support for cloud-based working directories</li> <li>Built-in support for Google Batch Jobs, Slurm, SGE, SSH, and container schedulers</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install xqute\n</code></pre>"},{"location":"#a-toy-example","title":"A Toy Example","text":"<pre><code>import asyncio\nfrom xqute import Xqute\n\nasync def main():\n    # Initialize Xqute with 3 jobs allowed to run concurrently\n    xqute = Xqute(forks=3)\n    for _ in range(10):\n        await xqute.put(['sleep', '1'])\n    await xqute.run_until_complete()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>Full API documentation is available at: https://pwwang.github.io/xqute/</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#xqute-object","title":"Xqute Object","text":"<p>An <code>Xqute</code> object is initialized as follows:</p> <pre><code>xqute = Xqute(...)\n</code></pre> <p>Available arguments are:</p> <ul> <li><code>scheduler</code>: The scheduler class or name (default: <code>local</code>)</li> <li><code>plugins</code>: Plugins to enable/disable for this session</li> <li><code>workdir</code>: Directory for job metadata (default: <code>./.xqute/</code>)</li> <li><code>forks</code>: Number of jobs allowed to run concurrently</li> <li><code>error_strategy</code>: Strategy for handling errors (e.g., <code>halt</code>, <code>retry</code>)</li> <li><code>num_retries</code>: Maximum number of retries when <code>error_strategy</code> is set to <code>retry</code></li> <li><code>submission_batch</code>: Number of jobs to submit in a batch</li> <li><code>scheduler_opts</code>: Additional keyword arguments for the scheduler</li> <li><code>jobname_prefix</code>: Prefix for job names</li> <li><code>recheck_interval</code>: Interval (in seconds) to recheck job status</li> </ul> <p>Note: The producer must be initialized within an event loop.</p> <p>To add a job to the queue:</p> <pre><code>await xqute.put(['echo', 'Hello, World!'])\n</code></pre>"},{"location":"#using-sge-scheduler","title":"Using SGE Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='sge',\n    forks=100,\n    scheduler_opts={\n        'qsub': '/path/to/qsub',\n        'qdel': '/path/to/qdel',\n        'qstat': '/path/to/qstat',\n        'q': '1-day',  # or qsub_q='1-day'\n    }\n)\n</code></pre> <p>Keyword arguments starting with <code>sge_</code> are interpreted as <code>qsub</code> options. For example:</p> <p><pre><code>'l': ['h_vmem=2G', 'gpu=1']\n</code></pre> will be expanded in the job script as:</p> <pre><code>#$ -l h_vmem=2G\n#$ -l gpu=1\n</code></pre>"},{"location":"#using-slurm-scheduler","title":"Using Slurm Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='slurm',\n    forks=100,\n    scheduler_opts={\n        'sbatch': '/path/to/sbatch',\n        'scancel': '/path/to/scancel',\n        'squeue': '/path/to/squeue',\n        'partition': '1-day',\n        'time': '01:00:00',\n    }\n)\n</code></pre>"},{"location":"#using-ssh-scheduler","title":"Using SSH Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='ssh',\n    forks=100,\n    scheduler_opts={\n        'ssh': '/path/to/ssh',\n        'servers': {\n            'server1': {\n                'user': 'username',\n                'port': 22,\n                'keyfile': '/path/to/keyfile',\n                'ctrl_persist': 600,\n                'ctrl_dir': '/tmp',\n            }\n        }\n    }\n)\n</code></pre> <p>Note: SSH servers must share the same filesystem and use keyfile authentication.</p>"},{"location":"#using-google-batch-jobs-scheduler","title":"Using Google Batch Jobs Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='gbatch',\n    forks=100,\n    scheduler_opts={\n        'project': 'your-gcp-project-id',\n        'location': 'us-central1',\n        'gcloud': '/path/to/gcloud',\n        'taskGroups': [ ... ],\n    }\n)\n</code></pre>"},{"location":"#using-container-scheduler","title":"Using Container Scheduler","text":"<pre><code>xqute = Xqute(\n    scheduler='container',\n    forks=100,\n    scheduler_opts={\n        'image': 'docker://bash:latest',\n        'entrypoint': '/usr/local/bin/bash',\n        'bin': 'docker',\n        'volumes': '/host/path:/container/path',\n        'envs': {'MY_ENV_VAR': 'value'},\n        'remove': True,\n        'bin_args': ['--hostname', 'xqute-container'],\n    }\n)\n</code></pre>"},{"location":"#plugins","title":"Plugins","text":"<p>To create a plugin for <code>xqute</code>, implement the following hooks:</p> <ul> <li><code>def on_init(scheduler)</code>: Called after the scheduler is initialized</li> <li><code>def on_shutdown(scheduler, sig)</code>: Called when the scheduler shuts down</li> <li><code>async def on_job_init(scheduler, job)</code>: Called when a job is initialized</li> <li><code>async def on_job_queued(scheduler, job)</code>: Called when a job is queued</li> <li><code>async def on_job_submitted(scheduler, job)</code>: Called when a job is submitted</li> <li><code>async def on_job_started(scheduler, job)</code>: Called when a job starts running</li> <li><code>async def on_job_polling(scheduler, job, counter)</code>: Called during job status polling</li> <li><code>async def on_job_killing(scheduler, job)</code>: Called when a job is being killed</li> <li><code>async def on_job_killed(scheduler, job)</code>: Called when a job is killed</li> <li><code>async def on_job_failed(scheduler, job)</code>: Called when a job fails</li> <li><code>async def on_job_succeeded(scheduler, job)</code>: Called when a job succeeds</li> <li><code>def on_jobcmd_init(scheduler, job) -&gt; str</code>: Called during job command initialization</li> <li><code>def on_jobcmd_prep(scheduler, job) -&gt; str</code>: Called before the job command runs</li> <li><code>def on_jobcmd_end(scheduler, job) -&gt; str</code>: Called after the job command completes</li> </ul> <p>To implement a hook, use the <code>simplug</code> plugin manager:</p> <pre><code>from xqute import simplug as pm\n\n@pm.impl\ndef on_init(scheduler):\n    ...\n</code></pre>"},{"location":"#implementing-a-scheduler","title":"Implementing a Scheduler","text":"<p>To create a custom scheduler, subclass the <code>Scheduler</code> abstract class and implement the following methods:</p> <pre><code>from xqute import Scheduler\n\nclass MyScheduler(Scheduler):\n    name = 'mysched'\n\n    async def submit_job(self, job):\n        \"\"\"Submit a job and return its unique ID.\"\"\"\n\n    async def kill_job(self, job):\n        \"\"\"Kill a job.\"\"\"\n\n    async def job_is_running(self, job):\n        \"\"\"Check if a job is running.\"\"\"\n</code></pre>"},{"location":"api/xqute.defaults/","title":"xqute.defaults","text":"module &lt;/&gt; <p>Default settings and utilities for xqute</p> Attributes <ul> <li><code>DEFAULT_ERROR_STRATEGY</code> (str) \u2014 The default strategy when there iserror happened </li> <li><code>DEFAULT_JOB_CMD_WRAPPER_SHELL</code> \u2014 The default shell for job wrapper</li> <li><code>DEFAULT_NUM_RETRIES</code> (int) \u2014 Default number of retries whenDEFAULT_ERROR_STRATEGY is retry </li> <li><code>DEFAULT_SCHEDULER_FORKS</code> (int) \u2014 Default number of job forks for scheduler</li> <li><code>DEFAULT_SUBMISSION_BATCH</code> (int) \u2014 Default consumer workers</li> <li><code>DEFAULT_WORKDIR</code> \u2014 The default work directory for jobs to save the metadata</li> </ul> Classes <ul> <li><code>JobErrorStrategy</code> \u2014 The strategy when error happen from jobs&lt;/&gt;</li> <li><code>JobStatus</code> \u2014 The status of a job&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_jobcmd_wrapper_init</code><code>(</code><code>local</code>, <code>remove_jid_after_done</code><code>)</code> (str) \u2014 Get the job command wrapper initialization script&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The strategy when error happen from jobs</p> Attributes <ul> <li><code>HALT</code> \u2014 halt the whole program</li> <li><code>IGNORE</code> \u2014 ignore and run next jobs</li> <li><code>RETRY</code> \u2014 retry the job</li> </ul> class &lt;/&gt; <p>The status of a job</p><p>Life cycles: ........................queued in scheduler INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; FINISHED (FAILED) INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; KILLING -&gt; FINISHED INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; KILLING -&gt; FINISHED INIT -&gt; QUEUED -&gt; (CANCELLED)</p> Attributes <ul> <li><code>FAILED</code> \u2014 When a job is failed</li> <li><code>FINISHED</code> \u2014 When a job is finished</li> <li><code>INIT</code> \u2014 When a job is initialized</li> <li><code>KILLING</code> \u2014 When a job is being killed</li> <li><code>QUEUED</code> \u2014 When a job is queued</li> <li><code>RETRYING</code> \u2014 When a job is to be retried</li> <li><code>RUNNING</code> \u2014 When a job is running</li> <li><code>SUBMITTED</code> \u2014 When a job is submitted</li> </ul> Methods <ul> <li><code>get_name</code><code>(</code><code>*statuses</code><code>)</code> (Union) \u2014 Get the name of the status&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Get the name of the status</p> Parameters <ul> <li><code>*statuses</code> (int) \u2014 The status values</li> </ul> Returns (Union) <p>The name of the status if a single status is passed, otherwisea tuple of names</p> function &lt;/&gt; <p>Get the job command wrapper initialization script</p> Parameters <ul> <li><code>local</code> (bool) \u2014 Whether the job is running locally</li> <li><code>remove_jid_after_done</code> (bool) \u2014 Whether to remove the remote job id fileafter the job is done </li> </ul> Returns (str) <p>The job command wrapper initialization script</p>"},{"location":"api/xqute.defaults/#xqutedefaults","title":"xqute.defaults","text":""},{"location":"api/xqute.defaults/#xqutedefaultsjoberrorstrategy","title":"<code>xqute.defaults.</code><code>JobErrorStrategy</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.defaults/#xqutedefaultsjobstatus","title":"<code>xqute.defaults.</code><code>JobStatus</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.defaults/#xqutedefaultsjobstatusget_name","title":"<code>get_name</code><code>(</code><code>*statuses</code><code>)</code>","text":""},{"location":"api/xqute.defaults/#xqutedefaultsget_jobcmd_wrapper_init","title":"<code>xqute.defaults.</code><code>get_jobcmd_wrapper_init</code><code>(</code><code>local</code>, <code>remove_jid_after_done</code><code>)</code>","text":""},{"location":"api/xqute.job/","title":"xqute.job","text":"module &lt;/&gt; <p>Job to execute</p> Classes <ul> <li><code>Job</code> \u2014 The class for job&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The class for job</p> Attributes <ul> <li><code>jid</code> (int | str | none) \u2014 Get the jid of the job in scheduler system&lt;/&gt;</li> <li><code>jid_file</code> (SpecPath) \u2014 The jid file of the job&lt;/&gt;</li> <li><code>rc</code> (int) \u2014 The return code of the job&lt;/&gt;</li> <li><code>rc_file</code> (SpecPath) \u2014 The rc file of the job&lt;/&gt;</li> <li><code>retry_dir</code> (SpecPath) \u2014 The retry directory of the job&lt;/&gt;</li> <li><code>status</code> (int) \u2014 Query the status of the jobIf the job is submitted, try to query it from the status file Make sure the status is updated by trap in wrapped script &lt;/&gt;</li> <li><code>status_file</code> (SpecPath) \u2014 The status file of the job&lt;/&gt;</li> <li><code>stderr_file</code> (SpecPath) \u2014 The stderr file of the job&lt;/&gt;</li> <li><code>stdout_file</code> (SpecPath) \u2014 The stdout file of the job&lt;/&gt;</li> </ul> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> <li><code>error_retry</code> (bool | none, optional) \u2014 Whether we should retry if error happened</li> <li><code>num_retries</code> (int | none, optional) \u2014 Total number of retries</li> <li><code>metadir</code> \u2014 The meta directory of the Job</li> </ul> Methods <ul> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 repr of the job&lt;/&gt;</li> <li><code>clean</code><code>(</code><code>retry</code><code>)</code> \u2014 Clean up the meta files&lt;/&gt;</li> </ul> method &lt;/&gt; <p>repr of the job</p> method &lt;/&gt; <p>Clean up the meta files</p> Parameters <ul> <li><code>retry</code> (optional) \u2014 Whether clean it for retrying</li> </ul>"},{"location":"api/xqute.job/#xqutejob","title":"xqute.job","text":""},{"location":"api/xqute.job/#xqutejobjob","title":"<code>xqute.job.</code><code>Job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>workdir</code>, <code>error_retry=None</code>, <code>num_retries=None</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.job/#xqutejobjobrepr","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.job/#xqutejobjobclean","title":"<code>clean</code><code>(</code><code>retry=False</code><code>)</code>","text":""},{"location":"api/xqute/","title":"xqute","text":"package &lt;/&gt; <p>A job management system for python</p> module &lt;/&gt; <p>The xqute module</p> Classes <ul> <li><code>Xqute</code> \u2014 The main class of the package&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Utilities for xqute</p> Classes <ul> <li><code>DuplicateFilter</code> \u2014 Filter instances are used to perform arbitrary filtering of LogRecords.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Hook specifications for scheduler plugins</p> Functions <ul> <li><code>on_init</code><code>(</code><code>xqute</code><code>)</code> \u2014 When xqute is initialized&lt;/&gt;</li> <li><code>on_job_failed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is failed&lt;/&gt;</li> <li><code>on_job_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is initialized&lt;/&gt;</li> <li><code>on_job_killed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is killed&lt;/&gt;</li> <li><code>on_job_killing</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is being killed&lt;/&gt;</li> <li><code>on_job_polling</code><code>(</code><code>scheduler</code>, <code>job</code>, <code>counter</code><code>)</code> \u2014 When the system is polling job status&lt;/&gt;</li> <li><code>on_job_queued</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is queued&lt;/&gt;</li> <li><code>on_job_started</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job starts to run.&lt;/&gt;</li> <li><code>on_job_submitted</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is submitted&lt;/&gt;</li> <li><code>on_job_submitting</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is to be submitted&lt;/&gt;</li> <li><code>on_job_succeeded</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is succeeded&lt;/&gt;</li> <li><code>on_jobcmd_end</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command finishes and after the postscript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command wrapper script is initialized before the prescript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_prep</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command right about to be runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>. For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins. &lt;/&gt;</li> <li><code>on_shutdown</code><code>(</code><code>xqute</code>, <code>sig</code><code>)</code> \u2014 When xqute is shutting down&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Job to execute</p> Classes <ul> <li><code>Job</code> \u2014 The class for job&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to schedule jobs</p> Classes <ul> <li><code>Scheduler</code><code>(</code><code>workdir</code>, <code>forks</code>, <code>error_strategy</code>, <code>num_retries</code>, <code>prescript</code>, <code>postscript</code>, <code>jobname_prefix</code>, <code>recheck_interval</code>, <code>cwd</code>, <code>**kwargs</code><code>)</code> \u2014 The abstract class for scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides the SpecPath and MountedPath classes.</p><p>It is used to represent paths of jobs and it is useful when a job is running in a remote system (a VM, a container, etc.), where we need to mount the paths into the remote system (MountedPath).</p> <p>But in the system where this framework is running, we need to use the paths (specified directly) that are used in the framework, where we also need to carry the information of the mounted path (SpecPath).</p> <p>The module provides two main abstract base classes: <ul><li>- <code>MountedPath</code>: Represents a path as it appears in the remote execution environment.</li><li>- <code>SpecPath</code>: Represents a path as it appears in the local environment where the</li></ul>framework runs.</p><p>Both classes have implementations for local paths and various cloud storage paths, including: <ul><li>- Google Cloud Storage</li><li>- Azure Blob Storage</li><li>- Amazon S3</li></ul><p>These classes maintain the relationship between the local and remote pathrepresentations, allowing transparent path operations while preserving both path contexts.</p> Classes <ul> <li><code>MountedPath</code> (xqute.path.mountedlocalpath | xqute.path.mountedcloudpath) \u2014 A router class to instantiate the correct path based on the path typefor the mounted path. &lt;/&gt;</li> <li><code>MountedLocalPath</code> \u2014 A class to represent a mounted local path&lt;/&gt;</li> <li><code>MountedCloudPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 A class to represent a mounted cloud path&lt;/&gt;</li> <li><code>MountedGSPath</code> (Union) \u2014 A class to represent a mounted Google Cloud Storage path&lt;/&gt;</li> <li><code>MountedAzureBlobPath</code> (Union) \u2014 A class to represent a mounted Azure Blob Storage path&lt;/&gt;</li> <li><code>MountedS3Path</code> (Union) \u2014 A class to represent a mounted Amazon S3 path&lt;/&gt;</li> <li><code>SpecPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A router class to instantiate the correct path based on the path typefor the spec path. &lt;/&gt;</li> <li><code>SpecLocalPath</code> \u2014 A class to represent a spec local path&lt;/&gt;</li> <li><code>SpecCloudPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 A class to represent a spec cloud path&lt;/&gt;</li> <li><code>SpecGSPath</code> (Union) \u2014 A class to represent a spec Google Cloud Storage path&lt;/&gt;</li> <li><code>SpecAzureBlobPath</code> (Union) \u2014 A class to represent a spec Azure Blob Storage path&lt;/&gt;</li> <li><code>SpecS3Path</code> (Union) \u2014 A class to represent a spec Amazon S3 path&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Default settings and utilities for xqute</p> Attributes <ul> <li><code>DEFAULT_ERROR_STRATEGY</code> (str) \u2014 The default strategy when there iserror happened </li> <li><code>DEFAULT_JOB_CMD_WRAPPER_SHELL</code> \u2014 The default shell for job wrapper</li> <li><code>DEFAULT_NUM_RETRIES</code> (int) \u2014 Default number of retries whenDEFAULT_ERROR_STRATEGY is retry </li> <li><code>DEFAULT_SCHEDULER_FORKS</code> (int) \u2014 Default number of job forks for scheduler</li> <li><code>DEFAULT_SUBMISSION_BATCH</code> (int) \u2014 Default consumer workers</li> <li><code>DEFAULT_WORKDIR</code> \u2014 The default work directory for jobs to save the metadata</li> </ul> Classes <ul> <li><code>JobErrorStrategy</code> \u2014 The strategy when error happen from jobs&lt;/&gt;</li> <li><code>JobStatus</code> \u2014 The status of a job&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_jobcmd_wrapper_init</code><code>(</code><code>local</code>, <code>remove_jid_after_done</code><code>)</code> (str) \u2014 Get the job command wrapper initialization script&lt;/&gt;</li> </ul> package &lt;/&gt; <p>Builtin schedulers</p> Functions <ul> <li><code>get_scheduler</code><code>(</code><code>scheduler</code><code>)</code> (Type) \u2014 Get the scheduler class&lt;/&gt;</li> </ul>"},{"location":"api/xqute/#xqute","title":"xqute","text":""},{"location":"api/xqute/#xqutexqute","title":"xqute.xqute","text":""},{"location":"api/xqute/#xquteutils","title":"xqute.utils","text":""},{"location":"api/xqute/#xquteplugin","title":"xqute.plugin","text":""},{"location":"api/xqute/#xqutejob","title":"xqute.job","text":""},{"location":"api/xqute/#xqutescheduler","title":"xqute.scheduler","text":""},{"location":"api/xqute/#xqutepath","title":"xqute.path","text":""},{"location":"api/xqute/#xqutedefaults","title":"xqute.defaults","text":""},{"location":"api/xqute/#xquteschedulers","title":"xqute.schedulers","text":""},{"location":"api/xqute.path/","title":"xqute.path","text":"module &lt;/&gt; <p>Provides the SpecPath and MountedPath classes.</p><p>It is used to represent paths of jobs and it is useful when a job is running in a remote system (a VM, a container, etc.), where we need to mount the paths into the remote system (MountedPath).</p> <p>But in the system where this framework is running, we need to use the paths (specified directly) that are used in the framework, where we also need to carry the information of the mounted path (SpecPath).</p> <p>The module provides two main abstract base classes: <ul><li>- <code>MountedPath</code>: Represents a path as it appears in the remote execution environment.</li><li>- <code>SpecPath</code>: Represents a path as it appears in the local environment where the</li></ul>framework runs.</p><p>Both classes have implementations for local paths and various cloud storage paths, including: <ul><li>- Google Cloud Storage</li><li>- Azure Blob Storage</li><li>- Amazon S3</li></ul><p>These classes maintain the relationship between the local and remote pathrepresentations, allowing transparent path operations while preserving both path contexts.</p> Classes <ul> <li><code>MountedPath</code> (xqute.path.mountedlocalpath | xqute.path.mountedcloudpath) \u2014 A router class to instantiate the correct path based on the path typefor the mounted path. &lt;/&gt;</li> <li><code>MountedLocalPath</code> \u2014 A class to represent a mounted local path&lt;/&gt;</li> <li><code>MountedCloudPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 A class to represent a mounted cloud path&lt;/&gt;</li> <li><code>MountedGSPath</code> (Union) \u2014 A class to represent a mounted Google Cloud Storage path&lt;/&gt;</li> <li><code>MountedAzureBlobPath</code> (Union) \u2014 A class to represent a mounted Azure Blob Storage path&lt;/&gt;</li> <li><code>MountedS3Path</code> (Union) \u2014 A class to represent a mounted Amazon S3 path&lt;/&gt;</li> <li><code>SpecPath</code> (xqute.path.speclocalpath | xqute.path.speccloudpath) \u2014 A router class to instantiate the correct path based on the path typefor the spec path. &lt;/&gt;</li> <li><code>SpecLocalPath</code> \u2014 A class to represent a spec local path&lt;/&gt;</li> <li><code>SpecCloudPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Union) \u2014 A class to represent a spec cloud path&lt;/&gt;</li> <li><code>SpecGSPath</code> (Union) \u2014 A class to represent a spec Google Cloud Storage path&lt;/&gt;</li> <li><code>SpecAzureBlobPath</code> (Union) \u2014 A class to represent a spec Azure Blob Storage path&lt;/&gt;</li> <li><code>SpecS3Path</code> (Union) \u2014 A class to represent a spec Amazon S3 path&lt;/&gt;</li> </ul> class &lt;/&gt; <p>A router class to instantiate the correct path based on the path typefor the mounted path.</p> <p>This abstract base class serves as a factory that creates appropriate mounted path instances based on the input path type. It represents a path as it exists in a remote execution environment (e.g., container, VM) while maintaining a reference to the corresponding path in the local environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment (SpecPath).</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; # Create a mounted path with corresponding spec path&gt;&gt;&gt; mounted_path = MountedPath(\n&gt;&gt;&gt;   \"/container/data/file.txt\", spec=\"/local/data/file.txt\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; str(mounted_path)\n'/container/data/file.txt'\n&gt;&gt;&gt; str(mounted_path.spec)\n'/local/data/file.txt'\n</code></pre> <pre><code>&gt;&gt;&gt; # Create a GCS mounted path\n&gt;&gt;&gt; gs_path = MountedPath(\"gs://bucket/file.txt\", spec=\"/local/file.txt\")\n&gt;&gt;&gt; type(gs_path)\n&lt;class 'xqute.path.MountedGSPath'&gt;\n</code></pre> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate MountedPath subclass based on the path type) \u2014 Factory method to create the appropriate MountedPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> </ul> staticmethod &lt;/&gt; <p>Factory method to create the appropriate MountedPath subclass instance.</p> Parameters <ul> <li><code>path</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The path string or object representing the mounted path location.</li> <li><code>spec</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> </ul> Returns (An instance of the appropriate MountedPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> class &lt;/&gt; Bases xqute.path.MountedPath abc.ABC pathlib.PosixPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a mounted local path</p><p>This class represents a path in a local filesystem as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedLocalPath(\"/container/data/file.txt\",...                               spec=\"/local/data/file.txt\")\n&gt;&gt;&gt; str(mounted_path)\n'/container/data/file.txt'\n&gt;&gt;&gt; str(mounted_path.spec)\n'/local/data/file.txt'\n&gt;&gt;&gt; mounted_path.name\n'file.txt'\n</code></pre> Classes <ul> <li><code>ABCMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new MountedLocalPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> \u2014 Return the string representation of the path, suitable forpassing to system calls. &lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (MountedPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> \u2014 Return the path as a 'file' URI.&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern. &lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> \u2014 True if the path is absolute (has both a root and, if applicable,a drive). &lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> \u2014 Whether this path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files). &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> \u2014 Whether this path is a symbolic link.&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Return True if this path matches the given pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does. &lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> \u2014 Open the file in bytes mode, read it, and close the file.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code><code>)</code> \u2014 Open the file in text mode, read it, and close the file.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> \u2014 Return the path to which the symbolic link points.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it. &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree. &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()). &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does. &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink. &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead. &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> \u2014 Walk the directory tree from this directory, similar to os.walk().&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (MountedPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> (MountedPath) \u2014 Create a new path by replacing all segments with the given segments.&lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (MountedPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Open the file in bytes mode, write to it, and close the file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file in text mode, write to it, and close the file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Return the string representation of the path, suitable forpassing to system calls.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the path as a 'file' URI.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive).</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Return True if this path matches the given pattern.</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.</p> method &lt;/&gt; <p>Whether this path is a directory.</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a symbolic link.</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file.</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk().</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Return the path to which the symbolic link points.</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist.</p> method &lt;/&gt; <p>Create a new directory at this given path.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty.</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> class &lt;/&gt; <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> staticmethod &lt;/&gt; <p>Create a new MountedLocalPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the mounted local path.</li> <li><code>spec</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns <p>A new MountedLocalPath instance.</p> method &lt;/&gt; <p>Create a new path by replacing all segments with the given segments.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to use in the new path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the specified segments.</p> Raises <ul> <li><code>NotImplementedError</code> \u2014 If Python version is lower than 3.10.</li> </ul> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the name changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the suffix changed in both    the mounted path and spec path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segments appended to both    the mounted path and spec path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted path with the segment appended.</p> abstract class &lt;/&gt; Bases xqute.path.MountedPath abc.ABC cloudpathlib.cloudpath.CloudPath <p>A class to represent a mounted cloud path</p><p>This class represents a cloud storage path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",...                          spec=\"gs://local-bucket/file.txt\")\n&gt;&gt;&gt; str(mounted_path)\n'gs://bucket/file.txt'\n&gt;&gt;&gt; str(mounted_path.spec)\n'gs://local-bucket/file.txt'\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new MountedCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (MountedPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (Generator) \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (Self) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> (Generator) \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> abstract method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> abstract method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> staticmethod &lt;/&gt; <p>Create a new MountedCloudPath instance.</p> Parameters <ul> <li><code>path</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The path string or object representing the mounted cloud path.</li> <li><code>spec</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> </ul> Returns <p>A new MountedCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p> class &lt;/&gt; Bases xqute.path.MountedCloudPath xqute.path.MountedPath abc.ABC yunpath.patch.GSPath cloudpathlib.gs.gspath.GSPath cloudpathlib.cloudpath.CloudPath <p>A class to represent a mounted Google Cloud Storage path</p><p>This class represents a Google Cloud Storage path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",...                          spec=\"gs://local-bucket/file.txt\")\n&gt;&gt;&gt; isinstance(mounted_path, MountedGSPath)\nTrue\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new MountedCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (MountedPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Whether this path is a symbolic link. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (GSPath) \u2014 Return the path to which the symbolic link points. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (GSPath) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> (GSPath) \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a symbolic link. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the path to which the symbolic link points. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> staticmethod &lt;/&gt; <p>Create a new MountedCloudPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The path string or object representing the mounted cloud path.</li> <li><code>spec</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns <p>A new MountedCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p> class &lt;/&gt; Bases xqute.path.MountedCloudPath xqute.path.MountedPath abc.ABC cloudpathlib.azure.azblobpath.AzureBlobPath cloudpathlib.cloudpath.CloudPath <p>A class to represent a mounted Azure Blob Storage path</p><p>This class represents an Azure Blob Storage path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"az://container/blob\",...                          spec=\"az://local-container/blob\")\n&gt;&gt;&gt; isinstance(mounted_path, MountedAzureBlobPath)\nTrue\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new MountedCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (MountedPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (Generator) \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (AzureBlobPath) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (Self) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> (Generator) \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> staticmethod &lt;/&gt; <p>Create a new MountedCloudPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The path string or object representing the mounted cloud path.</li> <li><code>spec</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns <p>A new MountedCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p> class &lt;/&gt; Bases xqute.path.MountedCloudPath xqute.path.MountedPath abc.ABC cloudpathlib.s3.s3path.S3Path cloudpathlib.cloudpath.CloudPath <p>A class to represent a mounted Amazon S3 path</p><p>This class represents an Amazon S3 path as it appears in a remote execution environment, while maintaining a reference to its corresponding path in the framework's environment.</p> Attributes <ul> <li><code>_spec</code> \u2014 The corresponding path in the local environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>spec</code> \u2014 Get the corresponding spec path in the local environment.&lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; mounted_path = MountedPath(\"s3://bucket/key\",...                          spec=\"s3://local-bucket/key\")\n&gt;&gt;&gt; isinstance(mounted_path, MountedS3Path)\nTrue\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the MountedPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new MountedCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the MountedPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (MountedPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_mounted</code><code>(</code><code>)</code> (bool) \u2014 Check if this path is actually mounted (different from spec path).&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (Generator) \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (Self) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> (Generator) \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Check if this path is actually mounted (different from spec path).</p> Returns (bool) <p>True if the mounted path is different from the spec path, Falseotherwise.</p> method &lt;/&gt; <p>Generate a string representation of the MountedPath.</p> Returns (str) <p>A string showing the class name, path, and spec path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two MountedPath objects are equal if they have the same path string and the same spec path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the MountedPath.</p> Returns (int) <p>A hash value based on the path string and spec path string.</p> staticmethod &lt;/&gt; <p>Create a new MountedCloudPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The path string or object representing the mounted cloud path.</li> <li><code>spec</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath | none, optional) \u2014 The path string or object representing the corresponding spec path.If None, the mounted path itself will be used as the spec path. </li> </ul> Returns <p>A new MountedCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (MountedPath) <p>A new mounted cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p> class &lt;/&gt; <p>A router class to instantiate the correct path based on the path typefor the spec path.</p> <p>This abstract base class serves as a factory that creates appropriate spec path instances based on the input path type. It represents a path in the local environment where the framework runs, while maintaining a reference to the corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; # Create a spec path with corresponding mounted path&gt;&gt;&gt; spec_path = SpecPath(\n&gt;&gt;&gt;   \"/local/data/file.txt\", mounted=\"/container/data/file.txt\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; str(spec_path)\n'/local/data/file.txt'\n&gt;&gt;&gt; str(spec_path.mounted)\n'/container/data/file.txt'\n</code></pre> <pre><code>&gt;&gt;&gt; # Create a GCS spec path\n&gt;&gt;&gt; gs_path = SpecPath(\n&gt;&gt;&gt;   \"gs://bucket/file.txt\", mounted=\"gs://container-bucket/file.txt\"\n&gt;&gt;&gt; )\n&gt;&gt;&gt; type(gs_path)\n&lt;class 'xqute.path.SpecGSPath'&gt;\n</code></pre> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (An instance of the appropriate SpecPath subclass based on the path type) \u2014 Factory method to create the appropriate SpecPath subclass instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> </ul> staticmethod &lt;/&gt; <p>Factory method to create the appropriate SpecPath subclass instance.</p> Parameters <ul> <li><code>path</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The path string or object representing the spec path.</li> <li><code>mounted</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> </ul> Returns (An instance of the appropriate SpecPath subclass based on the path type) <p>ss s s</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> class &lt;/&gt; Bases xqute.path.SpecPath abc.ABC pathlib.PosixPath pathlib.Path pathlib.PurePosixPath pathlib.PurePath <p>A class to represent a spec local path</p><p>This class represents a path in the local filesystem as it appears in the framework's environment, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> \u2014 The concatenation of the drive and root, or ''.&lt;/&gt;</li> <li><code>drive</code> \u2014 The drive prefix (letter or UNC path), if any.&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> \u2014 The final path component, if any.&lt;/&gt;</li> <li><code>parent</code> \u2014 Get the parent directory of this path.&lt;/&gt;</li> <li><code>parents</code> \u2014 A sequence of this path's logical parents.&lt;/&gt;</li> <li><code>parts</code> \u2014 An object providing sequence-like access to thecomponents in the filesystem path. &lt;/&gt;</li> <li><code>root</code> \u2014 The root of the path, if any.&lt;/&gt;</li> <li><code>stem</code> \u2014 The final path component, minus its last suffix.&lt;/&gt;</li> <li><code>suffix</code> \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt' &lt;/&gt;</li> <li><code>suffixes</code> \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz'] &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecLocalPath(\"/local/data/file.txt\",...                         mounted=\"/container/data/file.txt\")\n&gt;&gt;&gt; str(spec_path)\n'/local/data/file.txt'\n&gt;&gt;&gt; str(spec_path.mounted)\n'/container/data/file.txt'\n&gt;&gt;&gt; spec_path.name\n'file.txt'\n</code></pre> Classes <ul> <li><code>ABCMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__bytes__</code><code>(</code><code>)</code> \u2014 Return the bytes representation of the path.  This is onlyrecommended to use under Unix. &lt;/&gt;</li> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new SpecLocalPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__str__</code><code>(</code><code>)</code> \u2014 Return the string representation of the path, suitable forpassing to system calls. &lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>key</code><code>)</code> (SpecPath) \u2014 Implement the / operator for paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_posix</code><code>(</code><code>)</code> \u2014 Return the string representation of the path with forward (/)slashes. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> \u2014 Return the path as a 'file' URI.&lt;/&gt;</li> <li><code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks</code><code>)</code> \u2014 Change the permissions of the path, like os.chmod().&lt;/&gt;</li> <li><code>cwd</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the current working directory.&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>expanduser</code><code>(</code><code>)</code> \u2014 Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser) &lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern. &lt;/&gt;</li> <li><code>group</code><code>(</code><code>)</code> \u2014 Return the group name of the file gid.&lt;/&gt;</li> <li><code>hardlink_to</code><code>(</code><code>target</code><code>)</code> \u2014 Make this path a hard link pointing to the same file as target.&lt;/&gt;</li> <li><code>home</code><code>(</code><code>)</code> \u2014 Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')). &lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> \u2014 True if the path is absolute (has both a root and, if applicable,a drive). &lt;/&gt;</li> <li><code>is_block_device</code><code>(</code><code>)</code> \u2014 Whether this path is a block device.&lt;/&gt;</li> <li><code>is_char_device</code><code>(</code><code>)</code> \u2014 Whether this path is a character device.&lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>)</code> \u2014 Whether this path is a directory.&lt;/&gt;</li> <li><code>is_fifo</code><code>(</code><code>)</code> \u2014 Whether this path is a FIFO.&lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>)</code> \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files). &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction.&lt;/&gt;</li> <li><code>is_mount</code><code>(</code><code>)</code> \u2014 Check if this path is a mount point&lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code> \u2014 Return True if the path is relative to another path or False.&lt;/&gt;</li> <li><code>is_reserved</code><code>(</code><code>)</code> \u2014 Return True if the path contains one of the special names reservedby the system, if any. &lt;/&gt;</li> <li><code>is_socket</code><code>(</code><code>)</code> \u2014 Whether this path is a socket.&lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> \u2014 Whether this path is a symbolic link.&lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Join path components to this path.&lt;/&gt;</li> <li><code>lchmod</code><code>(</code><code>mode</code><code>)</code> \u2014 Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's. &lt;/&gt;</li> <li><code>lstat</code><code>(</code><code>)</code> \u2014 Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's. &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Return True if this path matches the given pattern.&lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>mode</code>, <code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does. &lt;/&gt;</li> <li><code>owner</code><code>(</code><code>)</code> \u2014 Return the login name of the file owner.&lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> \u2014 Open the file in bytes mode, read it, and close the file.&lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code><code>)</code> \u2014 Open the file in text mode, read it, and close the file.&lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> \u2014 Return the path to which the symbolic link points.&lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up</code><code>)</code> \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it. &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code><code>)</code> \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree. &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty.&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()). &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does. &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory</code><code>)</code> \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink. &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>mode</code>, <code>exist_ok</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist.&lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead. &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> \u2014 Walk the directory tree from this directory, similar to os.walk().&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> (SpecPath) \u2014 Return a new path with the name changed.&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> (SpecPath) \u2014 Create a new path by replacing all segments with the given segments.&lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> (SpecPath) \u2014 Return a new path with the stem changed.&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> (SpecPath) \u2014 Return a new path with the suffix changed.&lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2014 Open the file in bytes mode, write to it, and close the file.&lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> \u2014 Open the file in text mode, write to it, and close the file.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Return the string representation of the path, suitable forpassing to system calls.</p> method &lt;/&gt; <p>Return the string representation of the path with forward (/)slashes.</p> method &lt;/&gt; <p>Return the bytes representation of the path.  This is onlyrecommended to use under Unix.</p> method &lt;/&gt; <p>Return the path as a 'file' URI.</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive).</p> method &lt;/&gt; <p>Return True if the path contains one of the special names reservedby the system, if any.</p> method &lt;/&gt; <p>Return True if this path matches the given pattern.</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.</p> method &lt;/&gt; <p>Like stat(), except if the path points to a symlink, the symlink'sstatus information is returned, rather than its target's.</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.</p> method &lt;/&gt; <p>Whether this path is a directory.</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).</p> method &lt;/&gt; <p>Check if this path is a mount point</p> method &lt;/&gt; <p>Whether this path is a symbolic link.</p> method &lt;/&gt; <p>Whether this path is a junction.</p> method &lt;/&gt; <p>Whether this path is a block device.</p> method &lt;/&gt; <p>Whether this path is a character device.</p> method &lt;/&gt; <p>Whether this path is a FIFO.</p> method &lt;/&gt; <p>Whether this path is a socket.</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file.</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file.</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file.</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk().</p> classmethod &lt;/&gt; <p>Return a new path pointing to the current working directory.</p> classmethod &lt;/&gt; <p>Return a new path pointing to the user's home directory (asreturned by os.path.expanduser('~')).</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.</p> method &lt;/&gt; <p>Return the login name of the file owner.</p> method &lt;/&gt; <p>Return the group name of the file gid.</p> method &lt;/&gt; <p>Return the path to which the symbolic link points.</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist.</p> method &lt;/&gt; <p>Create a new directory at this given path.</p> method &lt;/&gt; <p>Change the permissions of the path, like os.chmod().</p> method &lt;/&gt; <p>Like chmod(), except if the path points to a symlink, the symlink'spermissions are changed, rather than its target's.</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty.</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.</p> method &lt;/&gt; <p>Make this path a hard link pointing to the same file as target.</p><p>Note the order of arguments (self, target) is the reverse of os.link's.</p> method &lt;/&gt; <p>Return a new path with expanded ~ and ~user constructs(as returned by os.path.expanduser)</p> class &lt;/&gt; <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> staticmethod &lt;/&gt; <p>Create a new SpecLocalPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec local path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns <p>A new SpecLocalPath instance.</p> method &lt;/&gt; <p>Create a new path by replacing all segments with the given segments.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to use in the new path.</li> </ul> Returns (SpecPath) <p>A new spec path with the specified segments.</p> method &lt;/&gt; <p>Return a new path with the name changed.</p> Parameters <ul> <li><code>name</code> \u2014 The new name for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the name changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the suffix changed.</p> Parameters <ul> <li><code>suffix</code> \u2014 The new suffix for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the suffix changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Return a new path with the stem changed.</p><p>The stem is the filename without the suffix.</p> Parameters <ul> <li><code>stem</code> \u2014 The new stem for the path.</li> </ul> Returns (SpecPath) <p>A new spec path with the stem changed in both    the spec path and mounted path.</p> method &lt;/&gt; <p>Join path components to this path.</p> Parameters <ul> <li><code>*pathsegments</code> \u2014 The path segments to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segments appended to both    the spec path and mounted path.</p> method &lt;/&gt; <p>Implement the / operator for paths.</p> Parameters <ul> <li><code>key</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec path with the segment appended.</p> abstract class &lt;/&gt; Bases xqute.path.SpecPath abc.ABC cloudpathlib.cloudpath.CloudPath <p>A class to represent a spec cloud path</p><p>This class represents a cloud storage path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",...                    mounted=\"gs://container-bucket/file.txt\")\n&gt;&gt;&gt; str(spec_path)\n'gs://bucket/file.txt'\n&gt;&gt;&gt; str(spec_path.mounted)\n'gs://container-bucket/file.txt'\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new SpecCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (SpecPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (Generator) \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (Self) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> (Generator) \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> abstract method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> abstract method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> staticmethod &lt;/&gt; <p>Create a new SpecCloudPath instance.</p> Parameters <ul> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec cloud path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> </ul> Returns <p>A new SpecCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p> class &lt;/&gt; Bases xqute.path.SpecCloudPath xqute.path.SpecPath abc.ABC yunpath.patch.GSPath cloudpathlib.gs.gspath.GSPath cloudpathlib.cloudpath.CloudPath <p>A class to represent a spec Google Cloud Storage path</p><p>This class represents a Google Cloud Storage path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",...                    mounted=\"gs://container-bucket/file.txt\")\n&gt;&gt;&gt; isinstance(spec_path, SpecGSPath)\nTrue\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new SpecCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (SpecPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_symlink</code><code>(</code><code>)</code> (bool) \u2014 Whether this path is a symbolic link. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>readlink</code><code>(</code><code>)</code> (GSPath) \u2014 Return the path to which the symbolic link points. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (GSPath) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> (stat_result) \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>symlink_to</code><code>(</code><code>target</code><code>)</code> (GSPath) \u2014 Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a symbolic link. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the path to which the symbolic link points. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make this path a symlink pointing to the target path.Note the order of arguments (link, target) is the reverse of os.symlink.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> staticmethod &lt;/&gt; <p>Create a new SpecCloudPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec cloud path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns <p>A new SpecCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p> class &lt;/&gt; Bases xqute.path.SpecCloudPath xqute.path.SpecPath abc.ABC cloudpathlib.azure.azblobpath.AzureBlobPath cloudpathlib.cloudpath.CloudPath <p>A class to represent a spec Azure Blob Storage path</p><p>This class represents an Azure Blob Storage path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"az://container/blob\",...                    mounted=\"az://remote-container/blob\")\n&gt;&gt;&gt; isinstance(spec_path, SpecAzureBlobPath)\nTrue\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new SpecCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (SpecPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (Generator) \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (AzureBlobPath) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (Self) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> (Generator) \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> staticmethod &lt;/&gt; <p>Create a new SpecCloudPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec cloud path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns <p>A new SpecCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p> class &lt;/&gt; Bases xqute.path.SpecCloudPath xqute.path.SpecPath abc.ABC cloudpathlib.s3.s3path.S3Path cloudpathlib.cloudpath.CloudPath <p>A class to represent a spec Amazon S3 path</p><p>This class represents an Amazon S3 path as it appears in the local environment where the framework runs, while maintaining a reference to its corresponding path in the remote execution environment.</p> Attributes <ul> <li><code>_mounted</code> \u2014 The corresponding path in the remote execution environment.</li> <li><code>anchor</code> (str) \u2014 The concatenation of the drive and root, or ''. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>drive</code> (str) \u2014 The drive prefix (letter or UNC path), if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>mounted</code> \u2014 Get the corresponding mounted path in the remote environment.&lt;/&gt;</li> <li><code>name</code> (str) \u2014 The final path component, if any. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parent</code> \u2014 The logical parent of the path. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parents</code> (Tuple) \u2014 A sequence of this path's logical parents. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>parts</code> (Tuple) \u2014 An object providing sequence-like access to thecomponents in the filesystem path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stem</code> (str) \u2014 The final path component, minus its last suffix. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>suffix</code> (str) \u2014 The final component's last suffix, if any.This includes the leading period. For example: '.txt'  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>suffixes</code> (List) \u2014 A list of the final component's suffixes, if any.These include the leading periods. For example: ['.tar', '.gz']  (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> Examples <pre><code>&gt;&gt;&gt; spec_path = SpecPath(\"s3://bucket/key\",...                    mounted=\"s3://remote-bucket/key\")\n&gt;&gt;&gt; isinstance(spec_path, SpecS3Path)\nTrue\n</code></pre> Classes <ul> <li><code>CloudPathMeta</code> \u2014 Metaclass for defining Abstract Base Classes (ABCs).&lt;/&gt;</li> </ul> Methods <ul> <li><code>__eq__</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Check equality with another path object.&lt;/&gt;</li> <li><code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code> \u2014 Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>__get_validators__</code><code>(</code><code>)</code> (Generator) \u2014 Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types &lt;/&gt;</li> <li><code>__hash__</code><code>(</code><code>)</code> (int) \u2014 Generate a hash for the SpecPath.&lt;/&gt;</li> <li><code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a new SpecCloudPath instance.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Generate a string representation of the SpecPath.&lt;/&gt;</li> <li><code>__truediv__</code><code>(</code><code>other</code><code>)</code> (SpecPath) \u2014 Implement the / operator for cloud paths.&lt;/&gt;</li> <li><code>absolute</code><code>(</code><code>)</code> (Self) \u2014 Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed. &lt;/&gt;</li> <li><code>as_uri</code><code>(</code><code>)</code> (str) \u2014 Return the path as a 'file' URI. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>clear_cache</code><code>(</code><code>)</code> \u2014 Removes cache if it exists&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy a file to a destination. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Copy self into target directory, preserving the filename.&lt;/&gt;</li> <li><code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud</code>, <code>ignore</code><code>)</code> \u2014 Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>exists</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path exists.&lt;/&gt;</li> <li><code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>info</code><code>(</code><code>)</code> (CloudPathInfo) \u2014 Return a CloudPathInfo object for this path.&lt;/&gt;</li> <li><code>is_absolute</code><code>(</code><code>)</code> (bool) \u2014 True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_dir</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a directory. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_file</code><code>(</code><code>follow_symlinks</code><code>)</code> (bool) \u2014 Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_junction</code><code>(</code><code>)</code> \u2014 Whether this path is a junction. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>is_relative_to</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>iterdir</code><code>(</code><code>)</code> (Generator) \u2014 Yield path objects of the directory contents.&lt;/&gt;</li> <li><code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive</code><code>)</code> (bool) \u2014 Return True if this path matches the given pattern. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>mkdir</code><code>(</code><code>parents</code>, <code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create a new directory at this given path. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>move</code><code>(</code><code>target</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self to target location, removing the source.&lt;/&gt;</li> <li><code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks</code>, <code>preserve_metadata</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Union) \u2014 Move self into target directory, preserving the filename and removing the source.&lt;/&gt;</li> <li><code>open</code><code>(</code><code>mode</code>, <code>buffering</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code>, <code>force_overwrite_from_cloud</code>, <code>force_overwrite_to_cloud</code><code>)</code> (IO) \u2014 Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_bytes</code><code>(</code><code>)</code> (bytes) \u2014 Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>read_text</code><code>(</code><code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (str) \u2014 Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>relative_to</code><code>(</code><code>other</code>, <code>walk_up</code><code>)</code> (PurePosixPath) \u2014 Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError. &lt;/&gt;</li> <li><code>rename</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>target</code><code>)</code> (Self) \u2014 Rename this path to the target path, overwriting if that path exists.&lt;/&gt;</li> <li><code>resolve</code><code>(</code><code>strict</code><code>)</code> (Self) \u2014 Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive</code>, <code>recurse_symlinks</code><code>)</code> (Generator) \u2014 Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmdir</code><code>(</code><code>)</code> \u2014 Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>rmtree</code><code>(</code><code>)</code> \u2014 Recursively delete a directory tree. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>samefile</code><code>(</code><code>other_path</code><code>)</code> (bool) \u2014 Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>stat</code><code>(</code><code>follow_symlinks</code><code>)</code> \u2014 Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>touch</code><code>(</code><code>exist_ok</code>, <code>mode</code><code>)</code> \u2014 Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>unlink</code><code>(</code><code>missing_ok</code><code>)</code> \u2014 Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud</code><code>)</code> (Self) \u2014 Upload a file or directory to the cloud path.&lt;/&gt;</li> <li><code>validate</code><code>(</code><code>v</code><code>)</code> (Self) \u2014 Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/ &lt;/&gt;</li> <li><code>walk</code><code>(</code><code>top_down</code>, <code>on_error</code>, <code>follow_symlinks</code><code>)</code> (Generator) \u2014 Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_name</code><code>(</code><code>name</code><code>)</code> \u2014 Return a new path with the file name changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code> \u2014 Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>with_stem</code><code>(</code><code>stem</code><code>)</code> \u2014 Return a new path with the stem changed. (Docstring copied from pathlib.Path)&lt;/&gt;</li> <li><code>with_suffix</code><code>(</code><code>suffix</code><code>)</code> \u2014 Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_bytes</code><code>(</code><code>data</code><code>)</code> (int) \u2014 Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> <li><code>write_text</code><code>(</code><code>data</code>, <code>encoding</code>, <code>errors</code>, <code>newline</code><code>)</code> (int) \u2014 Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path) &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Metaclass for defining Abstract Base Classes (ABCs).</p><p>Use this metaclass to create an ABC.  An ABC can be subclassed directly, and then acts as a mix-in class.  You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as 'virtual subclasses' -- these and their descendants will be considered subclasses of the registering ABC by the built-in issubclass() function, but the registering ABC won't show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via super()).</p> method &lt;/&gt; <p>Return the path as a 'file' URI. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path exists.</p><p>This method normally follows symlinks; to check whether a symlink exists, add the argument follow_symlinks=False.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a regular file (also True for symlinks pointingto regular files).  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Iterate over this subtree and yield all existing files (of anykind, including directories) matching the given relative pattern.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Recursively yield all existing files (of any kind, includingdirectories) matching the given relative pattern, anywhere in this subtree.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Yield path objects of the directory contents.</p><p>The children are yielded in arbitrary order, and the special entries '.' and '..' are not included.  (Docstring copied from pathlib.Path)</p> generator &lt;/&gt; <p>Walk the directory tree from this directory, similar to os.walk(). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file pointed to by this path and return a file object, asthe built-in open() function does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path, overwriting if that path exists.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Rename this path to the target path.</p><p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, not the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this directory.  The directory must be empty. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return whether other_path is the same or not as this file(as returned by os.path.samefile()).  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Remove this file or link.If the path is a directory, use rmdir() instead.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, write to it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in bytes mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Open the file in text mode, read it, and close the file. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Whether this path is a junction. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return an absolute version of this path by prepending the currentworking directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>True if the path is absolute (has both a root and, if applicable,a drive). (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Make the path absolute, resolving all symlinks on the way and alsonormalizing it.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the relative path to another path identified by the passedarguments.  If the operation is not possible (because this is not related to the other path), raise ValueError.</p> <p>The walk_up parameter controls whether <code>..</code> may be used to resolve the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if the path is relative to another path or False.(Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return True if this path matches the given pattern. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a CloudPathInfo object for this path.</p> method &lt;/&gt; <p>Recursively delete a directory tree. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Upload a file or directory to the cloud path.</p> method &lt;/&gt; <p>Copy a file to a destination. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Copy self into target directory, preserving the filename.</p> method &lt;/&gt; <p>Recursively copy a directory tree to a destination directory. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Move self to target location, removing the source.</p> method &lt;/&gt; <p>Move self into target directory, preserving the filename and removing the source.</p> method &lt;/&gt; <p>Removes cache if it exists</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Used as a Pydantic validator. Seehttps://docs.pydantic.dev/2.0/usage/types/custom/</p> classmethod &lt;/&gt; <p>Pydantic special method. Seehttps://pydantic-docs.helpmanual.io/usage/types/#custom-data-types</p> method &lt;/&gt; <p>Create a new directory at this given path. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Create this file with the given access mode, if it doesn't exist. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return the result of the stat() system call on this path, likeos.stat() does.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Generate a string representation of the SpecPath.</p> Returns (str) <p>A string showing the class name, path, and mounted path (if different).</p> method &lt;/&gt; <p>Check equality with another path object.</p><p>Two SpecPath objects are equal if they have the same path string and the same mounted path string.</p> Parameters <ul> <li><code>other</code> (Any) \u2014 Another object to compare with.</li> </ul> Returns (bool) <p>True if the paths are equal, False otherwise.</p> method &lt;/&gt; <p>Generate a hash for the SpecPath.</p> Returns (int) <p>A hash value based on the path string and mounted path string.</p> staticmethod &lt;/&gt; <p>Create a new SpecCloudPath instance.</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 Additional positional arguments passed to the path constructor.</li> <li><code>**kwargs</code> (Any) \u2014 Additional keyword arguments passed to the path constructor.</li> <li><code>path</code> (str | pathlib.path) \u2014 The path string or object representing the spec cloud path.</li> <li><code>mounted</code> (str | pathlib.path | none, optional) \u2014 The path string or object representing the corresponding mountedpath. If None, the spec path itself will be used as the mounted path. </li> </ul> Returns <p>A new SpecCloudPath instance.</p> method &lt;/&gt; <p>Implement the / operator for cloud paths.</p> Parameters <ul> <li><code>other</code> \u2014 The path segment to append to this path.</li> </ul> Returns (SpecPath) <p>A new spec cloud path with the segment appended.</p> method &lt;/&gt; <p>Return a new path with the file name changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the file suffix changed.  If the pathhas no suffix, add given suffix.  If the given suffix is an empty string, remove the suffix from the path.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Construct a new path object from any number of path-like objects.Subclasses may override this method to customize how new path objects are created from methods like <code>iterdir()</code>.  (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Return a new path with the stem changed. (Docstring copied from pathlib.Path)</p> method &lt;/&gt; <p>Combine this path with one or several arguments, and return anew path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).  (Docstring copied from pathlib.Path)</p>"},{"location":"api/xqute.path/#xqutepath","title":"xqute.path","text":""},{"location":"api/xqute.path/#xqutepathmountedpath","title":"<code>xqute.path.</code><code>MountedPath</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.mountedlocalpath | xqute.path.mountedcloudpath","text":""},{"location":"api/xqute.path/#xqutepathmountedpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpath","title":"<code>xqute.path.</code><code>MountedLocalPath</code><code>(</code><code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathstr","title":"<code>__str__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_uri","title":"<code>as_uri</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathwith_stem","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_absolute","title":"<code>is_absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathmatch","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathstat","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexists","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_dir","title":"<code>is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_file","title":"<code>is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_symlink","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsamefile","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathopen","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_bytes","title":"<code>read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_text","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_bytes","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_text","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathiterdir","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathglob","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrglob","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwalk","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathabsolute","title":"<code>absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathresolve","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreadlink","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathtouch","title":"<code>touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathmkdir","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathunlink","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrmdir","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrename","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreplace","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsymlink_to","title":"<code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#abcabcmeta","title":"<code>abc.</code><code>ABCMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>namespace</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_1","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_1","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_1","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_1","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpathwith_segments","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpathwith_name","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpathwith_suffix","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpathjoinpath","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedlocalpathtruediv","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpath","title":"<code>xqute.path.</code><code>MountedCloudPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmkdir","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathtouch","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathiterdir","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwalk","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathreplace","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathunlink","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathresolve","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathstat","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 stat_result","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_2","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_2","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_2","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_2","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathtruediv","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_name","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_suffix","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_segments","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_stem","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathjoinpath","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedgspath","title":"<code>xqute.path.</code><code>MountedGSPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta_1","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri_1","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists_1","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir_1","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file_1","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob_1","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob_1","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen_1","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathreplace_1","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename_1","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir_1","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile_1","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes_1","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text_1","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes_1","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text_1","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction_1","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute_1","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute_1","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to_1","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to_1","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch_1","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo_1","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree_1","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from_1","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_1","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into_1","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree_1","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_1","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into_1","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache_1","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema_1","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate_1","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators_1","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibgsgspathgspathtouch","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathmkdir","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathwalk","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathiterdir","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathstat","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 stat_result","text":""},{"location":"api/xqute.path/#yunpathpatchgspathis_symlink","title":"<code>is_symlink</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#yunpathpatchgspathreadlink","title":"<code>readlink</code><code>(</code><code>)</code> \u2192 GSPath","text":""},{"location":"api/xqute.path/#yunpathpatchgspathresolve","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 GSPath","text":""},{"location":"api/xqute.path/#yunpathpatchgspathsymlink_to","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2192 GSPath","text":""},{"location":"api/xqute.path/#yunpathpatchgspathunlink","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_3","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_3","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_3","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_3","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathnew_1","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathtruediv_1","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_name_1","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_suffix_1","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_segments_1","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_stem_1","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathjoinpath_1","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedazureblobpath","title":"<code>xqute.path.</code><code>MountedAzureBlobPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta_2","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri_2","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists_2","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir_2","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file_2","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob_2","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob_2","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathiterdir_1","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwalk_1","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen_2","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename_2","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir_2","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile_2","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathunlink_1","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes_2","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text_2","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes_2","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text_2","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction_2","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute_2","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute_2","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathresolve_1","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to_2","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to_2","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch_2","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo_2","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree_2","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from_2","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_2","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into_2","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree_2","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_2","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into_2","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache_2","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema_2","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate_2","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators_2","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathmkdir","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathtouch","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathstat","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathreplace","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 AzureBlobPath","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_4","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_4","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_4","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_4","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathnew_2","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathtruediv_2","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_name_2","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_suffix_2","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_segments_2","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_stem_2","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathjoinpath_2","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmounteds3path","title":"<code>xqute.path.</code><code>MountedS3Path</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta_3","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri_3","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists_3","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir_3","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file_3","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob_3","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob_3","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathiterdir_2","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwalk_2","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen_3","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathreplace_2","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename_3","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir_3","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile_3","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathunlink_2","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes_3","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text_3","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes_3","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text_3","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction_3","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute_3","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute_3","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathresolve_2","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to_3","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to_3","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch_3","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo_3","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree_3","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from_3","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_3","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into_3","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree_3","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_3","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into_3","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache_3","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema_3","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate_3","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators_3","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibs3s3paths3pathmkdir","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibs3s3paths3pathtouch","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibs3s3paths3pathstat","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathis_mounted_5","title":"<code>is_mounted</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathrepr_5","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpatheq_5","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedpathhash_5","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathnew_3","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>spec=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathtruediv_3","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_name_3","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_suffix_3","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_segments_3","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathwith_stem_3","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathmountedcloudpathjoinpath_3","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpath","title":"<code>xqute.path.</code><code>SpecPath</code><code>(</code><code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 xqute.path.speclocalpath | xqute.path.speccloudpath","text":""},{"location":"api/xqute.path/#xqutepathspecpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpath","title":"<code>xqute.path.</code><code>SpecLocalPath</code><code>(</code><code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathstr_1","title":"<code>__str__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_posix_1","title":"<code>as_posix</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathbytes_1","title":"<code>__bytes__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathas_uri_1","title":"<code>as_uri</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathrelative_to_1","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code>, <code>walk_up=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_relative_to_1","title":"<code>is_relative_to</code><code>(</code><code>other</code>, <code>*_deprecated</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_absolute_1","title":"<code>is_absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathis_reserved_1","title":"<code>is_reserved</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpurepathmatch_1","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathstat_1","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlstat_1","title":"<code>lstat</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexists_1","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_dir_1","title":"<code>is_dir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_file_1","title":"<code>is_file</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_mount_1","title":"<code>is_mount</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_symlink_1","title":"<code>is_symlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_junction_1","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_block_device_1","title":"<code>is_block_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_char_device_1","title":"<code>is_char_device</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_fifo_1","title":"<code>is_fifo</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathis_socket_1","title":"<code>is_socket</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsamefile_1","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathopen_1","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_bytes_1","title":"<code>read_bytes</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathread_text_1","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_bytes_1","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwrite_text_1","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathiterdir_1","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathglob_1","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrglob_1","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathwalk_1","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathcwd_1","title":"<code>cwd</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhome_1","title":"<code>home</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathabsolute_1","title":"<code>absolute</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathresolve_1","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathowner_1","title":"<code>owner</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathgroup_1","title":"<code>group</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreadlink_1","title":"<code>readlink</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathtouch_1","title":"<code>touch</code><code>(</code><code>mode=438</code>, <code>exist_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathmkdir_1","title":"<code>mkdir</code><code>(</code><code>mode=511</code>, <code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathchmod_1","title":"<code>chmod</code><code>(</code><code>mode</code>, <code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathlchmod_1","title":"<code>lchmod</code><code>(</code><code>mode</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathunlink_1","title":"<code>unlink</code><code>(</code><code>missing_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrmdir_1","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathrename_1","title":"<code>rename</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathreplace_1","title":"<code>replace</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathsymlink_to_1","title":"<code>symlink_to</code><code>(</code><code>target</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathhardlink_to_1","title":"<code>hardlink_to</code><code>(</code><code>target</code><code>)</code>","text":""},{"location":"api/xqute.path/#pathlibpathexpanduser_1","title":"<code>expanduser</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#abcabcmeta_1","title":"<code>abc.</code><code>ABCMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>namespace</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_1","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_1","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_1","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpathwith_segments","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpathwith_name","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpathwith_suffix","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpathwith_stem","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpathjoinpath","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeclocalpathtruediv","title":"<code>__truediv__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpath","title":"<code>xqute.path.</code><code>SpecCloudPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta_4","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmkdir_1","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathtouch_1","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri_4","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists_4","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir_4","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file_4","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob_4","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob_4","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathiterdir_3","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwalk_3","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen_4","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathreplace_3","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename_4","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir_4","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile_4","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathunlink_3","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes_4","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text_4","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes_4","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text_4","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction_4","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute_4","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute_4","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathresolve_3","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to_4","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to_4","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch_4","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathstat_1","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 stat_result","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo_4","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree_4","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from_4","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_4","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into_4","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree_4","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_4","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into_4","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache_4","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema_4","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate_4","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators_4","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_2","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_2","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_2","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathnew","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathtruediv","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_name","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_suffix","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_segments","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_stem","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathjoinpath","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecgspath","title":"<code>xqute.path.</code><code>SpecGSPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta_5","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri_5","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists_5","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir_5","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file_5","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob_5","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob_5","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen_5","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathreplace_4","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename_5","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir_5","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile_5","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes_5","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text_5","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes_5","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text_5","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction_5","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute_5","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute_5","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to_5","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to_5","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch_5","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo_5","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree_5","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from_5","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_5","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into_5","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree_5","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_5","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into_5","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache_5","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema_5","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate_5","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators_5","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibgsgspathgspathtouch_1","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathmkdir_1","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathwalk_1","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathiterdir_1","title":"<code>iterdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#yunpathpatchgspathstat_1","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 stat_result","text":""},{"location":"api/xqute.path/#yunpathpatchgspathis_symlink_1","title":"<code>is_symlink</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#yunpathpatchgspathreadlink_1","title":"<code>readlink</code><code>(</code><code>)</code> \u2192 GSPath","text":""},{"location":"api/xqute.path/#yunpathpatchgspathresolve_1","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 GSPath","text":""},{"location":"api/xqute.path/#yunpathpatchgspathsymlink_to_1","title":"<code>symlink_to</code><code>(</code><code>target</code><code>)</code> \u2192 GSPath","text":""},{"location":"api/xqute.path/#yunpathpatchgspathunlink_1","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_3","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_3","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_3","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathnew_1","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathtruediv_1","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_name_1","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_suffix_1","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_segments_1","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_stem_1","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathjoinpath_1","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecazureblobpath","title":"<code>xqute.path.</code><code>SpecAzureBlobPath</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta_6","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri_6","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists_6","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir_6","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file_6","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob_6","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob_6","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathiterdir_4","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwalk_4","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen_6","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename_6","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir_6","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile_6","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathunlink_4","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes_6","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text_6","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes_6","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text_6","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction_6","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute_6","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute_6","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathresolve_4","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to_6","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to_6","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch_6","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo_6","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree_6","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from_6","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_6","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into_6","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree_6","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_6","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into_6","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache_6","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema_6","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate_6","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators_6","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathmkdir_1","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathtouch_1","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathstat_1","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibazureazblobpathazureblobpathreplace_1","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 AzureBlobPath","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_4","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_4","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_4","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathnew_2","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathtruediv_2","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_name_2","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_suffix_2","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_segments_2","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_stem_2","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathjoinpath_2","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecs3path","title":"<code>xqute.path.</code><code>SpecS3Path</code><code>(</code><code>cloud_path</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmeta_7","title":"<code>cloudpathlib.cloudpath.</code><code>CloudPathMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>dic</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathas_uri_7","title":"<code>as_uri</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathexists_7","title":"<code>exists</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_dir_7","title":"<code>is_dir</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_file_7","title":"<code>is_file</code><code>(</code><code>follow_symlinks=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathglob_7","title":"<code>glob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrglob_7","title":"<code>rglob</code><code>(</code><code>pattern</code>, <code>case_sensitive=None</code>, <code>recurse_symlinks=True</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathiterdir_5","title":"<code>iterdir</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwalk_5","title":"<code>walk</code><code>(</code><code>top_down=True</code>, <code>on_error=None</code>, <code>follow_symlinks=False</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathopen_7","title":"<code>open</code><code>(</code><code>mode='r'</code>, <code>buffering=-1</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code>, <code>force_overwrite_from_cloud=None</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 IO","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathreplace_5","title":"<code>replace</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrename_7","title":"<code>rename</code><code>(</code><code>target</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmdir_7","title":"<code>rmdir</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathsamefile_7","title":"<code>samefile</code><code>(</code><code>other_path</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathunlink_5","title":"<code>unlink</code><code>(</code><code>missing_ok=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_bytes_7","title":"<code>write_bytes</code><code>(</code><code>data</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathwrite_text_7","title":"<code>write_text</code><code>(</code><code>data</code>, <code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 int","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_bytes_7","title":"<code>read_bytes</code><code>(</code><code>)</code> \u2192 bytes","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathread_text_7","title":"<code>read_text</code><code>(</code><code>encoding=None</code>, <code>errors=None</code>, <code>newline=None</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_junction_7","title":"<code>is_junction</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathabsolute_7","title":"<code>absolute</code><code>(</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_absolute_7","title":"<code>is_absolute</code><code>(</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathresolve_5","title":"<code>resolve</code><code>(</code><code>strict=False</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrelative_to_7","title":"<code>relative_to</code><code>(</code><code>other</code>, <code>walk_up=False</code><code>)</code> \u2192 PurePosixPath","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathis_relative_to_7","title":"<code>is_relative_to</code><code>(</code><code>other</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmatch_7","title":"<code>match</code><code>(</code><code>path_pattern</code>, <code>case_sensitive=None</code><code>)</code> \u2192 bool","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathinfo_7","title":"<code>info</code><code>(</code><code>)</code> \u2192 CloudPathInfo","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathrmtree_7","title":"<code>rmtree</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathupload_from_7","title":"<code>upload_from</code><code>(</code><code>source</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_7","title":"<code>copy</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopy_into_7","title":"<code>copy_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathcopytree_7","title":"<code>copytree</code><code>(</code><code>destination</code>, <code>force_overwrite_to_cloud=None</code>, <code>ignore=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_7","title":"<code>move</code><code>(</code><code>target</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathmove_into_7","title":"<code>move_into</code><code>(</code><code>target_dir</code>, <code>follow_symlinks=True</code>, <code>preserve_metadata=False</code>, <code>force_overwrite_to_cloud=None</code><code>)</code> \u2192 Union","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathclear_cache_7","title":"<code>clear_cache</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_pydantic_core_schema_7","title":"<code>__get_pydantic_core_schema__</code><code>(</code><code>_source_type</code>, <code>_handler</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathvalidate_7","title":"<code>validate</code><code>(</code><code>v</code><code>)</code> \u2192 Self","text":""},{"location":"api/xqute.path/#cloudpathlibcloudpathcloudpathget_validators_7","title":"<code>__get_validators__</code><code>(</code><code>)</code> \u2192 Generator","text":""},{"location":"api/xqute.path/#cloudpathlibs3s3paths3pathmkdir_1","title":"<code>mkdir</code><code>(</code><code>parents=False</code>, <code>exist_ok=False</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibs3s3paths3pathtouch_1","title":"<code>touch</code><code>(</code><code>exist_ok=True</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/xqute.path/#cloudpathlibs3s3paths3pathstat_1","title":"<code>stat</code><code>(</code><code>follow_symlinks=True</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathrepr_5","title":"<code>__repr__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpatheq_5","title":"<code>__eq__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspecpathhash_5","title":"<code>__hash__</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathnew_3","title":"<code>__new__</code><code>(</code><code>cls</code>, <code>path</code>, <code>mounted=None</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathtruediv_3","title":"<code>__truediv__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_name_3","title":"<code>with_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_suffix_3","title":"<code>with_suffix</code><code>(</code><code>suffix</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_segments_3","title":"<code>with_segments</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathwith_stem_3","title":"<code>with_stem</code><code>(</code><code>stem</code><code>)</code>","text":""},{"location":"api/xqute.path/#xqutepathspeccloudpathjoinpath_3","title":"<code>joinpath</code><code>(</code><code>*pathsegments</code><code>)</code>","text":""},{"location":"api/xqute.plugin/","title":"xqute.plugin","text":"module &lt;/&gt; <p>Hook specifications for scheduler plugins</p> Functions <ul> <li><code>on_init</code><code>(</code><code>xqute</code><code>)</code> \u2014 When xqute is initialized&lt;/&gt;</li> <li><code>on_job_failed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is failed&lt;/&gt;</li> <li><code>on_job_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is initialized&lt;/&gt;</li> <li><code>on_job_killed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is killed&lt;/&gt;</li> <li><code>on_job_killing</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is being killed&lt;/&gt;</li> <li><code>on_job_polling</code><code>(</code><code>scheduler</code>, <code>job</code>, <code>counter</code><code>)</code> \u2014 When the system is polling job status&lt;/&gt;</li> <li><code>on_job_queued</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is queued&lt;/&gt;</li> <li><code>on_job_started</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job starts to run.&lt;/&gt;</li> <li><code>on_job_submitted</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is submitted&lt;/&gt;</li> <li><code>on_job_submitting</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is to be submitted&lt;/&gt;</li> <li><code>on_job_succeeded</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> \u2014 When the job is succeeded&lt;/&gt;</li> <li><code>on_jobcmd_end</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command finishes and after the postscript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command wrapper script is initialized before the prescript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. For multiple plugins, the code will be inserted in the order of the plugin priority. &lt;/&gt;</li> <li><code>on_jobcmd_prep</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code> (str) \u2014 When the job command right about to be runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>. For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins. &lt;/&gt;</li> <li><code>on_shutdown</code><code>(</code><code>xqute</code>, <code>sig</code><code>)</code> \u2014 When xqute is shutting down&lt;/&gt;</li> </ul> function &lt;/&gt; <p>When xqute is initialized</p><p>Note that this hook will run at the same time when producer and consumer start. So they are not ensured to be started at this point.</p> Parameters <ul> <li><code>xqute</code> (Xqute) \u2014 The xqute object</li> </ul> function &lt;/&gt; <p>When xqute is shutting down</p><p>Return False to stop shutting down, but you have to shut it down by yourself, for example, <code>xqute.task.cancel()</code></p> <p>Only the first return value will be used.</p> Parameters <ul> <li><code>xqute</code> (Xqute) \u2014 The xqute object</li> <li><code>sig</code> (signal.signals | none) \u2014 The signal. <code>None</code> means a natural shutdown</li> </ul> function &lt;/&gt; <p>When the job is initialized</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is queued</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is to be submitted</p><p>Return False to cancel submitting. Only the first return value is used.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is submitted</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job starts to run.</p><p>Note that this is not when exactly the job starts to run, but when the scheduler starts to wait for the job to finish. So this hook is not suitable for measuring the time of the job.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the system is polling job status</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> <li><code>counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> function &lt;/&gt; <p>When the job is being killed</p><p>Return False to stop killing the job.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is killed</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is failed</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job is succeeded</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> function &lt;/&gt; <p>When the job command wrapper script is initialized before the prescript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. For multiple plugins, the code will be inserted in the order of the plugin priority.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p> function &lt;/&gt; <p>When the job command right about to be runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>. For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p> function &lt;/&gt; <p>When the job command finishes and after the postscript is runThis should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance. The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command. For multiple plugins, the code will be inserted in the order of the plugin priority.</p> Parameters <ul> <li><code>scheduler</code> (Scheduler) \u2014 The scheduler object</li> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p>"},{"location":"api/xqute.plugin/#xquteplugin","title":"xqute.plugin","text":""},{"location":"api/xqute.plugin/#xqutepluginon_init","title":"<code>xqute.plugin.</code><code>on_init</code><code>(</code><code>xqute</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_shutdown","title":"<code>xqute.plugin.</code><code>on_shutdown</code><code>(</code><code>xqute</code>, <code>sig</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_init","title":"<code>xqute.plugin.</code><code>on_job_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_queued","title":"<code>xqute.plugin.</code><code>on_job_queued</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_submitting","title":"<code>xqute.plugin.</code><code>on_job_submitting</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_submitted","title":"<code>xqute.plugin.</code><code>on_job_submitted</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_started","title":"<code>xqute.plugin.</code><code>on_job_started</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_polling","title":"<code>xqute.plugin.</code><code>on_job_polling</code><code>(</code><code>scheduler</code>, <code>job</code>, <code>counter</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_killing","title":"<code>xqute.plugin.</code><code>on_job_killing</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_killed","title":"<code>xqute.plugin.</code><code>on_job_killed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_failed","title":"<code>xqute.plugin.</code><code>on_job_failed</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_job_succeeded","title":"<code>xqute.plugin.</code><code>on_job_succeeded</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_jobcmd_init","title":"<code>xqute.plugin.</code><code>on_jobcmd_init</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_jobcmd_prep","title":"<code>xqute.plugin.</code><code>on_jobcmd_prep</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.plugin/#xqutepluginon_jobcmd_end","title":"<code>xqute.plugin.</code><code>on_jobcmd_end</code><code>(</code><code>scheduler</code>, <code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/","title":"xqute.scheduler","text":"module &lt;/&gt; <p>The scheduler to schedule jobs</p> Classes <ul> <li><code>Scheduler</code><code>(</code><code>workdir</code>, <code>forks</code>, <code>error_strategy</code>, <code>num_retries</code>, <code>prescript</code>, <code>postscript</code>, <code>jobname_prefix</code>, <code>recheck_interval</code>, <code>cwd</code>, <code>**kwargs</code><code>)</code> \u2014 The abstract class for scheduler&lt;/&gt;</li> </ul> abstract class &lt;/&gt; <p>The abstract class for scheduler</p> Attributes <ul> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>workdir</code> (str | pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The working directory</li> <li><code>forks</code> (int, optional) \u2014 Max number of job forks</li> <li><code>error_strategy</code> (str, optional) \u2014 The strategy when there is error happened</li> <li><code>num_retries</code> (int, optional) \u2014 Max number of retries when error_strategy is retry</li> <li><code>prescript</code> (str, optional) \u2014 The prescript to run before the job commandIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>postscript</code> (str, optional) \u2014 The postscript to run when job finishedIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>jobname_prefix</code> (str | none, optional) \u2014 The prefix for the job name</li> <li><code>recheck_interval</code> (int, optional) \u2014 The interval to recheck the job status.Default is every 600 polls (each takes about 0.1 seconds). </li> <li><code>cwd</code> (str | pathlib.path, optional) \u2014 The working directory for the job command wrapper</li> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is really running&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (int | str) \u2014 Submit a job&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> abstract method &lt;/&gt; <p>Submit a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (int | str) <p>The unique id in the scheduler system</p> abstract method &lt;/&gt; <p>Kill a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> abstract method &lt;/&gt; <p>Check if a job is really running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p>"},{"location":"api/xqute.scheduler/#xqutescheduler","title":"xqute.scheduler","text":""},{"location":"api/xqute.scheduler/#xquteschedulerscheduler","title":"<code>xqute.scheduler.</code><code>Scheduler</code><code>(</code><code>workdir</code>, <code>forks=1</code>, <code>error_strategy='ignore'</code>, <code>num_retries=3</code>, <code>prescript=''</code>, <code>postscript=''</code>, <code>jobname_prefix=None</code>, <code>recheck_interval=600</code>, <code>cwd=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.scheduler/#xquteschedulerschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/","title":"xqute.schedulers.container_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs via containers</p> Classes <ul> <li><code>ContainerScheduler</code> \u2014 Scheduler to run jobs via containers (Docker/Podman/Apptainer)&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.schedulers.local_scheduler.LocalScheduler xqute.scheduler.Scheduler <p>Scheduler to run jobs via containers (Docker/Podman/Apptainer)</p><p>This scheduler can execute jobs inside containers using Docker, Podman, or Apptainer.</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Additional arguments passed to parent Scheduler</li> <li><code>image</code> (str) \u2014 Container image to use for running jobs</li> <li><code>entrypoint</code> (Union, optional) \u2014 Entrypoint command for the container</li> <li><code>bin</code> (str, optional) \u2014 Path to container runtime binary (e.g. /path/to/docker)</li> <li><code>volumes</code> (Union, optional) \u2014 host:container volume mapping string or stringsor named volume mapping like <code>MOUNTED=/path/on/host</code> then it will be mounted to <code>/mnt/disks/MOUNTED</code> in the container. You can use environment variable <code>MOUNTED</code> in your job scripts to refer to the mounted path. </li> <li><code>remove</code> (bool, optional) \u2014 Whether to remove the container after execution.Only applies to Docker/Podman. </li> <li><code>user</code> (str | none, optional) \u2014 User to run the container as (only for Docker/Podman)By default, it runs as the current user (os.getuid() and os.getgid()) </li> <li><code>bin_args</code> (Optional, optional) \u2014 Additional arguments to pass to the container runtime</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job asynchronously&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (int) \u2014 Submit a job locally&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Kill a job asynchronously</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job locally</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (int) <p>The process id</p> method &lt;/&gt; <p>The job command init</p>"},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_scheduler","title":"xqute.schedulers.container_scheduler","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerscheduler","title":"<code>xqute.schedulers.container_scheduler.</code><code>ContainerScheduler</code><code>(</code><code>image</code>, <code>entrypoint='/bin/bash'</code>, <code>bin='docker'</code>, <code>volumes=None</code>, <code>remove=True</code>, <code>user=None</code>, <code>bin_args=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerslocal_schedulerlocalschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerslocal_schedulerlocalschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.container_scheduler/#xquteschedulerscontainer_schedulercontainerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/","title":"xqute.schedulers.gbatch_scheduler","text":"module &lt;/&gt; Classes <ul> <li><code>GbatchScheduler</code> \u2014 Scheduler for Google Cloud Batch&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>Scheduler for Google Cloud Batch</p><p>You can pass extra configuration parameters to the constructor that will be used in the job configuration file. For example, you can pass <code>taskGroups</code> to specify the task groups and their specifications.</p> <p>For using containers, it is a little bit tricky to specify the commands. When no <code>entrypoint</code> is specified, the <code>commands</code> should be a list with the first element being the interpreter (e.g. <code>/bin/bash</code>) and the second element being the path to the wrapped job script. If the <code>entrypoint</code> is specified, we can use the <code>{lang}</code> and <code>{script}</code> placeholders in the <code>commands</code> list, where <code>{lang}</code> will be replaced with the interpreter (e.g. <code>/bin/bash</code>) and <code>{script}</code> will be replaced with the path to the wrapped job script. With <code>entrypoint</code> specified and no <code>{script}</code> placeholder, the joined command will be the interpreter followed by the path to the wrapped job script will be appended to the <code>commands</code> list.</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> <li><code>project</code> (str) \u2014 GCP project ID</li> <li><code>location</code> (str) \u2014 GCP location (e.g. us-central1)</li> <li><code>mount</code> (Union, optional) \u2014 GCS path to mount (e.g. gs://my-bucket:/mnt/my-bucket)You can pass a list of mounts. You can also use named mount like <code>NAME=gs://bucket/dir</code> then it will be mounted to <code>/mnt/disks/NAME</code> in the container. You can use environment variable <code>NAME</code> in your job scripts to refer to the mounted path. </li> <li><code>service_account</code> (str | none, optional) \u2014 GCP service account email (e.g. test-account@example.com)</li> <li><code>network</code> (str | none, optional) \u2014 GCP network (e.g. default-network)</li> <li><code>subnetwork</code> (str | none, optional) \u2014 GCP subnetwork (e.g. regions/us-central1/subnetworks/default)</li> <li><code>no_external_ip_address</code> (bool | none, optional) \u2014 Whether to disable external IP address</li> <li><code>machine_type</code> (str | none, optional) \u2014 GCP machine type (e.g. e2-standard-4)</li> <li><code>provisioning_model</code> (str | none, optional) \u2014 GCP provisioning model (e.g. SPOT)</li> <li><code>image_uri</code> (str | none, optional) \u2014 Container image URI (e.g. ubuntu-2004-lts)</li> <li><code>entrypoint</code> (str, optional) \u2014 Container entrypoint (e.g. /bin/bash)</li> <li><code>commands</code> (Union, optional) \u2014 The command list to run in the container.There are three ways to specify the commands: 1. If no entrypoint is specified, the final command will be [commands, wrapped_script], where the entrypoint is the wrapper script interpreter that is determined by <code>JOBCMD_WRAPPER_LANG</code> (e.g. /bin/bash), commands is the list you provided, and wrapped_script is the path to the wrapped job script. 2. You can specify something like \"-c\", then the final command will be [\"-c\", \"wrapper_script_interpreter, wrapper_script\"] 3. You can use the placeholders <code>{lang}</code> and <code>{script}</code> in the commands list, where <code>{lang}</code> will be replaced with the interpreter (e.g. /bin/bash) and <code>{script}</code> will be replaced with the path to the wrapped job script. For example, you can specify [\"{lang} {script}\"] and the final command will be [\"wrapper_interpreter, wrapper_script\"] </li> <li><code>runnables</code> (Optional, optional) \u2014 Additional runnables to run before or after the main job.Each runnable should be a dictionary that follows the GCP Batch API specification. You can also specify an \"order\" key in the dictionary to control the execution order of the runnables. Runnables with negative order will be executed before the main job, and those with non-negative order will be executed after the main job. The main job runnable will always be executed in the order it is defined in the list. </li> </ul> Attributes <ul> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is really running&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The unique id in the scheduler system</p> method &lt;/&gt; <p>Kill a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>Check if a job is really running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The job command init</p>"},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_scheduler","title":"xqute.schedulers.gbatch_scheduler","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchscheduler","title":"<code>xqute.schedulers.gbatch_scheduler.</code><code>GbatchScheduler</code><code>(</code><code>*args</code>, <code>project</code>, <code>location</code>, <code>mount=None</code>, <code>service_account=None</code>, <code>network=None</code>, <code>subnetwork=None</code>, <code>no_external_ip_address=None</code>, <code>machine_type=None</code>, <code>provisioning_model=None</code>, <code>image_uri=None</code>, <code>entrypoint=None</code>, <code>commands=None</code>, <code>runnables=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.gbatch_scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/","title":"xqute.schedulers.local_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs locally</p> Classes <ul> <li><code>LocalScheduler</code> \u2014 The local scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>The local scheduler</p> Parameters <ul> <li><code>workdir</code> (str | Path | CloudPath) \u2014 The working directory</li> <li><code>forks</code> (int, optional) \u2014 Max number of job forks</li> <li><code>error_strategy</code> (str, optional) \u2014 The strategy when there is error happened</li> <li><code>num_retries</code> (int, optional) \u2014 Max number of retries when error_strategy is retry</li> <li><code>prescript</code> (str, optional) \u2014 The prescript to run before the job commandIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>postscript</code> (str, optional) \u2014 The postscript to run when job finishedIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>jobname_prefix</code> (str | none, optional) \u2014 The prefix for the job name</li> <li><code>recheck_interval</code> (int, optional) \u2014 The interval to recheck the job status.Default is every 600 polls (each takes about 0.1 seconds). </li> <li><code>cwd</code> (str | Path, optional) \u2014 The working directory for the job command wrapper</li> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job asynchronously&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code>, <code>_mounted</code><code>)</code> (int) \u2014 Submit a job locally&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job locally</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> <li><code>_mounted</code> (bool, optional) \u2014 Whether to use the mounted path of the wrapped job scriptUsed internally for container scheduler </li> </ul> Returns (int) <p>The process id</p> method &lt;/&gt; <p>Kill a job asynchronously</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p>"},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_scheduler","title":"xqute.schedulers.local_scheduler","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalscheduler","title":"<code>xqute.schedulers.local_scheduler.</code><code>LocalScheduler</code><code>(</code><code>workdir</code>, <code>forks=1</code>, <code>error_strategy='ignore'</code>, <code>num_retries=3</code>, <code>prescript=''</code>, <code>postscript=''</code>, <code>jobname_prefix=None</code>, <code>recheck_interval=600</code>, <code>cwd=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code>, <code>_mounted=False</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.local_scheduler/#xquteschedulerslocal_schedulerlocalschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers/","title":"xqute.schedulers","text":"package &lt;/&gt; <p>Builtin schedulers</p> Functions <ul> <li><code>get_scheduler</code><code>(</code><code>scheduler</code><code>)</code> (Type) \u2014 Get the scheduler class&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs locally</p> Classes <ul> <li><code>LocalScheduler</code> \u2014 The local scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs via containers</p> Classes <ul> <li><code>ContainerScheduler</code> \u2014 Scheduler to run jobs via containers (Docker/Podman/Apptainer)&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs on SGE</p> Classes <ul> <li><code>SgeScheduler</code> \u2014 The sge scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>The scheduler to run jobs on Slurm</p> Classes <ul> <li><code>SlurmScheduler</code> \u2014 The Slurm scheduler&lt;/&gt;</li> </ul>"},{"location":"api/xqute.schedulers/#xquteschedulers","title":"xqute.schedulers","text":""},{"location":"api/xqute.schedulers/#xquteschedulerslocal_scheduler","title":"xqute.schedulers.local_scheduler","text":""},{"location":"api/xqute.schedulers/#xquteschedulerscontainer_scheduler","title":"xqute.schedulers.container_scheduler","text":""},{"location":"api/xqute.schedulers/#xquteschedulerssge_scheduler","title":"xqute.schedulers.sge_scheduler","text":""},{"location":"api/xqute.schedulers/#xquteschedulersslurm_scheduler","title":"xqute.schedulers.slurm_scheduler","text":""},{"location":"api/xqute.schedulers.sge_scheduler/","title":"xqute.schedulers.sge_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs on SGE</p> Classes <ul> <li><code>SgeScheduler</code> \u2014 The sge scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>The sge scheduler</p> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on SGE&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to SGE&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job to SGE</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on SGE</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p>"},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_scheduler","title":"xqute.schedulers.sge_scheduler","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgescheduler","title":"<code>xqute.schedulers.sge_scheduler.</code><code>SgeScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.sge_scheduler/#xquteschedulerssge_schedulersgeschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/","title":"xqute.schedulers.slurm_scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs on Slurm</p> Classes <ul> <li><code>SlurmScheduler</code> \u2014 The Slurm scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>The Slurm scheduler</p> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on Slurm&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to Slurm&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job to Slurm</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on Slurm</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> \u2014 The job to check</li> </ul> Returns <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p>"},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_scheduler","title":"xqute.schedulers.slurm_scheduler","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmscheduler","title":"<code>xqute.schedulers.slurm_scheduler.</code><code>SlurmScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.slurm_scheduler/#xquteschedulersslurm_schedulerslurmschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler/","title":"xqute.schedulers.ssh_scheduler","text":"package &lt;/&gt; module &lt;/&gt; <p>The scheduler to run jobs on SSH</p> Classes <ul> <li><code>SshScheduler</code> \u2014 The ssh scheduler&lt;/&gt;</li> </ul> module &lt;/&gt; <p>This script is used to wrap the command for the scheduler to submit and run</p><p>It is used by the ssh scheduler to submit jobs to remote servers and print the pid of the job to stdout. The real command is run in a subprocess without waiting for the results.</p> <p>The script is executed by the scheduler, not the user. And it's not imported by xqute directly.</p> <p>Find a way to pass envs?</p>"},{"location":"api/xqute.schedulers.ssh_scheduler/#xquteschedulersssh_scheduler","title":"xqute.schedulers.ssh_scheduler","text":""},{"location":"api/xqute.schedulers.ssh_scheduler/#xquteschedulersssh_schedulerscheduler","title":"xqute.schedulers.ssh_scheduler.scheduler","text":""},{"location":"api/xqute.schedulers.ssh_scheduler/#xquteschedulersssh_schedulersubmitter","title":"xqute.schedulers.ssh_scheduler.submitter","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/","title":"xqute.schedulers.ssh_scheduler.scheduler","text":"module &lt;/&gt; <p>The scheduler to run jobs on SSH</p> Classes <ul> <li><code>SshScheduler</code> \u2014 The ssh scheduler&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.scheduler.Scheduler <p>The ssh scheduler</p> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on SSH&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to SSH&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job to SSH</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on SSH</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p>"},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerscheduler","title":"xqute.schedulers.ssh_scheduler.scheduler","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshscheduler","title":"<code>xqute.schedulers.ssh_scheduler.scheduler.</code><code>SshScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.scheduler/#xquteschedulersssh_schedulerschedulersshschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/xqute.schedulers.ssh_scheduler.submitter/","title":"xqute.schedulers.ssh_scheduler.submitter","text":"module &lt;/&gt; <p>This script is used to wrap the command for the scheduler to submit and run</p><p>It is used by the ssh scheduler to submit jobs to remote servers and print the pid of the job to stdout. The real command is run in a subprocess without waiting for the results.</p> <p>The script is executed by the scheduler, not the user. And it's not imported by xqute directly.</p> <p>Find a way to pass envs?</p>"},{"location":"api/xqute.schedulers.ssh_scheduler.submitter/#xquteschedulersssh_schedulersubmitter","title":"xqute.schedulers.ssh_scheduler.submitter","text":""},{"location":"api/xqute.utils/","title":"xqute.utils","text":"module &lt;/&gt; <p>Utilities for xqute</p> Classes <ul> <li><code>DuplicateFilter</code> \u2014 Filter instances are used to perform arbitrary filtering of LogRecords.&lt;/&gt;</li> </ul> class &lt;/&gt; Bases logging.Filter <p>Filter instances are used to perform arbitrary filtering of LogRecords.</p><p>Loggers and Handlers can optionally use Filter instances to filter records as desired. The base filter class only allows events which are below a certain point in the logger hierarchy. For example, a filter initialized with \"A.B\" will allow events logged by loggers \"A.B\", \"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If initialized with the empty string, all events are passed.</p> Methods <ul> <li><code>filter</code><code>(</code><code>record</code><code>)</code> \u2014 Determine if the specified record is to be logged.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Determine if the specified record is to be logged.</p><p>Returns True if the record should be logged, or False otherwise. If deemed appropriate, the record may be modified in-place.</p>"},{"location":"api/xqute.utils/#xquteutils","title":"xqute.utils","text":""},{"location":"api/xqute.utils/#xquteutilsduplicatefilter","title":"<code>xqute.utils.</code><code>DuplicateFilter</code><code>(</code><code>)</code>","text":""},{"location":"api/xqute.utils/#xquteutilsduplicatefilterfilter","title":"<code>filter</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/xqute.xqute/","title":"xqute.xqute","text":"module &lt;/&gt; <p>The xqute module</p> Classes <ul> <li><code>Xqute</code> \u2014 The main class of the package&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The main class of the package</p> Attributes <ul> <li><code>EMPTY_BUFFER_SLEEP_TIME</code> \u2014 The time to sleep while waiting whenthe buffer is empty to wait for the jobs to be pushed </li> <li><code>_cancelling</code> \u2014 A mark to mark whether a shutting down eventis triggered (True for natural cancelling, the signal for cancelling with a signal, SIGINT for example) </li> <li><code>buffer_queue</code> \u2014 A buffer queue to save the pushed jobs</li> <li><code>jobs</code> \u2014 The jobs registry</li> <li><code>name</code> \u2014 The name, used in logger</li> <li><code>plugins</code> \u2014 The plugins to be enabled or disabledto disable a plugin, using <code>-plugin_name</code> either all plugin names should be prefixed with '+'/'-' or none of them should </li> <li><code>queue</code> \u2014 The job queue</li> <li><code>scheduler</code> \u2014 The scheduler</li> <li><code>task</code> \u2014 The task of producer and consumers</li> </ul> Parameters <ul> <li><code>scheduler</code> (str | Type[Scheduler], optional) \u2014 The scheduler class or name</li> <li><code>plugins</code> (Optional, optional) \u2014 The plugins to be enabled or disabledto disable a plugin, using <code>-plugin_name</code> either all plugin names should be prefixed with '+'/'-' or none of them should </li> <li><code>workdir</code> (str | PathType, optional) \u2014 The job meta directory</li> <li><code>submission_batch</code> (int, optional) \u2014 The number of consumers to submit jobs. So that thesubmission process won't exhaust the local resources </li> <li><code>error_strategy</code> (str, optional) \u2014 The strategy when there is error happened</li> <li><code>num_retries</code> (int, optional) \u2014 Max number of retries when error_strategy is retry</li> <li><code>forks</code> (int, optional) \u2014 Max number of job forks for scheduler</li> <li><code>scheduler_opts</code> (Optional, optional) \u2014 Additional keyword arguments for scheduler</li> </ul> Methods <ul> <li><code>cancel</code><code>(</code><code>sig</code><code>)</code> \u2014 Cancel the producer-consumer task&lt;/&gt;</li> <li><code>put</code><code>(</code><code>cmd</code>, <code>envs</code><code>)</code> \u2014 Put a command into the buffer&lt;/&gt;</li> <li><code>run_until_complete</code><code>(</code><code>)</code> \u2014 Wait until all jobs complete&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Cancel the producer-consumer task</p><p><code>self._cancelling</code> will be set to <code>signaled</code> if sig is provided, otherwise it will be set to <code>True</code></p> Parameters <ul> <li><code>sig</code> (signal.signals | none, optional) \u2014 Whether this cancelling is caused by a signal</li> </ul> method &lt;/&gt; <p>Put a command into the buffer</p> Parameters <ul> <li><code>cmd</code> (CommandType | Job) \u2014 The command</li> <li><code>envs</code> (dict, optional) \u2014 The environment variables for the job</li> </ul> method &lt;/&gt; <p>Wait until all jobs complete</p>"},{"location":"api/xqute.xqute/#xqutexqute","title":"xqute.xqute","text":""},{"location":"api/xqute.xqute/#xqutexqutexqute","title":"<code>xqute.xqute.</code><code>Xqute</code><code>(</code><code>scheduler='local'</code>, <code>plugins=None</code>, <code>workdir='./.xqute'</code>, <code>submission_batch=8</code>, <code>error_strategy='ignore'</code>, <code>num_retries=3</code>, <code>forks=1</code>, <code>scheduler_opts=None</code>, <code>jobname_prefix=None</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexqutecancel","title":"<code>cancel</code><code>(</code><code>sig=None</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexquteput","title":"<code>put</code><code>(</code><code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/xqute.xqute/#xqutexqutexquterun_until_complete","title":"<code>run_until_complete</code><code>(</code><code>)</code>","text":""},{"location":"api/source/xqute.defaults/","title":"xqute.defaults","text":""},{"location":"api/source/xqute.defaults/","title":"SOURCE CODE xqute.defaults DOCS","text":"<pre><code>\"\"\"Default settings and utilities for xqute\n\nAttributes:\n    DEFAULT_WORKDIR: The default work directory for jobs to save the metadata\n    DEFAULT_ERROR_STRATEGY: The default strategy when there is\n        error happened\n    DEFAULT_NUM_RETRIES: Default number of retries when\n        DEFAULT_ERROR_STRATEGY is retry\n    DEFAULT_JOB_CMD_WRAPPER_SHELL: The default shell for job wrapper\n    DEFAULT_SCHEDULER_FORKS: Default number of job forks for scheduler\n    DEFAULT_SUBMISSION_BATCH: Default consumer workers\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport textwrap\nfrom typing import Tuple\nimport uvloop\n\nasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n\n\nclass JobErrorStrategy:DOCS\n    \"\"\"The strategy when error happen from jobs\n\n    Attributes:\n        IGNORE: ignore and run next jobs\n        RETRY: retry the job\n        HALT: halt the whole program\n    \"\"\"\n\n    IGNORE: str = \"ignore\"\n    RETRY: str = \"retry\"\n    HALT: str = \"halt\"\n\n\nclass JobStatus:DOCS\n    \"\"\"The status of a job\n\n    Life cycles:\n    ........................queued in scheduler\n    INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; FINISHED (FAILED)\n    INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; RUNNING -&gt; KILLING -&gt; FINISHED\n    INIT -&gt; QUEUED -&gt; SUBMITTED -&gt; KILLING -&gt; FINISHED\n    INIT -&gt; QUEUED -&gt; (CANCELLED)\n\n    Attributes:\n        INIT: When a job is initialized\n        RETRYING: When a job is to be retried\n        QUEUED: When a job is queued\n        SUBMITTED: When a job is submitted\n        RUNNING: When a job is running\n        KILLING: When a job is being killed\n        FINISHED: When a job is finished\n        FAILED: When a job is failed\n    \"\"\"\n\n    INIT: int = 0\n    RETRYING: int = 1\n    QUEUED: int = 2\n    SUBMITTED: int = 3\n    RUNNING: int = 4\n    KILLING: int = 5\n    FINISHED: int = 6\n    FAILED: int = 7\n\n    @classmethodDOCS\n    def get_name(cls, *statuses: int) -&gt; Tuple[str, ...] | str:\n        \"\"\"Get the name of the status\n\n        Args:\n            *statuses: The status values\n\n        Returns:\n            The name of the status if a single status is passed, otherwise\n            a tuple of names\n        \"\"\"\n        ret_dict = {}\n        for name, value in cls.__dict__.items():\n            if value in statuses:\n                ret_dict[value] = name\n        ret_tuple = tuple(ret_dict[status] for status in statuses)\n        if len(ret_tuple) &gt; 1:\n            return ret_tuple\n        return ret_tuple[0]  # pragma: no cover\n\n\nLOGGER_NAME = \"XQUTE\"\n\nDEFAULT_SCHEDULER_FORKS: int = 1\nDEFAULT_WORKDIR = \"./.xqute\"\nDEFAULT_ERROR_STRATEGY: str = JobErrorStrategy.IGNORE\nDEFAULT_NUM_RETRIES: int = 3\nDEFAULT_SUBMISSION_BATCH: int = 8\nJOBCMD_WRAPPER_LANG: str = \"/bin/bash\"\nJOBCMD_WRAPPER_TEMPLATE: str = r\"\"\"#!{shebang}\nset -u -E -o pipefail\n\n{scheduler.jobcmd_wrapper_init}\n\n# tell the xqute that the job is submitted\nupdate_metafile \"{status.RUNNING}\" \"{job.status_file.mounted}\"\nupdate_metafile \"\" \"{job.stdout_file.mounted}\"\n\n# plugins.on_jobcmd_init\n{jobcmd_init}\n\n\ncleanup() {{\n    rc=$?\n    update_metafile \"$rc\" \"{job.rc_file.mounted}\"\n    if [[ $rc -eq 0 ]]; then\n        update_metafile \"{status.FINISHED}\" \"{job.status_file.mounted}\"\n    else\n        update_metafile \"{status.FAILED}\" \"{job.status_file.mounted}\"\n    fi\n\n    remove_metafile \"{job.jid_file.mounted}\"\n\n    # postscript\n    {scheduler.postscript}\n\n    # plugins.on_jobcmd_end\n    {jobcmd_end}\n\n    exit $rc\n}}\n\n# register trap\ntrap \"cleanup\" EXIT\n\n# prescript\n{scheduler.prescript}\n\ncmd=$(compose_cmd \"{cmd}\" \"{job.stdout_file.mounted}\" \"{job.stderr_file.mounted}\")\n\n# plugins.on_jobcmd_prep\n{jobcmd_prep}\n\n# Run the command, the real job\neval \"$cmd\"\n\"\"\"  # noqa: E501\n\n\ndef get_jobcmd_wrapper_init(local: bool, remove_jid_after_done: bool) -&gt; str:DOCS\n    \"\"\"Get the job command wrapper initialization script\n\n    Args:\n        local: Whether the job is running locally\n        remove_jid_after_done: Whether to remove the remote job id file\n            after the job is done\n\n    Returns:\n        The job command wrapper initialization script\n    \"\"\"\n    if local:\n        rm_file = (\n            'mv \"$file\" \"${file}.used\"'\n            if remove_jid_after_done\n            else 'if [ \"file\" != *\"job.jid\" ]; then rm -f \"$file\"; fi'\n        )\n        return textwrap.dedent(\n            f\"\"\"\n            export META_ON_CLOUD=0\n\n            update_metafile() {{\n                local content=$1\n                local file=$2\n                echo \"$content\" &gt; \"$file\"\n            }}\n\n            remove_metafile() {{\n                local file=$1\n                {rm_file}\n            }}\n\n            compose_cmd() {{\n                local cmd=$1\n                local stdout_file=$2\n                local stderr_file=$3\n                echo \"$cmd 1&gt;$stdout_file 2&gt;$stderr_file\"\n            }}\n            \"\"\"\n        )\n    else:\n        rm_file = (\n            'cloudsh mv \"$file\" \"${file}_used\"'\n            if remove_jid_after_done\n            else 'if [ \"file\" != *\"job.jid\" ]; then cloudsh rm -f \"$file\"; fi'\n        )\n        return textwrap.dedent(\n            f\"\"\"\n            export META_ON_CLOUD=1\n\n            # Check if cloudsh is installed\n            if ! command -v cloudsh &amp;&gt; /dev/null; then\n                echo \"cloudsh is not installed to support cloud workdir, please install it first\" 1&gt;&amp;2\n                exit 1\n            fi\n\n            update_metafile() {{\n                local content=$1\n                local file=$2\n                echo \"$content\" | cloudsh sink \"$file\"\n            }}\n\n            remove_metafile() {{\n                local file=$1\n                {rm_file}\n            }}\n\n            compose_cmd() {{\n                local cmd=$1\n                local stdout_file=$2\n                local stderr_file=$3\n                # create temp files to save stderr\n                stderrtmp=$(mktemp)\n                echo \"$cmd 2&gt;$stderrtmp | cloudsh sink $stdout_file; \\\\\n                    rc=\\\\$?; \\\\\n                    cloudsh mv $stderrtmp $stderr_file; \\\\\n                    exit \\\\$rc\"\n            }}\n            \"\"\"  # noqa: E501\n        )\n</code></pre>"},{"location":"api/source/xqute.job/","title":"xqute.job","text":""},{"location":"api/source/xqute.job/","title":"SOURCE CODE xqute.job DOCS","text":"<pre><code>\"\"\"Job to execute\"\"\"\n\nfrom __future__ import annotations\n\nimport shlex\nfrom typing import Any, Tuple\n\nfrom .defaults import JobStatus\nfrom .utils import logger, CommandType\nfrom .path import SpecPath\n\n\nclass Job:DOCS\n    \"\"\"The class for job\n\n    Attributes:\n\n        cmd: The command\n        index: The index of the job\n        metadir: The metadir of the job\n        jid: The jid of the job in scheduler system\n        trial_count: The count for re-tries\n        hook_done: Mark whether hooks have already been. Since we don't have\n            a trigger for job finished/failed, so we do a polling on it. This\n            is to avoid calling the hooks repeatedly\n        _status: The status of the job\n        _rc: The return code of the job\n        _error_retry: Whether we should retry if error happened\n        _num_retries: Total number of retries\n\n    Args:\n        index: The index of the job\n        cmd: The command of the job\n        metadir: The meta directory of the Job\n        error_retry: Whether we should retry if error happened\n        num_retries: Total number of retries\n    \"\"\"\n\n    __slots__ = (\n        \"cmd\",\n        \"index\",\n        \"metadir\",\n        \"trial_count\",\n        \"_jid\",\n        \"_status\",\n        \"_rc\",\n        \"_error_retry\",\n        \"_num_retries\",\n        \"prev_status\",\n        \"envs\",\n    )\n\n    def __init__(\n        self,\n        index: int,\n        cmd: CommandType,\n        workdir: SpecPath,\n        error_retry: bool | None = None,\n        num_retries: int | None = None,\n        envs: dict[str, Any] | None = None,\n    ):\n        \"\"\"Construct a new Job\n\n        Args:\n            index: The index of the job\n            cmd: The command of the job\n            metadir: The meta directory of the Job\n            error_retry: Whether we should retry if error happened\n            num_retries: Total number of retries\n        \"\"\"\n        self.cmd: Tuple[str, ...] = tuple(\n            map(\n                str,\n                (cmd if isinstance(cmd, (tuple, list)) else shlex.split(cmd)),\n            )\n        )\n        self.index = index\n        self.envs = envs or {}\n        self.envs[\"XQUTE_JOB_INDEX\"] = str(self.index)\n        self.envs[\"XQUTE_METADIR\"] = str(workdir)\n        self.metadir = workdir / str(self.index)  # type: ignore\n        self.envs[\"XQUTE_JOB_METADIR\"] = str(self.metadir)\n        self.metadir.mkdir(exist_ok=True, parents=True)\n\n        # The name of the job, should be the unique id from the scheduler\n        self.trial_count = 0\n        self.prev_status = JobStatus.INIT\n\n        self._jid: int | str | None = None\n        self._status = JobStatus.INIT\n        self._rc = -1\n        self._error_retry = error_retry\n        self._num_retries = num_retries\n\n    def __repr__(self) -&gt; str:DOCS\n        \"\"\"repr of the job\"\"\"\n        prefix = f\"{self.__class__.__name__}-{self.index}\"\n        if not self.jid:\n            return f\"&lt;{prefix}: ({self.cmd})&gt;\"\n        return f\"&lt;{prefix}({self.jid}): ({self.cmd})&gt;\"\n\n    @propertyDOCS\n    def jid(self) -&gt; int | str | None:\n        \"\"\"Get the jid of the job in scheduler system\"\"\"\n        if self._jid is None and not self.jid_file.is_file():\n            return None\n        if self._jid is not None:\n            return self._jid\n        self._jid = self.jid_file.read_text()\n        return self._jid\n\n    @jid.setter\n    def jid(self, uniqid: int | str):\n        self._jid = uniqid\n        self.jid_file.write_text(str(uniqid))\n\n    @propertyDOCS\n    def stdout_file(self) -&gt; SpecPath:\n        \"\"\"The stdout file of the job\"\"\"\n        return self.metadir / \"job.stdout\"\n\n    @propertyDOCS\n    def stderr_file(self) -&gt; SpecPath:\n        \"\"\"The stderr file of the job\"\"\"\n        return self.metadir / \"job.stderr\"\n\n    @propertyDOCS\n    def status_file(self) -&gt; SpecPath:\n        \"\"\"The status file of the job\"\"\"\n        return self.metadir / \"job.status\"\n\n    @propertyDOCS\n    def rc_file(self) -&gt; SpecPath:\n        \"\"\"The rc file of the job\"\"\"\n        return self.metadir / \"job.rc\"\n\n    @propertyDOCS\n    def jid_file(self) -&gt; SpecPath:\n        \"\"\"The jid file of the job\"\"\"\n        return self.metadir / \"job.jid\"\n\n    @propertyDOCS\n    def retry_dir(self) -&gt; SpecPath:\n        \"\"\"The retry directory of the job\"\"\"\n        return self.metadir / \"job.retry\"\n\n    @propertyDOCS\n    def status(self) -&gt; int:\n        \"\"\"Query the status of the job\n\n        If the job is submitted, try to query it from the status file\n        Make sure the status is updated by trap in wrapped script\n        \"\"\"\n        self.prev_status = self._status\n        if self.status_file.is_file() and self._status in (\n            JobStatus.SUBMITTED,\n            JobStatus.RUNNING,\n            JobStatus.KILLING,\n        ):\n            try:\n                self._status = int(self.status_file.read_text())\n            except (\n                FileNotFoundError,\n                ValueError,\n                TypeError,\n            ):  # pragma: no cover\n                pass\n\n        if (\n            self._status == JobStatus.FAILED\n            and self._error_retry\n            and self.trial_count &lt; self._num_retries  # type: ignore\n        ):\n            self._status = JobStatus.RETRYING\n\n        if self.prev_status != self._status and (\n            self._status == JobStatus.RETRYING or self._status &gt;= JobStatus.KILLING\n        ):\n            logger.info(\n                \"/Job-%s Status changed: %r -&gt; %r\",\n                self.index,\n                *JobStatus.get_name(self.prev_status, self._status),\n            )\n\n        return self._status\n\n    @status.setter\n    def status(self, stat: int):\n        \"\"\"Set the status manually\n\n        Args:\n            stat: The status to set\n        \"\"\"\n        logger.debug(\n            \"/Job-%s Status changed: %r -&gt; %r\",\n            self.index,\n            *JobStatus.get_name(self._status, stat),\n        )\n        self.prev_status = self._status\n        self._status = stat\n\n    @propertyDOCS\n    def rc(self) -&gt; int:\n        \"\"\"The return code of the job\"\"\"\n        if not self.rc_file.is_file():\n            return self._rc  # pragma: no cover\n        return int(self.rc_file.read_text())\n\n    def clean(self, retry=False):DOCS\n        \"\"\"Clean up the meta files\n\n        Args:\n            retry: Whether clean it for retrying\n        \"\"\"\n        files_to_clean = [\n            self.stdout_file,\n            self.stderr_file,\n            self.status_file,\n            self.rc_file,\n        ]\n\n        if retry:\n            retry_dir = self.retry_dir / str(self.trial_count)\n            if retry_dir.exists():\n                retry_dir.rmtree()\n            retry_dir.mkdir(parents=True)\n\n            for file in files_to_clean:\n                if file.is_file():\n                    file.rename(retry_dir / file.name)\n        else:\n            for file in files_to_clean:\n                if file.is_file():\n                    file.unlink()\n</code></pre>"},{"location":"api/source/xqute/","title":"xqute","text":""},{"location":"api/source/xqute/","title":"SOURCE CODE xqute DOCS","text":"<pre><code>\"\"\"A job management system for python\"\"\"\n\nfrom .defaults import JobStatus, JobErrorStrategy\nfrom .xqute import Xqute\nfrom .plugin import plugin\nfrom .utils import logger\nfrom .job import Job\nfrom .scheduler import Scheduler\n\n__version__ = \"0.10.17\"\n</code></pre>"},{"location":"api/source/xqute.path/","title":"xqute.path","text":""},{"location":"api/source/xqute.path/","title":"SOURCE CODE xqute.path DOCS","text":"<pre><code>\"\"\"Provides the SpecPath and MountedPath classes.\n\nIt is used to represent paths of jobs and it is useful when a job is running in a\nremote system (a VM, a container, etc.), where we need to mount the paths into\nthe remote system (MountedPath).\n\nBut in the system where this framework is running, we need to use the paths\n(specified directly) that are used in the framework, where we also need to carry\nthe information of the mounted path (SpecPath).\n\nThe module provides two main abstract base classes:\n- `MountedPath`: Represents a path as it appears in the remote execution environment.\n- `SpecPath`: Represents a path as it appears in the local environment where the\nframework runs.\n\nBoth classes have implementations for local paths and various cloud storage paths,\nincluding:\n- Google Cloud Storage\n- Azure Blob Storage\n- Amazon S3\n\nThese classes maintain the relationship between the local and remote path\nrepresentations, allowing transparent path operations while preserving both path\ncontexts.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom abc import ABC\nfrom pathlib import Path\nfrom typing import Any\n\nfrom yunpath import AnyPath, CloudPath, GSPath, AzureBlobPath, S3Path\n\nLocalPath = type(Path())\n\n__all__ = [\"SpecPath\", \"MountedPath\"]\n\n\nclass MountedPath(ABC):DOCS\n    \"\"\"A router class to instantiate the correct path based on the path type\n    for the mounted path.\n\n    This abstract base class serves as a factory that creates appropriate mounted path\n    instances based on the input path type. It represents a path as it exists in a\n    remote execution environment (e.g., container, VM) while maintaining a reference to\n    the corresponding path in the local environment.\n\n    Attributes:\n        _spec: The corresponding path in the local environment (SpecPath).\n\n    Examples:\n        &gt;&gt;&gt; # Create a mounted path with corresponding spec path\n        &gt;&gt;&gt; mounted_path = MountedPath(\n        &gt;&gt;&gt;   \"/container/data/file.txt\", spec=\"/local/data/file.txt\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; str(mounted_path)\n        '/container/data/file.txt'\n        &gt;&gt;&gt; str(mounted_path.spec)\n        '/local/data/file.txt'\n\n        &gt;&gt;&gt; # Create a GCS mounted path\n        &gt;&gt;&gt; gs_path = MountedPath(\"gs://bucket/file.txt\", spec=\"/local/file.txt\")\n        &gt;&gt;&gt; type(gs_path)\n        &lt;class 'xqute.path.MountedGSPath'&gt;\n    \"\"\"\n\n    def __new__(  # type: ignoreDOCS\n        cls,\n        path: str | Path | CloudPath,\n        spec: str | Path | CloudPath | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; MountedLocalPath | MountedCloudPath:\n        \"\"\"Factory method to create the appropriate MountedPath subclass instance.\n\n        Args:\n            path: The path string or object representing the mounted path location.\n            spec: The path string or object representing the corresponding spec path.\n                If None, the mounted path itself will be used as the spec path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            An instance of the appropriate MountedPath subclass based on the path type:\n            - MountedGSPath for Google Cloud Storage paths\n            - MountedAzureBlobPath for Azure Blob Storage paths\n            - MountedS3Path for Amazon S3 paths\n            - MountedLocalPath for local filesystem paths\n        \"\"\"\n\n        if cls is MountedPath:\n            path = AnyPath(path)  # type: ignore\n            if isinstance(path, GSPath):\n                mounted_class = MountedGSPath\n            elif isinstance(path, AzureBlobPath):  # pragma: no cover\n                mounted_class = MountedAzureBlobPath  # type: ignore\n            elif isinstance(path, S3Path):  # pragma: no cover\n                mounted_class = MountedS3Path  # type: ignore\n            else:\n                mounted_class = MountedLocalPath  # type: ignore\n\n            return mounted_class.__new__(mounted_class, path, spec, *args, **kwargs)\n\n        return super().__new__(cls)  # type: ignore # pragma: no cover\n\n    @propertyDOCS\n    def spec(self) -&gt; SpecPath:\n        \"\"\"Get the corresponding spec path in the local environment.\n\n        Returns:\n            SpecPath: The path as it appears in the local environment.\n        \"\"\"\n        return SpecPath(self._spec, mounted=self)  # type: ignore\n\n    def is_mounted(self) -&gt; bool:DOCS\n        \"\"\"Check if this path is actually mounted (different from spec path).\n\n        Returns:\n            bool: True if the mounted path is different from the spec path, False\n            otherwise.\n        \"\"\"\n        # Direct string comparison instead of using equality operator\n        return str(self._spec) != str(self)\n\n    def __repr__(self):DOCS\n        \"\"\"Generate a string representation of the MountedPath.\n\n        Returns:\n            str: A string showing the class name, path, and spec path (if different).\n        \"\"\"\n        # Check if spec is different by string comparison rather than using is_mounted()\n        if self.is_mounted():\n            return f\"{type(self).__name__}('{self}', spec='{self._spec}')\"\n        else:\n            return f\"{type(self).__name__}('{self}')\"\n\n    def __eq__(self, other: Any) -&gt; bool:DOCS\n        \"\"\"Check equality with another path object.\n\n        Two MountedPath objects are equal if they have the same path string\n        and the same spec path string.\n\n        Args:\n            other: Another object to compare with.\n\n        Returns:\n            bool: True if the paths are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, (Path, CloudPath)):\n            return False\n\n        if isinstance(other, MountedPath):\n            return str(self) == str(other) and str(self.spec) == str(other.spec)\n\n        return str(self) == str(other)\n\n    def __hash__(self) -&gt; int:DOCS\n        \"\"\"Generate a hash for the MountedPath.\n\n        Returns:\n            int: A hash value based on the path string and spec path string.\n        \"\"\"\n        return hash((str(self), str(self.spec)))\n\n\nclass MountedLocalPath(MountedPath, LocalPath):  # type: ignoreDOCS\n    \"\"\"A class to represent a mounted local path\n\n    This class represents a path in a local filesystem as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Attributes:\n        _spec: The corresponding path in the local environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedLocalPath(\"/container/data/file.txt\",\n        ...                               spec=\"/local/data/file.txt\")\n        &gt;&gt;&gt; str(mounted_path)\n        '/container/data/file.txt'\n        &gt;&gt;&gt; str(mounted_path.spec)\n        '/local/data/file.txt'\n        &gt;&gt;&gt; mounted_path.name\n        'file.txt'\n    \"\"\"\n\n    def __new__(DOCS\n        cls,\n        path: str | Path,\n        spec: str | Path | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Create a new MountedLocalPath instance.\n\n        Args:\n            path: The path string or object representing the mounted local path.\n            spec: The path string or object representing the corresponding spec path.\n                If None, the mounted path itself will be used as the spec path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            A new MountedLocalPath instance.\n        \"\"\"\n        if sys.version_info &gt;= (3, 12):\n            obj = object.__new__(cls)\n        else:  # pragma: no cover\n            obj = cls._from_parts((path, *args))\n\n        spec = spec or obj\n        if isinstance(spec, (Path, CloudPath)):\n            obj._spec = spec\n        else:\n            obj._spec = AnyPath(spec)\n\n        return obj\n\n    def __init__(\n        self,\n        path: str | Path,\n        spec: str | Path | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize a MountedLocalPath instance.\n\n        Args:\n            path: The path string or object representing the mounted local path.\n            spec: The path string or object representing the corresponding spec path.\n                If None, the mounted path itself will be used as the spec path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n        \"\"\"\n        if sys.version_info &gt;= (3, 12):\n            # For python 3.9, object initalized by ._from_parts()\n            LocalPath.__init__(self, path, *args, **kwargs)\n\n    def with_segments(self, *pathsegments) -&gt; MountedPath:DOCS\n        \"\"\"Create a new path by replacing all segments with the given segments.\n\n        Args:\n            *pathsegments: The path segments to use in the new path.\n\n        Returns:\n            MountedPath: A new mounted path with the specified segments.\n\n        Raises:\n            NotImplementedError: If Python version is lower than 3.10.\n        \"\"\"\n        if sys.version_info &gt;= (3, 12):\n            new_path = LocalPath(*pathsegments)\n            pathsegments = tuple(str(p) for p in pathsegments)\n            new_spec = AnyPath(self._spec).with_segments(*pathsegments)\n\n            return MountedPath(new_path, spec=new_spec)\n\n        raise NotImplementedError(  # pragma: no cover\n            \"'with_segments' needs Python 3.10 or higher\"\n        )\n\n    def with_name(self, name):DOCS\n        \"\"\"Return a new path with the name changed.\n\n        Args:\n            name: The new name for the path.\n\n        Returns:\n            MountedPath: A new mounted path with the name changed in both\n                the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.with_name(self, name)\n        new_spec = AnyPath(self._spec).with_name(name)\n\n        return MountedPath(new_path, spec=new_spec)\n\n    def with_suffix(self, suffix):DOCS\n        \"\"\"Return a new path with the suffix changed.\n\n        Args:\n            suffix: The new suffix for the path.\n\n        Returns:\n            MountedPath: A new mounted path with the suffix changed in both\n                the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.with_suffix(self, suffix)\n        new_spec = AnyPath(self._spec).with_suffix(suffix)\n\n        return MountedPath(new_path, spec=new_spec)\n\n    def joinpath(self, *pathsegments) -&gt; MountedPath:DOCS\n        \"\"\"Join path components to this path.\n\n        Args:\n            *pathsegments: The path segments to append to this path.\n\n        Returns:\n            MountedPath: A new mounted path with the segments appended to both\n                the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.joinpath(self, *pathsegments)\n        new_spec = AnyPath(self._spec).joinpath(*pathsegments)\n\n        return MountedPath(new_path, spec=new_spec)\n\n    def __truediv__(self, key):DOCS\n        \"\"\"Implement the / operator for paths.\n\n        Args:\n            key: The path segment to append to this path.\n\n        Returns:\n            MountedPath: A new mounted path with the segment appended.\n        \"\"\"\n        # it was not implemented with .with_segments()\n        return self.joinpath(key)\n\n    @propertyDOCS\n    def parent(self):\n        \"\"\"Get the parent directory of this path.\n\n        Returns:\n            MountedPath: A new mounted path representing the parent directory\n                of both the mounted path and spec path.\n        \"\"\"\n        new_path = LocalPath.parent.fget(self)\n        new_spec = AnyPath(self._spec).parent\n\n        return MountedPath(new_path, spec=new_spec)\n\n\nclass MountedCloudPath(MountedPath, CloudPath):DOCS\n    \"\"\"A class to represent a mounted cloud path\n\n    This class represents a cloud storage path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Attributes:\n        _spec: The corresponding path in the local environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",\n        ...                          spec=\"gs://local-bucket/file.txt\")\n        &gt;&gt;&gt; str(mounted_path)\n        'gs://bucket/file.txt'\n        &gt;&gt;&gt; str(mounted_path.spec)\n        'gs://local-bucket/file.txt'\n    \"\"\"\n\n    def __new__(DOCS\n        cls,\n        path: str | Path | CloudPath,\n        spec: str | Path | CloudPath | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Create a new MountedCloudPath instance.\n\n        Args:\n            path: The path string or object representing the mounted cloud path.\n            spec: The path string or object representing the corresponding spec path.\n                If None, the mounted path itself will be used as the spec path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            A new MountedCloudPath instance.\n        \"\"\"\n        obj = object.__new__(cls)\n        spec = spec or obj\n        if isinstance(spec, (Path, CloudPath)):\n            obj._spec = spec\n        else:\n            obj._spec = AnyPath(spec)\n\n        return obj\n\n    def __init__(\n        self,\n        path: str | Path | CloudPath,\n        spec: str | Path | CloudPath | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize a MountedCloudPath instance.\n\n        Args:\n            path: The path string or object representing the mounted cloud path.\n            spec: The path string or object representing the corresponding spec path.\n                If None, the mounted path itself will be used as the spec path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n        \"\"\"\n        super().__init__(path, *args, **kwargs)  # type: ignore\n\n    def __truediv__(self, other):DOCS\n        \"\"\"Implement the / operator for cloud paths.\n\n        Args:\n            other: The path segment to append to this path.\n\n        Returns:\n            MountedPath: A new mounted cloud path with the segment appended.\n        \"\"\"\n        # it was not implemented with .with_segments()\n        out = CloudPath.joinpath(self, other)\n        spec = AnyPath(self._spec).joinpath(other)\n        return MountedPath(out, spec=spec)\n\n    def with_name(self, name):DOCS\n        \"\"\"Return a new path with the name changed.\n\n        Args:\n            name: The new name for the path.\n\n        Returns:\n            MountedPath: A new mounted path with the name changed in both\n                the mounted path and spec path.\n        \"\"\"\n        out = CloudPath.with_name(self, name)\n        spec = AnyPath(self._spec).with_name(name)\n        return MountedPath(out, spec=spec)\n\n    def with_suffix(self, suffix):DOCS\n        \"\"\"Return a new path with the suffix changed.\n\n        Args:\n            suffix: The new suffix for the path.\n\n        Returns:\n            MountedPath: A new mounted path with the suffix changed in both\n                the mounted path and spec path.\n        \"\"\"\n        out = CloudPath.with_suffix(self, suffix)\n        spec = AnyPath(self._spec).with_suffix(suffix)\n        return MountedPath(out, spec=spec)\n\n    def with_segments(self, *pathsegments):DOCS\n        \"\"\"Create a new path by replacing all segments with the given segments.\n\n        Args:\n            *pathsegments: The path segments to use in the new path.\n\n        Returns:\n            MountedPath: A new mounted path with the specified segments.\n        \"\"\"\n        out = CloudPath.with_segments(self, *pathsegments)\n        spec = AnyPath(self._spec).with_segments(*pathsegments)\n        return MountedPath(out, spec=spec)\n\n    def with_stem(self, stem):DOCS\n        \"\"\"Return a new path with the stem changed.\n\n        The stem is the filename without the suffix.\n\n        Args:\n            stem: The new stem for the path.\n\n        Returns:\n            MountedPath: A new mounted path with the stem changed in both\n                the mounted path and spec path.\n        \"\"\"\n        out = CloudPath.with_stem(self, stem)\n        spec = AnyPath(self._spec).with_stem(stem)\n        return MountedPath(out, spec=spec)\n\n    def joinpath(self, *pathsegments):DOCS\n        \"\"\"Join path components to this path.\n\n        Args:\n            *pathsegments: The path segments to append to this path.\n\n        Returns:\n            MountedPath: A new mounted path with the segments appended to both\n                the mounted path and spec path.\n        \"\"\"\n        out = CloudPath.joinpath(self, *pathsegments)\n        spec = AnyPath(self._spec).joinpath(*pathsegments)\n        return MountedPath(out, spec=spec)\n\n    @propertyDOCS\n    def parent(self):\n        \"\"\"Get the parent directory of this path.\n\n        Returns:\n            MountedPath: A new mounted path representing the parent directory\n                of both the mounted path and spec path.\n        \"\"\"\n        out = CloudPath.parent.fget(self)\n        spec = AnyPath(self._spec).parent\n        return MountedPath(out, spec=spec)\n\n\nclass MountedGSPath(MountedCloudPath, GSPath):DOCS\n    \"\"\"A class to represent a mounted Google Cloud Storage path\n\n    This class represents a Google Cloud Storage path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"gs://bucket/file.txt\",\n        ...                          spec=\"gs://local-bucket/file.txt\")\n        &gt;&gt;&gt; isinstance(mounted_path, MountedGSPath)\n        True\n    \"\"\"\n\n\nclass MountedAzureBlobPath(MountedCloudPath, AzureBlobPath):DOCS\n    \"\"\"A class to represent a mounted Azure Blob Storage path\n\n    This class represents an Azure Blob Storage path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"az://container/blob\",\n        ...                          spec=\"az://local-container/blob\")\n        &gt;&gt;&gt; isinstance(mounted_path, MountedAzureBlobPath)\n        True\n    \"\"\"\n\n\nclass MountedS3Path(MountedCloudPath, S3Path):DOCS\n    \"\"\"A class to represent a mounted Amazon S3 path\n\n    This class represents an Amazon S3 path as it appears in a remote\n    execution environment, while maintaining a reference to its corresponding\n    path in the framework's environment.\n\n    Examples:\n        &gt;&gt;&gt; mounted_path = MountedPath(\"s3://bucket/key\",\n        ...                          spec=\"s3://local-bucket/key\")\n        &gt;&gt;&gt; isinstance(mounted_path, MountedS3Path)\n        True\n    \"\"\"\n\n\nclass SpecPath(ABC):DOCS\n    \"\"\"A router class to instantiate the correct path based on the path type\n    for the spec path.\n\n    This abstract base class serves as a factory that creates appropriate spec path\n    instances based on the input path type. It represents a path in the local\n    environment where the framework runs, while maintaining a reference to the\n    corresponding path in the remote execution environment.\n\n    Attributes:\n        _mounted: The corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; # Create a spec path with corresponding mounted path\n        &gt;&gt;&gt; spec_path = SpecPath(\n        &gt;&gt;&gt;   \"/local/data/file.txt\", mounted=\"/container/data/file.txt\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; str(spec_path)\n        '/local/data/file.txt'\n        &gt;&gt;&gt; str(spec_path.mounted)\n        '/container/data/file.txt'\n\n        &gt;&gt;&gt; # Create a GCS spec path\n        &gt;&gt;&gt; gs_path = SpecPath(\n        &gt;&gt;&gt;   \"gs://bucket/file.txt\", mounted=\"gs://container-bucket/file.txt\"\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; type(gs_path)\n        &lt;class 'xqute.path.SpecGSPath'&gt;\n    \"\"\"\n\n    def __new__(  # type: ignoreDOCS\n        cls,\n        path: str | Path | CloudPath,\n        mounted: str | Path | CloudPath | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; SpecLocalPath | SpecCloudPath:\n        \"\"\"Factory method to create the appropriate SpecPath subclass instance.\n\n        Args:\n            path: The path string or object representing the spec path.\n            mounted: The path string or object representing the corresponding mounted\n                path. If None, the spec path itself will be used as the mounted path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            An instance of the appropriate SpecPath subclass based on the path type:\n            - SpecGSPath for Google Cloud Storage paths\n            - SpecAzureBlobPath for Azure Blob Storage paths\n            - SpecS3Path for Amazon S3 paths\n            - SpecLocalPath for local filesystem paths\n        \"\"\"\n        if cls is SpecPath:\n            path = AnyPath(path)  # type: ignore\n            if isinstance(path, GSPath):\n                spec_class = SpecGSPath\n            elif isinstance(path, AzureBlobPath):  # pragma: no cover\n                spec_class = SpecAzureBlobPath  # type: ignore\n            elif isinstance(path, S3Path):  # pragma: no cover\n                spec_class = SpecS3Path  # type: ignore\n            else:\n                spec_class = SpecLocalPath\n\n            return spec_class.__new__(\n                spec_class, path, mounted, *args, **kwargs  # type: ignore\n            )\n\n        return super().__new__(cls)  # type: ignore # pragma: no cover\n\n    @propertyDOCS\n    def mounted(self) -&gt; MountedPath:\n        \"\"\"Get the corresponding mounted path in the remote environment.\n\n        Returns:\n            MountedPath: The path as it appears in the remote execution environment.\n        \"\"\"\n        # Make sure we handle the case where _mounted might not be set\n        return MountedPath(self._mounted, spec=self)  # type: ignore\n\n    def __repr__(self) -&gt; str:DOCS\n        \"\"\"Generate a string representation of the SpecPath.\n\n        Returns:\n            str: A string showing the class name, path, and mounted path (if different).\n        \"\"\"\n        if self.mounted.is_mounted():\n            return f\"{type(self).__name__}('{self}', mounted='{self._mounted}')\"\n        else:\n            return f\"{type(self).__name__}('{self}')\"\n\n    def __eq__(self, other: Any) -&gt; bool:DOCS\n        \"\"\"Check equality with another path object.\n\n        Two SpecPath objects are equal if they have the same path string\n        and the same mounted path string.\n\n        Args:\n            other: Another object to compare with.\n\n        Returns:\n            bool: True if the paths are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, (Path, CloudPath)):\n            return False\n\n        if isinstance(other, SpecPath):\n            return str(self) == str(other) and str(self.mounted) == str(other.mounted)\n\n        return str(self) == str(other)\n\n    def __hash__(self) -&gt; int:DOCS\n        \"\"\"Generate a hash for the SpecPath.\n\n        Returns:\n            int: A hash value based on the path string and mounted path string.\n        \"\"\"\n        return hash((str(self), str(self.mounted)))\n\n\nclass SpecLocalPath(SpecPath, LocalPath):  # type: ignoreDOCS\n    \"\"\"A class to represent a spec local path\n\n    This class represents a path in the local filesystem as it appears in the\n    framework's environment, while maintaining a reference to its corresponding\n    path in the remote execution environment.\n\n    Attributes:\n        _mounted: The corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecLocalPath(\"/local/data/file.txt\",\n        ...                         mounted=\"/container/data/file.txt\")\n        &gt;&gt;&gt; str(spec_path)\n        '/local/data/file.txt'\n        &gt;&gt;&gt; str(spec_path.mounted)\n        '/container/data/file.txt'\n        &gt;&gt;&gt; spec_path.name\n        'file.txt'\n    \"\"\"\n\n    def __new__(DOCS\n        cls,\n        path: str | Path,\n        mounted: str | Path | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Create a new SpecLocalPath instance.\n\n        Args:\n            path: The path string or object representing the spec local path.\n            mounted: The path string or object representing the corresponding mounted\n                path. If None, the spec path itself will be used as the mounted path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            A new SpecLocalPath instance.\n        \"\"\"\n        if sys.version_info &gt;= (3, 12):\n            obj = object.__new__(cls)\n        else:  # pragma: no cover\n            obj = cls._from_parts((path, *args))\n\n        mounted = mounted or obj\n        if isinstance(mounted, (Path, CloudPath)):\n            obj._mounted = mounted\n        else:\n            obj._mounted = AnyPath(mounted)\n\n        return obj\n\n    def __init__(\n        self,\n        path: str | Path,\n        mounted: str | Path | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize a SpecLocalPath instance.\n\n        Args:\n            path: The path string or object representing the spec local path.\n            mounted: The path string or object representing the corresponding mounted\n                path. If None, the spec path itself will be used as the mounted path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n        \"\"\"\n        if sys.version_info &gt;= (3, 12):\n            # For python 3.9, object initalized by ._from_parts()\n            LocalPath.__init__(self, path, *args, **kwargs)\n\n    def with_segments(self, *pathsegments) -&gt; SpecPath:DOCS\n        \"\"\"Create a new path by replacing all segments with the given segments.\n\n        Args:\n            *pathsegments: The path segments to use in the new path.\n\n        Returns:\n            SpecPath: A new spec path with the specified segments.\n        \"\"\"\n        new_path = LocalPath(*pathsegments)\n        pathsegments = [str(p) for p in pathsegments]\n        new_mounted = AnyPath(self._mounted).with_segments(*pathsegments)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def with_name(self, name) -&gt; SpecPath:DOCS\n        \"\"\"Return a new path with the name changed.\n\n        Args:\n            name: The new name for the path.\n\n        Returns:\n            SpecPath: A new spec path with the name changed in both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.with_name(self, name)\n        new_mounted = AnyPath(self._mounted).with_name(name)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def with_suffix(self, suffix) -&gt; SpecPath:DOCS\n        \"\"\"Return a new path with the suffix changed.\n\n        Args:\n            suffix: The new suffix for the path.\n\n        Returns:\n            SpecPath: A new spec path with the suffix changed in both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.with_suffix(self, suffix)\n        new_mounted = AnyPath(self._mounted).with_suffix(suffix)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def with_stem(self, stem) -&gt; SpecPath:DOCS\n        \"\"\"Return a new path with the stem changed.\n\n        The stem is the filename without the suffix.\n\n        Args:\n            stem: The new stem for the path.\n\n        Returns:\n            SpecPath: A new spec path with the stem changed in both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.with_stem(self, stem)\n        new_mounted = AnyPath(self._mounted).with_stem(stem)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def joinpath(self, *pathsegments) -&gt; SpecPath:DOCS\n        \"\"\"Join path components to this path.\n\n        Args:\n            *pathsegments: The path segments to append to this path.\n\n        Returns:\n            SpecPath: A new spec path with the segments appended to both\n                the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.joinpath(self, *pathsegments)\n        new_mounted = AnyPath(self._mounted).joinpath(*pathsegments)\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n    def __truediv__(self, key):DOCS\n        \"\"\"Implement the / operator for paths.\n\n        Args:\n            key: The path segment to append to this path.\n\n        Returns:\n            SpecPath: A new spec path with the segment appended.\n        \"\"\"\n        # it was not implemented with .with_segments()\n        return self.joinpath(key)\n\n    @propertyDOCS\n    def parent(self) -&gt; SpecPath:\n        \"\"\"Get the parent directory of this path.\n\n        Returns:\n            SpecPath: A new spec path representing the parent directory\n                of both the spec path and mounted path.\n        \"\"\"\n        new_path = LocalPath.parent.fget(self)\n        new_mounted = AnyPath(self._mounted).parent\n\n        return SpecPath(new_path, mounted=new_mounted)\n\n\nclass SpecCloudPath(SpecPath, CloudPath):DOCS\n    \"\"\"A class to represent a spec cloud path\n\n    This class represents a cloud storage path as it appears in the local\n    environment where the framework runs, while maintaining a reference to its\n    corresponding path in the remote execution environment.\n\n    Attributes:\n        _mounted: The corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",\n        ...                    mounted=\"gs://container-bucket/file.txt\")\n        &gt;&gt;&gt; str(spec_path)\n        'gs://bucket/file.txt'\n        &gt;&gt;&gt; str(spec_path.mounted)\n        'gs://container-bucket/file.txt'\n    \"\"\"\n\n    def __new__(DOCS\n        cls,\n        path: str | Path,\n        mounted: str | Path | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Create a new SpecCloudPath instance.\n\n        Args:\n            path: The path string or object representing the spec cloud path.\n            mounted: The path string or object representing the corresponding mounted\n                path. If None, the spec path itself will be used as the mounted path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n\n        Returns:\n            A new SpecCloudPath instance.\n        \"\"\"\n        # Fix the debugging print statements which could cause confusion\n        obj = object.__new__(cls)\n        mounted = mounted or obj\n        if isinstance(mounted, (Path, CloudPath)):\n            obj._mounted = mounted\n        else:\n            obj._mounted = AnyPath(mounted)\n        return obj\n\n    def __init__(\n        self,\n        path: str | Path,\n        mounted: str | Path | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize a SpecCloudPath instance.\n\n        Args:\n            path: The path string or object representing the spec cloud path.\n            mounted: The path string or object representing the corresponding mounted\n                path. If None, the spec path itself will be used as the mounted path.\n            *args: Additional positional arguments passed to the path constructor.\n            **kwargs: Additional keyword arguments passed to the path constructor.\n        \"\"\"\n        super().__init__(path, *args, **kwargs)  # type: ignore[arg-type]\n\n    def __truediv__(self, other):DOCS\n        \"\"\"Implement the / operator for cloud paths.\n\n        Args:\n            other: The path segment to append to this path.\n\n        Returns:\n            SpecPath: A new spec cloud path with the segment appended.\n        \"\"\"\n        # Get the new path and mounted path\n        out = CloudPath.joinpath(self, other)\n        mounted = AnyPath(self._mounted).joinpath(other)\n\n        return SpecPath(out, mounted=mounted)\n\n    def with_name(self, name):DOCS\n        \"\"\"Return a new path with the name changed.\n\n        Args:\n            name: The new name for the path.\n\n        Returns:\n            SpecPath: A new spec path with the name changed in both\n                the spec path and mounted path.\n        \"\"\"\n        out = CloudPath.with_name(self, name)\n        mounted = AnyPath(self._mounted).with_name(name)\n        return SpecPath(out, mounted=mounted)\n\n    def with_suffix(self, suffix):DOCS\n        \"\"\"Return a new path with the suffix changed.\n\n        Args:\n            suffix: The new suffix for the path.\n\n        Returns:\n            SpecPath: A new spec path with the suffix changed in both\n                the spec path and mounted path.\n        \"\"\"\n        out = CloudPath.with_suffix(self, suffix)\n        mounted = AnyPath(self._mounted).with_suffix(suffix)\n        return SpecPath(out, mounted=mounted)\n\n    def with_segments(self, *pathsegments):DOCS\n        \"\"\"Create a new path by replacing all segments with the given segments.\n\n        Args:\n            *pathsegments: The path segments to use in the new path.\n\n        Returns:\n            SpecPath: A new spec path with the specified segments.\n        \"\"\"\n        out = CloudPath.with_segments(self, *pathsegments)\n        mounted = AnyPath(self._mounted).with_segments(*pathsegments)\n        return SpecPath(out, mounted=mounted)\n\n    def with_stem(self, stem):DOCS\n        \"\"\"Return a new path with the stem changed.\n\n        The stem is the filename without the suffix.\n\n        Args:\n            stem: The new stem for the path.\n\n        Returns:\n            SpecPath: A new spec path with the stem changed in both\n                the spec path and mounted path.\n        \"\"\"\n        out = CloudPath.with_stem(self, stem)\n        mounted = AnyPath(self._mounted).with_stem(stem)\n        return SpecPath(out, mounted=mounted)\n\n    def joinpath(self, *pathsegments):DOCS\n        \"\"\"Join path components to this path.\n\n        Args:\n            *pathsegments: The path segments to append to this path.\n\n        Returns:\n            SpecPath: A new spec path with the segments appended to both\n                the spec path and mounted path.\n        \"\"\"\n        out = CloudPath.joinpath(self, *pathsegments)\n        mounted = AnyPath(self._mounted).joinpath(*pathsegments)\n        return SpecPath(out, mounted=mounted)\n\n    @propertyDOCS\n    def parent(self):\n        \"\"\"Get the parent directory of this path.\n\n        Returns:\n            SpecPath: A new spec path representing the parent directory\n                of both the spec path and mounted path.\n        \"\"\"\n        out = CloudPath.parent.fget(self)\n        mounted = AnyPath(self._mounted).parent\n        return SpecPath(out, mounted=mounted)\n\n\nclass SpecGSPath(SpecCloudPath, GSPath):DOCS\n    \"\"\"A class to represent a spec Google Cloud Storage path\n\n    This class represents a Google Cloud Storage path as it appears in the\n    local environment where the framework runs, while maintaining a reference\n    to its corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"gs://bucket/file.txt\",\n        ...                    mounted=\"gs://container-bucket/file.txt\")\n        &gt;&gt;&gt; isinstance(spec_path, SpecGSPath)\n        True\n    \"\"\"\n\n\nclass SpecAzureBlobPath(SpecCloudPath, AzureBlobPath):DOCS\n    \"\"\"A class to represent a spec Azure Blob Storage path\n\n    This class represents an Azure Blob Storage path as it appears in the\n    local environment where the framework runs, while maintaining a reference\n    to its corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"az://container/blob\",\n        ...                    mounted=\"az://remote-container/blob\")\n        &gt;&gt;&gt; isinstance(spec_path, SpecAzureBlobPath)\n        True\n    \"\"\"\n\n\nclass SpecS3Path(SpecCloudPath, S3Path):DOCS\n    \"\"\"A class to represent a spec Amazon S3 path\n\n    This class represents an Amazon S3 path as it appears in the\n    local environment where the framework runs, while maintaining a reference\n    to its corresponding path in the remote execution environment.\n\n    Examples:\n        &gt;&gt;&gt; spec_path = SpecPath(\"s3://bucket/key\",\n        ...                    mounted=\"s3://remote-bucket/key\")\n        &gt;&gt;&gt; isinstance(spec_path, SpecS3Path)\n        True\n    \"\"\"\n</code></pre>"},{"location":"api/source/xqute.plugin/","title":"xqute.plugin","text":""},{"location":"api/source/xqute.plugin/","title":"SOURCE CODE xqute.plugin DOCS","text":"<pre><code>\"\"\"Hook specifications for scheduler plugins\"\"\"\n\nfrom __future__ import annotations\n\nimport signal\nfrom typing import TYPE_CHECKING\nfrom simplug import Simplug, SimplugResult  # type: ignore\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .xqute import Xqute\n    from .job import Job\n    from .scheduler import Scheduler\n\n\nplugin = Simplug(\"xqute\")\n\n\n@plugin.specDOCS\ndef on_init(xqute: Xqute):\n    \"\"\"When xqute is initialized\n\n    Note that this hook will run at the same time when producer and consumer\n    start. So they are not ensured to be started at this point.\n\n    Args:\n        xqute: The xqute object\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\ndef on_shutdown(xqute: Xqute, sig: signal.Signals | None):\n    \"\"\"When xqute is shutting down\n\n    Return False to stop shutting down, but you have to shut it down\n    by yourself, for example, `xqute.task.cancel()`\n\n    Only the first return value will be used.\n\n    Args:\n        xqute: The xqute object\n        sig: The signal. `None` means a natural shutdown\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_init(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is initialized\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_queued(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is queued\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\nasync def on_job_submitting(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is to be submitted\n\n    Return False to cancel submitting. Only the first return value is used.\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_submitted(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is submitted\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_started(scheduler: Scheduler, job: Job):\n    \"\"\"When the job starts to run.\n\n    Note that this is not when exactly the job starts to run, but when the\n    scheduler starts to wait for the job to finish. So this hook is not\n    suitable for measuring the time of the job.\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_polling(scheduler: Scheduler, job: Job, counter: int):\n    \"\"\"When the system is polling job status\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n        counter: The polling counter, used to limit the number of polls or\n            skip some polls if the scheduler is busy.\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\nasync def on_job_killing(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is being killed\n\n    Return False to stop killing the job.\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_killed(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is killed\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_failed(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is failed\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_succeeded(scheduler: Scheduler, job: Job):\n    \"\"\"When the job is succeeded\n\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_init(scheduler: Scheduler, job: Job) -&gt; str:\n    \"\"\"When the job command wrapper script is initialized before the prescript is run\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_prep(scheduler: Scheduler, job: Job) -&gt; str:\n    \"\"\"When the job command right about to be run\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n    The bash variable `$cmd` is accessible in the context. It is also possible to\n    modify the `cmd` variable. Just remember to assign the modified value to `cmd`.\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n    Keep in mind that the `$cmd` may be modified by other plugins.\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_end(scheduler: Scheduler, job: Job) -&gt; str:\n    \"\"\"When the job command finishes and after the postscript is run\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n    The bash variable `$rc` is accessible in the context, which is the return code\n    of the job command.\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n    Args:\n        scheduler: The scheduler object\n        job: The job object\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\nplugin.load_entrypoints()\n</code></pre>"},{"location":"api/source/xqute.scheduler/","title":"xqute.scheduler","text":""},{"location":"api/source/xqute.scheduler/","title":"SOURCE CODE xqute.scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to schedule jobs\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport shlex\nimport signal\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import Any, List, Type\n\nfrom yunpath import CloudPath\nfrom diot import Diot  # type: ignore\n\nfrom .defaults import (\n    JobStatus,\n    JobErrorStrategy,\n    JOBCMD_WRAPPER_LANG,\n    JOBCMD_WRAPPER_TEMPLATE,\n    DEFAULT_ERROR_STRATEGY,\n    DEFAULT_NUM_RETRIES,\n    get_jobcmd_wrapper_init,\n)\nfrom .utils import logger, CommandType\nfrom .path import SpecPath\nfrom .job import Job\nfrom .plugin import plugin\n\n\nclass Scheduler(ABC):DOCS\n    \"\"\"The abstract class for scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        jobcmd_wrapper_init: The init script for the job command wrapper\n\n    Args:\n        workdir: The working directory\n        forks: Max number of job forks\n        error_strategy: The strategy when there is error happened\n        num_retries: Max number of retries when error_strategy is retry\n        prescript: The prescript to run before the job command\n            It is a piece of script that inserted into the wrapper script, running\n            on the scheduler system.\n        postscript: The postscript to run when job finished\n            It is a piece of script that inserted into the wrapper script, running\n            on the scheduler system.\n        jobname_prefix: The prefix for the job name\n        recheck_interval: The interval to recheck the job status.\n            Default is every 600 polls (each takes about 0.1 seconds).\n        cwd: The working directory for the job command wrapper\n        **kwargs: Other arguments for the scheduler\n    \"\"\"\n\n    __slots__ = (\n        \"config\",\n        \"forks\",\n        \"workdir\",\n        \"error_strategy\",\n        \"num_retries\",\n        \"prescript\",\n        \"postscript\",\n        \"jobname_prefix\",\n        \"recheck_interval\",\n        \"cwd\",\n    )\n\n    # The name of the scheduler\n    name: str\n    # Should we remove the jid file after job done\n    # This is useful for local scheduler and alike. The biggest reason for this is\n    # that the pid can be reused by other processes, which might cause the\n    # scheduler to think the job is still running.\n    # But for schedulers like google batch jobs, the jid file is used to delete\n    # the job if we want to retry the job.\n    remove_jid_after_done: bool = True\n    job_class: Type[Job] = Job\n\n    def __init__(\n        self,\n        workdir: str | Path | CloudPath,\n        forks: int = 1,\n        error_strategy: str = DEFAULT_ERROR_STRATEGY,\n        num_retries: int = DEFAULT_NUM_RETRIES,\n        prescript: str = \"\",\n        postscript: str = \"\",\n        jobname_prefix: str | None = None,\n        recheck_interval: int = 600,\n        cwd: str | Path = None,\n        **kwargs,\n    ):\n        self.forks = forks\n        mounted_workdir = kwargs.pop(\"mounted_workdir\", None)\n        self.workdir = SpecPath(workdir, mounted=mounted_workdir)\n\n        self.error_strategy = error_strategy\n        self.num_retries = num_retries\n        self.prescript = prescript\n        self.postscript = postscript\n        self.jobname_prefix = jobname_prefix or self.name\n        self.recheck_interval = recheck_interval\n        self.cwd = None if cwd is None else str(cwd)\n\n        self.config = Diot(**kwargs)\n\n    def create_job(DOCS\n        self,\n        index: int,\n        cmd: CommandType,\n        envs: dict[str, Any] | None = None,\n    ) -&gt; Job:\n        \"\"\"Create a job\n\n        Args:\n            index: The index of the job\n            cmd: The command of the job\n\n        Returns:\n            The job\n        \"\"\"\n        return self.job_class(\n            index=index,\n            cmd=cmd,\n            workdir=self.workdir,\n            error_retry=self.error_strategy == JobErrorStrategy.RETRY,\n            num_retries=self.num_retries,\n            envs=envs,\n        )\n\n    async def submit_job_and_update_status(self, job: Job):DOCS\n        \"\"\"Submit and update the status\n\n        1. Check if the job is already submitted or running\n        2. If not, run the hook\n        3. If the hook is not cancelled, clean the job\n        4. Submit the job, raising an exception if it fails\n        5. If the job is submitted successfully, update the status\n        6. If the job fails to submit, update the status and write stderr to\n            the job file\n\n        Args:\n            job: The job\n        \"\"\"\n        if await self.job_is_submitted_or_running(job):\n            logger.warning(\n                \"/Scheduler-%s Skip submitting, \"\n                \"job %r is already submitted or running.\",\n                self.name,\n                job,\n            )\n            return\n\n        exception: Exception | None = None\n        try:\n            if await plugin.hooks.on_job_submitting(self, job) is False:\n                logger.info(\n                    \"/Scheduler-%s Job %s submission cancelled by hook.\",\n                    self.name,\n                    job.index,\n                )\n                return\n\n            logger.debug(\n                \"/Scheduler-%s Cleaning job %s before submission\",\n                self.name,\n                job.index,\n            )\n            job.clean()\n\n            try:\n                # raise the exception immediately\n                # it somehow cannot be catched immediately\n                logger.debug(\n                    \"/Scheduler-%s Submitting job %s ...\",\n                    self.name,\n                    job.index,\n                )\n                job.jid = await self.submit_job(job)\n            except Exception as exc:\n                exception = RuntimeError(f\"Failed to submit job: {exc}\")\n                exception.__traceback__ = exc.__traceback__\n            else:\n                logger.info(\n                    \"/Scheduler-%s Job %s submitted (jid: %s, wrapped: %s)\",\n                    self.name,\n                    job.index,\n                    job.jid,\n                    self.wrapped_job_script(job),\n                )\n\n                job.status = JobStatus.SUBMITTED\n                await plugin.hooks.on_job_submitted(self, job)\n        except Exception as exc:  # pragma: no cover\n            exception = exc\n\n        if exception is not None:\n            from traceback import format_exception\n\n            job.stderr_file.write_text(\n                \"\".join(\n                    format_exception(\n                        type(exception),\n                        exception,\n                        exception.__traceback__,\n                    )\n                ),\n            )\n            job.rc_file.write_text(\"-2\")\n            job.status = JobStatus.FAILED\n            await plugin.hooks.on_job_failed(self, job)\n\n    async def retry_job(self, job: Job):DOCS\n        \"\"\"Retry a job\n\n        Args:\n            job: The job\n        \"\"\"\n        job.jid = \"\"\n        job.clean(retry=True)\n        job.trial_count += 1\n        logger.warning(\n            \"/Scheduler-%s Retrying (#%s) job: %r\",\n            self.name,\n            job.trial_count,\n            job,\n        )\n        await self.submit_job_and_update_status(job)\n\n    async def kill_job_and_update_status(self, job: Job):DOCS\n        \"\"\"Kill a job and update its status\n\n        Args:\n            job: The job\n        \"\"\"\n        job.status = JobStatus.KILLING\n        ret = await plugin.hooks.on_job_killing(self, job)\n        if ret is False:  # pragma: no cover\n            logger.info(\n                \"/Scheduler-%s Job %s killing cancelled by hook.\",\n                self.name,\n                job.index,\n            )\n            return\n\n        logger.warning(\"/Scheduler-%s Killing job %s ...\", self.name, job.index)\n        await self.kill_job(job)\n        try:\n            # in case the jid file is removed by the wrapped script\n            logger.debug(\n                \"/Scheduler-%s Removing jid file %s ...\",\n                self.name,\n                job.jid_file,\n            )\n            job.jid_file.unlink(missing_ok=True)\n        except Exception:  # pragma: no cover\n            # missing_ok is not working for some cloud paths\n            # FileNotFoundError, google.api_core.exceptions.NotFound\n            pass\n\n        job.status = JobStatus.FINISHED\n        logger.info(\n            \"/Scheduler-%s Job %s killed, calling hook ...\",\n            self.name,\n            job.index,\n        )\n        await plugin.hooks.on_job_killed(self, job)\n\n    async def polling_jobs(DOCS\n        self,\n        jobs: List[Job],\n        on: str,\n        polling_counter: int,\n    ) -&gt; bool:\n        \"\"\"Check if all jobs are done or new jobs can submit\n\n        Args:\n            jobs: The list of jobs\n            on: query on status: `submittable` or `all_done`\n            polling_counter: The polling counter, used to limit the number of polls or\n                skip some polls if the scheduler is busy.\n\n        Returns:\n            True if yes otherwise False.\n        \"\"\"\n        n_running = 0\n        ret = True\n        logger.debug(\n            \"/Scheduler-%s Polling jobs (%s) (%s) ...\",\n            self.name,\n            on,\n            polling_counter,\n        )\n        for job in jobs:\n            status = job.status\n            if on == \"submittable\" and status in (\n                JobStatus.QUEUED,\n                JobStatus.SUBMITTED,\n                JobStatus.RUNNING,\n                JobStatus.KILLING,\n            ):\n                logger.debug(\n                    \"/Scheduler-%s Job %s is %s, incrementing n_running to (%s)...\",\n                    self.name,\n                    job.index,\n                    JobStatus.get_name(status),\n                    n_running + 1,\n                )\n                n_running += 1\n\n            if job.prev_status != status:\n                if status in (JobStatus.FAILED, JobStatus.RETRYING):\n                    logger.debug(\n                        \"/Scheduler-%s Job %s changed status: %s -&gt; %s\",\n                        self.name,\n                        job.index,\n                        JobStatus.get_name(job.prev_status),\n                        JobStatus.get_name(status),\n                    )\n\n                    if job.prev_status != JobStatus.RUNNING:\n                        logger.debug(\n                            \"/Scheduler-%s Job %s was not running before failure, \"\n                            \"running on_job_started hook to ensure lifecycle ...\",\n                            self.name,\n                            job.index,\n                        )\n                        await plugin.hooks.on_job_started(self, job)\n\n                    logger.debug(\n                        \"/Scheduler-%s Job %s calling on_job_failed hook ...\",\n                        self.name,\n                        job.index,\n                    )\n                    await plugin.hooks.on_job_failed(self, job)\n                    if self.remove_jid_after_done:\n                        # We are also doing this in the wrapped script\n                        # But for the could jid file, it is not 100% sure\n                        # the file is removed, because it is still held by\n                        # the GSPath object and in some cases when it is\n                        # recycled, the file is recreated on the cloud.\n                        try:\n                            job.jid_file.unlink(missing_ok=True)\n                        except Exception:  # pragma: no cover\n                            # missing_ok is not working for some cloud paths\n                            # FileNotFoundError, google.api_core.exceptions.NotFound\n                            pass\n                elif status == JobStatus.FINISHED:\n                    logger.debug(\n                        \"/Scheduler-%s Job %s changed status: %s -&gt; %s\",\n                        self.name,\n                        job.index,\n                        JobStatus.get_name(job.prev_status),\n                        JobStatus.get_name(status),\n                    )\n                    if job.prev_status != JobStatus.RUNNING:\n                        logger.debug(\n                            \"/Scheduler-%s Job %s was not running before finishing, \"\n                            \"running on_job_started hook to ensure lifecycle ...\",\n                            self.name,\n                            job.index,\n                        )\n                        await plugin.hooks.on_job_started(self, job)\n\n                    logger.debug(\n                        \"/Scheduler-%s Job %s calling on_job_succeeded hook ...\",\n                        self.name,\n                        job.index,\n                    )\n                    await plugin.hooks.on_job_succeeded(self, job)\n                    if self.remove_jid_after_done:\n                        try:\n                            job.jid_file.unlink(missing_ok=True)\n                        except Exception:  # pragma: no cover\n                            # FileNotFoundError, google.api_core.exceptions.NotFound\n                            pass\n                elif status == JobStatus.RUNNING:\n                    logger.debug(\n                        \"/Scheduler-%s Job %s changed status: %s -&gt; %s\",\n                        self.name,\n                        job.index,\n                        JobStatus.get_name(job.prev_status),\n                        JobStatus.get_name(status),\n                    )\n                    logger.debug(\n                        \"/Scheduler-%s Job %s calling on_job_started hook ...\",\n                        self.name,\n                        job.index,\n                    )\n                    await plugin.hooks.on_job_started(self, job)\n            elif status == JobStatus.SUBMITTED:  # pragma: no cover\n                # Check if the job fails before running\n                if await self.job_fails_before_running(job):\n                    logger.warning(\n                        \"/Scheduler-%s Job %s seems to fail before running, \"\n                        \"check your scheduler logs if necessary.\",\n                        self.name,\n                        job.index,\n                    )\n                    job.status = JobStatus.FAILED\n                    job.rc_file.write_text(\"-3\")\n                    with job.stderr_file.open(\"a\") as f:\n                        f.write(\n                            \"\\nError: job seems to fail before running.\\n\"\n                            \"Check your scheduler logs if necessary.\\n\",\n                        )\n\n                    await plugin.hooks.on_job_failed(self, job)\n                    if self.error_strategy == JobErrorStrategy.HALT:\n                        logger.error(\n                            \"/Scheduler-%s Pipeline will halt since job failed: %r\",\n                            self.name,\n                            job,\n                        )\n                        os.kill(os.getpid(), signal.SIGTERM)\n                        # job.status = JobStatus.FINISHED\n                        break\n            elif status == JobStatus.RUNNING:\n                logger.debug(\n                    \"/Scheduler-%s Job %s is running, calling polling hook ...\",\n                    self.name,\n                    job.index,\n                )\n                # Call the polling hook\n                await plugin.hooks.on_job_polling(self, job, polling_counter)\n                # Let's make sure the job is really running\n                # For example, a node can be preempted by the cloud and\n                # the job status and rc will not be updated\n                # If we have an rc file, that means the job is done\n                # and we can skip the polling\n                if (\n                    not job.rc_file.is_file()\n                    and (polling_counter + 1) % self.recheck_interval == 0\n                    and not await self.job_is_running(job)\n                ):  # pragma: no cover\n                    logger.warning(\n                        \"/Scheduler-%s Job %s is not running in the scheduler, \"\n                        \"but its status is still RUNNING, setting it to FAILED\",\n                        self.name,\n                        job.index,\n                    )\n                    job.status = JobStatus.FAILED\n                    job.rc_file.write_text(\"-3\")\n                    with job.stderr_file.open(\"a\") as f:\n                        f.write(\n                            \"\\nError: job is not running in the scheduler, \"\n                            \"but its status is still RUNNING.\\n\",\n                            \"It is likely that the resource is preempted.\\n\",\n                        )\n\n                    await plugin.hooks.on_job_failed(self, job)\n                    if self.error_strategy == JobErrorStrategy.HALT:\n                        logger.error(\n                            \"/Scheduler-%s Pipeline will halt since job failed: %r\",\n                            self.name,\n                            job,\n                        )\n                        os.kill(os.getpid(), signal.SIGTERM)\n                        # job.status = JobStatus.FINISHED\n                        break\n\n            if (\n                self.error_strategy == JobErrorStrategy.HALT\n                and status == JobStatus.FAILED\n            ):\n                logger.error(\n                    \"/Scheduler-%s Pipeline will halt since job failed: %r\",\n                    self.name,\n                    job,\n                )\n                os.kill(os.getpid(), signal.SIGTERM)\n                # job.status = JobStatus.FINISHED\n                break\n\n            if status not in (JobStatus.FINISHED, JobStatus.FAILED):\n                logger.debug(\n                    \"/Scheduler-%s Not all jobs are done yet, job %s is %s\",\n                    self.name,\n                    job.index,\n                    JobStatus.get_name(status),\n                )\n                # Try to resubmit the job for retrying\n                if status == JobStatus.RETRYING:\n                    logger.debug(\n                        \"/Scheduler-%s Job %s is retrying ...\",\n                        self.name,\n                        job.index,\n                    )\n                    await self.retry_job(job)\n                ret = False\n                # not returning here\n                # might wait for callbacks or halt on other jobs\n        return n_running &lt; self.forks if on == \"submittable\" else ret\n\n    async def kill_running_jobs(self, jobs: List[Job]):DOCS\n        \"\"\"Try to kill all running jobs\n\n        Args:\n            jobs: The list of jobs\n        \"\"\"\n        logger.warning(\"/Scheduler-%s Killing running jobs ...\", self.name)\n        for job in jobs:\n            status = job.status\n            if status in (JobStatus.SUBMITTED, JobStatus.RUNNING):\n                await self.kill_job_and_update_status(job)\n\n    async def job_is_submitted_or_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Check if a job is already submitted or running\n\n        Args:\n            job: The job\n\n        Returns:\n            True if yes otherwise False.\n        \"\"\"\n        if job.jid_file.is_file():\n            if await self.job_is_running(job):\n                job.status = JobStatus.SUBMITTED\n                return True\n        return False\n\n    async def job_fails_before_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Check if a job fails before running.\n\n        For some schedulers, the job might fail before running (after submission).\n        For example, the job might fail to allocate resources. In such a case,\n        the wrapped script might not be executed, and the job status will not be\n        updated (stays in SUBMITTED). We need to check such jobs and mark them as\n        FAILED.\n\n        For the instant scheduler, for example, the local scheduler, the failure will\n        be immediately reported when submitting the job, so we don't need to check\n        such jobs.\n\n        Args:\n            job: The job to check\n\n        Returns:\n            True if the job fails before running, otherwise False.\n        \"\"\"\n        return False\n\n    @propertyDOCS\n    def jobcmd_wrapper_init(self) -&gt; str:\n        \"\"\"The init script for the job command wrapper\"\"\"\n        wrapper_init = get_jobcmd_wrapper_init(\n            not isinstance(self.workdir.mounted, CloudPath),\n            self.remove_jid_after_done,\n        )\n        if self.cwd:\n            # Some schedulers (e.g. Google Cloud Batch) doesn't support changing the\n            # working directory via configuration, so we need to change it in the\n            # wrapper script.\n            # See: https://issuetracker.google.com/issues/336164416\n            wrapper_init = f\"cd {shlex.quote(self.cwd)}\\n\\n{wrapper_init}\"\n\n        return wrapper_init\n\n    def jobcmd_shebang(self, job: Job) -&gt; str:DOCS\n        \"\"\"The shebang of the wrapper script\"\"\"\n        wrapper_lang = (\n            JOBCMD_WRAPPER_LANG\n            if isinstance(JOBCMD_WRAPPER_LANG, (tuple, list))\n            else [JOBCMD_WRAPPER_LANG]\n        )\n        return shlex.join(wrapper_lang)\n\n    def jobcmd_init(self, job) -&gt; str:DOCS\n        \"\"\"The job command init\"\"\"\n        init_code = []\n        if job.envs:\n            init_code.append(\"# Environment variables\")\n            init_code.extend(\n                [\n                    f\"export {key}={shlex.quote(str(value))}\"\n                    for key, value in job.envs.items()\n                ]\n            )\n\n        codes = plugin.hooks.on_jobcmd_init(self, job)\n        init_code.extend([code for code in codes if code])\n        return \"\\n\".join(init_code)\n\n    def jobcmd_prep(self, job) -&gt; str:DOCS\n        \"\"\"The job command preparation\"\"\"\n        codes = plugin.hooks.on_jobcmd_prep(self, job)\n        codes = [code for code in codes if code]\n        return \"\\n\".join(codes)\n\n    def jobcmd_end(self, job) -&gt; str:DOCS\n        \"\"\"The job command end\"\"\"\n        codes = plugin.hooks.on_jobcmd_end(self, job)\n        codes = [code for code in codes if code]\n        return \"\\n\".join(codes)\n\n    def wrap_job_script(self, job: Job) -&gt; str:DOCS\n        \"\"\"Wrap the job script\n\n        Args:\n            job: The job\n\n        Returns:\n            The wrapped script\n        \"\"\"\n        return JOBCMD_WRAPPER_TEMPLATE.format(\n            scheduler=self,\n            shebang=self.jobcmd_shebang(job),\n            status=JobStatus,\n            job=job,\n            cmd=shlex.join(job.cmd),\n            jobcmd_init=self.jobcmd_init(job),\n            jobcmd_prep=self.jobcmd_prep(job),\n            jobcmd_end=self.jobcmd_end(job),\n        )\n\n    def wrapped_job_script(self, job: Job) -&gt; SpecPath:DOCS\n        \"\"\"Get the wrapped job script\n\n        Args:\n            job: The job\n\n        Returns:\n            The path of the wrapped job script\n        \"\"\"\n        base = f\"job.wrapped.{self.name}\"\n        wrapt_script = job.metadir / base\n        wrapt_script.write_text(self.wrap_job_script(job))\n\n        return wrapt_script\n\n    @abstractmethodDOCS\n    async def submit_job(self, job: Job) -&gt; int | str:\n        \"\"\"Submit a job\n\n        Args:\n            job: The job\n\n        Returns:\n            The unique id in the scheduler system\n        \"\"\"\n\n    @abstractmethodDOCS\n    async def kill_job(self, job: Job):\n        \"\"\"Kill a job\n\n        Args:\n            job: The job\n        \"\"\"\n\n    @abstractmethodDOCS\n    async def job_is_running(self, job: Job) -&gt; bool:\n        \"\"\"Check if a job is really running\n\n        Args:\n            job: The job\n\n        Returns:\n            True if yes otherwise False.\n        \"\"\"\n</code></pre>"},{"location":"api/source/xqute.schedulers.container_scheduler/","title":"xqute.schedulers.container_scheduler","text":""},{"location":"api/source/xqute.schedulers.container_scheduler/","title":"SOURCE CODE xqute.schedulers.container_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs via containers\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport shlex\nimport shutil\nfrom pathlib import Path\nfrom typing import List, Sequence\n\nfrom ..job import Job\nfrom ..defaults import JOBCMD_WRAPPER_LANG\nfrom ..path import SpecPath\nfrom .local_scheduler import LocalScheduler\nfrom .gbatch_scheduler import NAMED_MOUNT_RE, DEFAULT_MOUNTED_ROOT\n\nCONTAINER_TYPES = {\n    \"docker\": \"docker\",\n    \"podman\": \"podman\",\n    \"apptainer\": \"apptainer\",\n    \"singularity\": \"apptainer\",\n}\n\n\nclass ContainerScheduler(LocalScheduler):DOCS\n    \"\"\"Scheduler to run jobs via containers (Docker/Podman/Apptainer)\n\n    This scheduler can execute jobs inside containers using Docker, Podman,\n    or Apptainer.\n\n    Args:\n        image: Container image to use for running jobs\n        entrypoint: Entrypoint command for the container\n        bin: Path to container runtime binary (e.g. /path/to/docker)\n        volumes: host:container volume mapping string or strings\n            or named volume mapping like `MOUNTED=/path/on/host`\n            then it will be mounted to `/mnt/disks/MOUNTED` in the container.\n            You can use environment variable `MOUNTED` in your job scripts to\n            refer to the mounted path.\n        user: User to run the container as (only for Docker/Podman)\n            By default, it runs as the current user (os.getuid() and os.getgid())\n        remove: Whether to remove the container after execution.\n            Only applies to Docker/Podman.\n        bin_args: Additional arguments to pass to the container runtime\n        **kwargs: Additional arguments passed to parent Scheduler\n    \"\"\"\n\n    name = \"container\"\n\n    __slots__ = (\n        \"image\",\n        \"entrypoint\",\n        \"bin\",\n        \"volumes\",\n        # \"envs\",\n        \"remove\",\n        \"user\",\n        \"bin_args\",\n        \"_container_type\",\n        \"_path_envs\",\n    )\n\n    def __init__(\n        self,\n        image: str,\n        entrypoint: str | List[str] = JOBCMD_WRAPPER_LANG,\n        bin: str = \"docker\",\n        volumes: str | Sequence[str] | None = None,\n        # envs: Dict[str, str] | None = None,\n        remove: bool = True,\n        user: str | None = None,\n        bin_args: List[str] | None = None,\n        **kwargs,\n    ):\n        if \"mount\" in kwargs:\n            raise ValueError(\n                \"You used 'mount' argument for container scheduler, \"\n                \"did you mean 'volumes'?\"\n            )\n\n        kwargs.setdefault(\"mounted_workdir\", f\"{DEFAULT_MOUNTED_ROOT}/xqute_workdir\")\n        super().__init__(**kwargs)\n\n        self.bin = shutil.which(bin)\n        if not self.bin:\n            raise ValueError(f\"Container runtime binary '{bin}' not found in PATH\")\n\n        self.image = image\n        self.entrypoint = (\n            list(entrypoint) if isinstance(entrypoint, (list, tuple)) else [entrypoint]\n        )\n        self._path_envs = {}\n        self.volumes = volumes or []\n        self.volumes = (\n            [self.volumes] if isinstance(self.volumes, str) else list(self.volumes)\n        )\n        for i, vol in enumerate(self.volumes):\n            if NAMED_MOUNT_RE.match(vol):\n                name, host_path = vol.split(\"=\", 1)\n                host_path_obj = Path(host_path).expanduser().resolve()\n                if not host_path_obj.exists():\n                    raise FileNotFoundError(\n                        f\"Volume host path '{host_path}' does not exist\"\n                    )\n                if host_path_obj.is_file():\n                    host_path = str(host_path_obj.parent)\n                    mount_path = (\n                        f\"{DEFAULT_MOUNTED_ROOT}/{name}/{host_path_obj.parent.name}\"\n                    )\n                    self._path_envs[name] = f\"{mount_path}/{host_path_obj.name}\"\n                    self.volumes[i] = f\"{host_path}:{mount_path}\"\n                else:\n                    host_path = str(host_path_obj)\n                    mount_path = f\"{DEFAULT_MOUNTED_ROOT}/{name}\"\n                    self._path_envs[name] = mount_path\n                    self.volumes[i] = f\"{host_path}:{mount_path}\"\n\n        # self.envs = envs or {}\n        self.remove = remove\n        self.user = user or f\"{os.getuid()}:{os.getgid()}\"\n        self.bin_args = bin_args or []\n        self.volumes.append(f\"{self.workdir}:{self.workdir.mounted}\")\n\n        self._container_type = CONTAINER_TYPES.get(\n            Path(self.bin).name.lower(),\n            \"docker\",\n        )\n        if self._container_type in (\"docker\", \"podman\") and self.image.startswith(\n            \"docker://\"\n        ):\n            # Convert docker://image to image name\n            self.image = self.image[9:]\n\n    def wrapped_job_script(self, job: Job) -&gt; SpecPath:DOCS\n        \"\"\"Get the wrapped job script\n\n        Args:\n            job: The job\n\n        Returns:\n            The path of the wrapped job script\n        \"\"\"\n        base = f\"job.wrapped.{self._container_type}\"\n        wrapt_script = job.metadir / base\n        wrapt_script.write_text(self.wrap_job_script(job))\n\n        return wrapt_script\n\n    def jobcmd_shebang(self, job: Job) -&gt; str:DOCS\n        \"\"\"The shebang of the wrapper script\"\"\"\n        cmd = [self.bin, \"run\"]\n        if self._container_type == \"apptainer\":\n            if self.cwd:  # pragma: no cover\n                cmd.extend([\"--pwd\", self.cwd])\n            else:\n                cmd.extend([\"--pwd\", str(self.workdir.mounted)])\n            for key, value in job.envs.items():\n                cmd.extend([\"--env\", f\"{key}={value}\"])\n            for vol in self.volumes:\n                cmd.extend([\"--bind\", f\"{vol}\"])\n        else:\n            if self.remove:\n                cmd.append(\"--rm\")\n            cmd.extend([\"--user\", self.user])\n            for key, value in job.envs.items():\n                cmd.extend([\"-e\", f\"{key}={value}\"])\n            for vol in self.volumes:\n                cmd.extend([\"-v\", vol])\n\n            if self.cwd:\n                cmd.extend([\"--workdir\", self.cwd])\n            else:\n                cmd.extend([\"--workdir\", str(self.workdir.mounted)])\n\n        cmd.extend(self.bin_args)\n        cmd.append(self.image)\n        cmd.extend(self.entrypoint)\n\n        return shlex.join(cmd)\n\n    async def submit_job(self, job: Job) -&gt; int:  # type: ignore[override]DOCS\n        \"\"\"Submit a job locally\n\n        Args:\n            job: The job\n\n        Returns:\n            The process id\n        \"\"\"\n        return await super().submit_job(job, _mounted=True)\n\n    def jobcmd_init(self, job) -&gt; str:DOCS\n        init_cmd = super().jobcmd_init(job)\n        path_envs_exports = [\n            f\"export {key}={shlex.quote(value)}\"\n            for key, value in self._path_envs.items()\n        ]\n        if path_envs_exports:\n            path_envs_exports.insert(0, \"# Mounted paths\")\n            init_cmd = \"\\n\".join(path_envs_exports) + \"\\n\" + init_cmd\n\n        return init_cmd\n</code></pre>"},{"location":"api/source/xqute.schedulers.gbatch_scheduler/","title":"xqute.schedulers.gbatch_scheduler","text":""},{"location":"api/source/xqute.schedulers.gbatch_scheduler/","title":"SOURCE CODE xqute.schedulers.gbatch_scheduler DOCS","text":"<pre><code>from __future__ import annotations\n\nimport asyncio\nimport json\nimport re\nimport shlex\nimport getpass\nfrom typing import Sequence\nfrom copy import deepcopy\nfrom hashlib import sha256\nfrom yunpath import GSPath, AnyPath\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\nfrom ..defaults import JOBCMD_WRAPPER_LANG\nfrom ..utils import logger\nfrom ..path import SpecPath\n\n\nJOBNAME_PREFIX_RE = re.compile(r\"^[a-zA-Z][a-zA-Z0-9-]{0,47}$\")\nNAMED_MOUNT_RE = re.compile(r\"^[A-Za-z][A-Za-z0-9_]*=.+$\")\nDEFAULT_MOUNTED_ROOT = \"/mnt/disks\"\n\n\nclass GbatchScheduler(Scheduler):DOCS\n    \"\"\"Scheduler for Google Cloud Batch\n\n    You can pass extra configuration parameters to the constructor\n    that will be used in the job configuration file.\n    For example, you can pass `taskGroups` to specify the task groups\n    and their specifications.\n\n    For using containers, it is a little bit tricky to specify the commands.\n    When no `entrypoint` is specified, the `commands` should be a list\n    with the first element being the interpreter (e.g. `/bin/bash`)\n    and the second element being the path to the wrapped job script.\n    If the `entrypoint` is specified, we can use the `{lang}` and `{script}`\n    placeholders in the `commands` list, where `{lang}` will be replaced\n    with the interpreter (e.g. `/bin/bash`) and `{script}` will be replaced\n    with the path to the wrapped job script.\n    With `entrypoint` specified and no `{script}` placeholder, the joined command\n    will be the interpreter followed by the path to the wrapped job script will be\n    appended to the `commands` list.\n\n    Args:\n        project: GCP project ID\n        location: GCP location (e.g. us-central1)\n        mount: GCS path to mount (e.g. gs://my-bucket:/mnt/my-bucket)\n            You can pass a list of mounts.\n            You can also use named mount like `NAME=gs://bucket/dir`\n            then it will be mounted to `/mnt/disks/NAME` in the container.\n            You can use environment variable `NAME` in your job scripts to\n            refer to the mounted path.\n        service_account: GCP service account email (e.g. test-account@example.com)\n        network: GCP network (e.g. default-network)\n        subnetwork: GCP subnetwork (e.g. regions/us-central1/subnetworks/default)\n        no_external_ip_address: Whether to disable external IP address\n        machine_type: GCP machine type (e.g. e2-standard-4)\n        provisioning_model: GCP provisioning model (e.g. SPOT)\n        image_uri: Container image URI (e.g. ubuntu-2004-lts)\n        entrypoint: Container entrypoint (e.g. /bin/bash)\n        commands: The command list to run in the container.\n            There are three ways to specify the commands:\n            1. If no entrypoint is specified, the final command will be\n            [commands, wrapped_script], where the entrypoint is the wrapper script\n            interpreter that is determined by `JOBCMD_WRAPPER_LANG` (e.g. /bin/bash),\n            commands is the list you provided, and wrapped_script is the path to the\n            wrapped job script.\n            2. You can specify something like \"-c\", then the final command\n            will be [\"-c\", \"wrapper_script_interpreter, wrapper_script\"]\n            3. You can use the placeholders `{lang}` and `{script}` in the commands\n            list, where `{lang}` will be replaced with the interpreter (e.g. /bin/bash)\n            and `{script}` will be replaced with the path to the wrapped job script.\n            For example, you can specify [\"{lang} {script}\"] and the final command\n            will be [\"wrapper_interpreter, wrapper_script\"]\n        runnables: Additional runnables to run before or after the main job.\n            Each runnable should be a dictionary that follows the\n            [GCP Batch API specification](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#runnable).\n            You can also specify an \"order\" key in the dictionary to control the\n            execution order of the runnables. Runnables with negative order\n            will be executed before the main job, and those with non-negative\n            order will be executed after the main job. The main job runnable\n            will always be executed in the order it is defined in the list.\n        *args, **kwargs: Other arguments passed to base Scheduler class\n    \"\"\"  # noqa: E501\n\n    name = \"gbatch\"\n\n    __slots__ = Scheduler.__slots__ + (\n        \"gcloud\",\n        \"project\",\n        \"location\",\n        \"runnable_index\",\n        \"_path_envs\",\n    )\n\n    def __init__(\n        self,\n        *args,\n        project: str,\n        location: str,\n        mount: str | Sequence[str] | None = None,\n        service_account: str | None = None,\n        network: str | None = None,\n        subnetwork: str | None = None,\n        no_external_ip_address: bool | None = None,\n        machine_type: str | None = None,\n        provisioning_model: str | None = None,\n        image_uri: str | None = None,\n        entrypoint: str = None,\n        commands: str | Sequence[str] | None = None,\n        runnables: Sequence[dict] | None = None,\n        **kwargs,\n    ):\n        \"\"\"Construct the gbatch scheduler\"\"\"\n        self.gcloud = kwargs.pop(\"gcloud\", \"gcloud\")\n        self.project = project\n        self.location = location\n        kwargs.setdefault(\"mounted_workdir\", f\"{DEFAULT_MOUNTED_ROOT}/xqute_workdir\")\n        super().__init__(*args, **kwargs)\n\n        if not isinstance(self.workdir, GSPath):\n            raise ValueError(\n                \"'gbatch' scheduler requires google cloud storage 'workdir'.\"\n            )\n\n        if not JOBNAME_PREFIX_RE.match(self.jobname_prefix):\n            raise ValueError(\n                \"'jobname_prefix' for gbatch scheduler doesn't follow pattern \"\n                \"^[a-zA-Z][a-zA-Z0-9-]{0,47}$.\"\n            )\n\n        self._path_envs = {}\n        task_groups = self.config.setdefault(\"taskGroups\", [])\n        if not task_groups:\n            task_groups.append({})\n        if not task_groups[0]:\n            task_groups[0] = {}\n\n        task_spec = task_groups[0].setdefault(\"taskSpec\", {})\n        task_runnables = task_spec.setdefault(\"runnables\", [])\n\n        # Process additional runnables with ordering\n        additional_runnables = []\n        if runnables:\n            for runnable_dict in runnables:\n                runnable_copy = deepcopy(runnable_dict)\n                order = runnable_copy.pop(\"order\", 0)\n                additional_runnables.append((order, runnable_copy))\n\n        # Sort by order\n        additional_runnables.sort(key=lambda x: x[0])\n\n        # Create main job runnable\n        if not task_runnables:\n            task_runnables.append({})\n        if not task_runnables[0]:\n            task_runnables[0] = {}\n\n        job_runnable = task_runnables[0]\n        if \"container\" in job_runnable or image_uri:\n            job_runnable.setdefault(\"container\", {})\n            if not isinstance(job_runnable[\"container\"], dict):  # pragma: no cover\n                raise ValueError(\n                    \"'taskGroups[0].taskSpec.runnables[0].container' should be a \"\n                    \"dictionary for gbatch configuration.\"\n                )\n            if image_uri:\n                job_runnable[\"container\"].setdefault(\"image_uri\", image_uri)\n            if entrypoint:\n                job_runnable[\"container\"].setdefault(\"entrypoint\", entrypoint)\n\n            job_runnable[\"container\"].setdefault(\"commands\", commands or [])\n        else:\n            job_runnable[\"script\"] = {\n                \"text\": None,  # placeholder for job command\n                \"_commands\": commands,  # Store commands for later use\n            }\n\n        # Clear existing runnables and rebuild with proper ordering\n        task_runnables.clear()\n\n        # Add runnables with negative order (before job)\n        for order, runnable_dict in additional_runnables:\n            if order &lt; 0:\n                task_runnables.append(runnable_dict)\n\n        # Add the main job runnable\n        task_runnables.append(job_runnable)\n        self.runnable_index = len(task_runnables) - 1\n\n        # Add runnables with positive order (after job)\n        for order, runnable_dict in additional_runnables:\n            if order &gt;= 0:\n                task_runnables.append(runnable_dict)\n\n        # Only logs the stdout/stderr of submission (when wrapped script doesn't run)\n        # The logs of the wrapped script are logged to stdout/stderr files\n        # in the workdir.\n        logs_policy = self.config.setdefault(\"logsPolicy\", {})\n        logs_policy.setdefault(\"destination\", \"CLOUD_LOGGING\")\n\n        volumes = task_spec.setdefault(\"volumes\", [])\n        if not isinstance(volumes, list):\n            raise ValueError(\n                \"'taskGroups[0].taskSpec.volumes' should be a list for \"\n                \"gbatch configuration.\"\n            )\n\n        volumes.insert(\n            0,\n            {\n                \"gcs\": {\"remotePath\": self.workdir._no_prefix},\n                \"mountPath\": str(self.workdir.mounted),\n            },\n        )\n\n        if mount and not isinstance(mount, (tuple, list)):\n            mount = [mount]  # type: ignore\n        if mount:\n            for m in mount:\n                # Let's check if mount is provided as \"OUTDIR=gs://bucket/dir\"\n                # If so, we mounted it to $DEFAULT_MOUNTED_ROOT/OUTDIR\n                # and set OUTDIR env variable to the mounted path in self._path_envs\n                if NAMED_MOUNT_RE.match(m):\n                    name, gcs = m.split(\"=\", 1)\n                    if not gcs.startswith(\"gs://\"):\n                        raise ValueError(\n                            \"When using named mount, it should be in the format \"\n                            \"'NAME=gs://bucket/dir', where NAME matches \"\n                            \"^[A-Za-z][A-Za-z0-9_]*$\"\n                        )\n                    gcs_path = AnyPath(gcs)\n                    # Check if it is a file path\n                    if gcs_path.is_file():\n                        # Mount the parent directory\n                        gcs = str(gcs_path.parent._no_prefix)\n                        mount_path = (\n                            f\"{DEFAULT_MOUNTED_ROOT}/{name}/{gcs_path.parent.name}\"\n                        )\n                        self._path_envs[name] = f\"{mount_path}/{gcs_path.name}\"\n                    else:\n                        gcs = gcs[5:]\n                        mount_path = f\"{DEFAULT_MOUNTED_ROOT}/{name}\"\n                        self._path_envs[name] = mount_path\n\n                    volumes.append(\n                        {\n                            \"gcs\": {\"remotePath\": gcs},\n                            \"mountPath\": mount_path,\n                        }\n                    )\n                else:\n                    # Or, we expect a literal mount \"gs://bucket/dir:/mount/path\"\n                    gcs, mount_path = m.rsplit(\":\", 1)\n                    if gcs.startswith(\"gs://\"):\n                        gcs = gcs[5:]\n                    volumes.append(\n                        {\n                            \"gcs\": {\"remotePath\": gcs},\n                            \"mountPath\": mount_path,\n                        }\n                    )\n\n        # Add some labels for filtering by `gcloud batch jobs list`\n        labels = self.config.setdefault(\"labels\", {})\n\n        labels.setdefault(\"xqute\", \"true\")\n        labels.setdefault(\"user\", getpass.getuser())\n\n        allocation_policy = self.config.setdefault(\"allocationPolicy\", {})\n\n        if service_account:\n            allocation_policy.setdefault(\"serviceAccount\", {}).setdefault(\n                \"email\", service_account\n            )\n\n        if network or subnetwork or no_external_ip_address is not None:\n            network_interface = allocation_policy.setdefault(\"network\", {}).setdefault(\n                \"networkInterfaces\", []\n            )\n            if not network_interface:\n                network_interface.append({})\n            network_interface = network_interface[0]\n            if network:\n                network_interface.setdefault(\"network\", network)\n            if subnetwork:\n                network_interface.setdefault(\"subnetwork\", subnetwork)\n            if no_external_ip_address is not None:\n                network_interface.setdefault(\n                    \"noExternalIpAddress\", no_external_ip_address\n                )\n\n        if machine_type or provisioning_model:\n            instances = allocation_policy.setdefault(\"instances\", [])\n            if not instances:\n                instances.append({})\n            policy = instances[0].setdefault(\"policy\", {})\n            if machine_type:\n                policy.setdefault(\"machineType\", machine_type)\n            if provisioning_model:\n                policy.setdefault(\"provisioningModel\", provisioning_model)\n\n        email = allocation_policy.get(\"serviceAccount\", {}).get(\"email\")\n        if email:\n            # 63 character limit, '@' is not allowed in labels\n            # labels.setdefault(\"email\", email[:63])\n            labels.setdefault(\"sacct\", email.split(\"@\", 1)[0][:63])\n\n    def job_config_file(self, job: Job) -&gt; SpecPath:\n        base = f\"job.wrapped.{self.name}.json\"\n        conf_file = job.metadir / base\n\n        wrapt_script = self.wrapped_job_script(job)\n        config = deepcopy(self.config)\n        runnable = config[\"taskGroups\"][0][\"taskSpec\"][\"runnables\"][self.runnable_index]\n        if \"container\" in runnable:\n            container = runnable[\"container\"]\n            if \"entrypoint\" not in container:\n                # supports only /bin/bash, but not /bin/bash -u\n                container[\"entrypoint\"] = JOBCMD_WRAPPER_LANG\n                container[\"commands\"].append(str(wrapt_script.mounted))\n            elif any(\"{script}\" in cmd for cmd in container[\"commands\"]):\n                # If the entrypoint is already set, we assume it is a script\n                # that will be executed with the job command.\n                container[\"commands\"] = [\n                    cmd.replace(\"{lang}\", str(JOBCMD_WRAPPER_LANG)).replace(\n                        \"{script}\", str(wrapt_script.mounted)\n                    )\n                    for cmd in container[\"commands\"]\n                ]\n            else:\n                container[\"commands\"].append(\n                    shlex.join(\n                        shlex.split(JOBCMD_WRAPPER_LANG) + [str(wrapt_script.mounted)]\n                    )\n                )\n        else:\n            # Apply commands for script runnables as well\n            stored_commands = runnable[\"script\"].pop(\"_commands\", None)\n            if stored_commands:\n                if any(\"{script}\" in str(cmd) for cmd in stored_commands):\n                    # Use commands with script placeholder replacement\n                    command_parts = [\n                        shlex.quote(cmd)\n                        .replace(\"{lang}\", str(JOBCMD_WRAPPER_LANG))\n                        .replace(\"{script}\", str(wrapt_script.mounted))\n                        for cmd in stored_commands\n                    ]\n                else:\n                    # Append script to commands\n                    command_parts = [\n                        *(shlex.quote(str(cmd)) for cmd in stored_commands),\n                        shlex.quote(\n                            shlex.join(\n                                (\n                                    *shlex.split(JOBCMD_WRAPPER_LANG),\n                                    str(wrapt_script.mounted),\n                                )\n                            )\n                        ),\n                    ]\n            else:\n                command_parts = [\n                    *shlex.split(JOBCMD_WRAPPER_LANG),\n                    str(wrapt_script.mounted),\n                ]\n\n            runnable[\"script\"][\"text\"] = \" \".join(command_parts)\n\n        with conf_file.open(\"w\") as f:\n            json.dump(config, f, indent=2)\n\n        return conf_file\n\n    async def _delete_job(self, job: Job) -&gt; None:\n        \"\"\"Try to delete the job from google cloud's registry\n\n        As google doesn't allow jobs to have the same id.\n\n        Args:\n            job: The job to delete\n        \"\"\"\n        logger.debug(\n            \"/Scheduler-%s Try deleting job %r on GCP.\",\n            self.name,\n            job,\n        )\n        status = await self._get_job_status(job)\n        while status.endswith(\"_IN_PROGRESS\"):  # pragma: no cover\n            await asyncio.sleep(1)\n            status = await self._get_job_status(job)\n\n        command = [\n            self.gcloud,\n            \"batch\",\n            \"jobs\",\n            \"delete\",\n            job.jid,\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n        ]\n\n        try:\n            proc = await asyncio.create_subprocess_exec(\n                *command,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n            )\n        except Exception:\n            pass\n        else:  # pragma: no cover\n            await proc.wait()\n\n        status = await self._get_job_status(job)\n        while status == \"DELETION_IN_PROGRESS\":  # pragma: no cover\n            await asyncio.sleep(1)\n            status = await self._get_job_status(job)\n\n        if status != \"UNKNOWN\":  # pragma: no cover\n            logger.warning(\n                \"/Scheduler-%s Failed to delete job %r on GCP, submision may fail.\",\n                self.name,\n                job,\n            )\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n\n        sha = sha256(str(self.workdir).encode()).hexdigest()[:8]\n        job.jid = f\"{self.jobname_prefix}-{sha}-{job.index}\".lower()\n        await self._delete_job(job)\n\n        conf_file = self.job_config_file(job)\n        proc = await asyncio.create_subprocess_exec(\n            self.gcloud,\n            \"batch\",\n            \"jobs\",\n            \"submit\",\n            job.jid,\n            \"--config\",\n            conf_file.fspath,\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.STDOUT,\n        )\n\n        stdout, _ = await proc.communicate()\n        if proc.returncode != 0:  # pragma: no cover\n            raise RuntimeError(\n                \"Can't submit job to Google Cloud Batch: \\n\"\n                f\"{stdout.decode()}\\n\"\n                \"Check the configuration file:\\n\"\n                f\"{conf_file}\"\n            )\n\n        return job.jid\n\n    async def kill_job(self, job: Job):DOCS\n        command = [\n            self.gcloud,\n            \"alpha\",\n            \"batch\",\n            \"jobs\",\n            \"cancel\",\n            job.jid,\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n            \"--quiet\",\n        ]\n        proc = await asyncio.create_subprocess_exec(\n            *command,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n\n    async def _get_job_status(self, job: Job) -&gt; str:\n        if not job.jid_file.is_file():\n            return \"UNKNOWN\"\n\n        # Do not rely on _jid, as it can be a obolete job.\n        jid = job.jid_file.read_text().strip()\n\n        command = [\n            self.gcloud,\n            \"batch\",\n            \"jobs\",\n            \"describe\",\n            jid,\n            \"--project\",\n            self.project,\n            \"--location\",\n            self.location,\n        ]\n\n        try:\n            proc = await asyncio.create_subprocess_exec(\n                *command,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n            )\n        except Exception:  # pragma: no cover\n            return \"UNKNOWN\"\n\n        if await proc.wait() != 0:\n            return \"UNKNOWN\"\n\n        stdout = (await proc.stdout.read()).decode()\n        return re.search(r\"state: (.+)\", stdout).group(1)\n\n    async def job_fails_before_running(self, job: Job) -&gt; bool:  # pragma: no coverDOCS\n        status = await self._get_job_status(job)\n        return status in (\"FAILED\", \"DELETION_IN_PROGRESS\", \"CANCELLED\")\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        status = await self._get_job_status(job)\n        return status in (\"RUNNING\", \"QUEUED\", \"SCHEDULED\")\n\n    def jobcmd_init(self, job) -&gt; str:DOCS\n        init_cmd = super().jobcmd_init(job)\n        path_envs_exports = [\n            f\"export {key}={shlex.quote(value)}\"\n            for key, value in self._path_envs.items()\n        ]\n        if path_envs_exports:\n            path_envs_exports.insert(0, \"# Mounted paths\")\n            init_cmd = \"\\n\".join(path_envs_exports) + \"\\n\" + init_cmd\n\n        return init_cmd\n</code></pre>"},{"location":"api/source/xqute.schedulers.local_scheduler/","title":"xqute.schedulers.local_scheduler","text":""},{"location":"api/source/xqute.schedulers.local_scheduler/","title":"SOURCE CODE xqute.schedulers.local_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs locally\"\"\"\n\nimport asyncio\nimport os\nimport shlex\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\n\n\ndef _pid_exists(pid: int) -&gt; bool:\n    \"\"\"Check if a process with a given pid exists\"\"\"\n    try:\n        os.kill(pid, 0)\n    except Exception:  # pragma: no cover\n        return False\n    return True\n\n\nclass LocalScheduler(Scheduler):DOCS\n    \"\"\"The local scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n    \"\"\"\n\n    name = \"local\"\n\n    async def submit_job(self, job: Job, _mounted: bool = False) -&gt; int:DOCS\n        \"\"\"Submit a job locally\n\n        Args:\n            job: The job\n            _mounted: Whether to use the mounted path of the wrapped job script\n                Used internally for container scheduler\n\n        Returns:\n            The process id\n        \"\"\"\n        wrapt_script_path = (\n            self.wrapped_job_script(job).mounted\n            if _mounted\n            else self.wrapped_job_script(job).fspath\n        )\n        # In case the process exits very quickly\n        if not job.jid_file.exists():\n            job.jid_file.write_text(\"0\")\n\n        proc = await asyncio.create_subprocess_exec(\n            *shlex.split(self.jobcmd_shebang(job)),\n            wrapt_script_path,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.STDOUT,\n            start_new_session=True,\n            # Changing the working directory here may cause wrapped_job_script to fail\n            # to be found, so we don't set cwd here.\n            # The cwd is changed in the wrapper script instead.\n            # cwd=self.cwd\n        )\n\n        # wait for a while to make sure the process is running\n        # this is to avoid the real command is not run when proc is recycled too early\n        # this happens for python &lt; 3.12\n        await asyncio.sleep(0.1)\n\n        if job.stdout_file.exists():\n            # job submitted successfully and already started very soon\n            return proc.pid\n\n        if proc.returncode is not None and proc.returncode != 0:\n            # The process has already finished and no stdout/stderr files are\n            # generated\n            # Something went wrong with the wrapper script?\n            stderr = await proc.stdout.read()\n            raise RuntimeError(\n                f\"Failed to submit job #{job.index} (rc={proc.returncode}): \"\n                f\"{stderr.decode()}\\n\"\n                f\"Command: {self.jobcmd_shebang(job)} \"\n                f\"{wrapt_script_path}\\n\"\n            )\n\n        # don't await for the results, as this will run the real command\n        return proc.pid\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job asynchronously\n\n        Args:\n            job: The job\n        \"\"\"\n        try:\n            os.killpg(int(job.jid), 9)\n        except Exception:  # pragma: no cover\n            pass\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        try:\n            jid = int(job.jid_file.read_text().strip())\n        except (ValueError, TypeError, FileNotFoundError):\n            return False\n\n        if jid &lt;= 0:\n            return False\n\n        return _pid_exists(jid)\n</code></pre>"},{"location":"api/source/xqute.schedulers/","title":"xqute.schedulers","text":""},{"location":"api/source/xqute.schedulers/","title":"SOURCE CODE xqute.schedulers DOCS","text":"<pre><code>\"\"\"Builtin schedulers\"\"\"\n\nfrom __future__ import annotations\n\nfrom importlib import import_module\nfrom typing import Type\n\nfrom ..scheduler import Scheduler\n\n\ndef get_scheduler(scheduler: str | Type[Scheduler]) -&gt; Type[Scheduler]:DOCS\n    \"\"\"Get the scheduler class\n\n    Args:\n        sched_name: The scheduler name\n            Defined in the scheduler class\n\n    Returns:\n        The scheduler class\n    \"\"\"\n    if isinstance(scheduler, str):\n        module = import_module(f\"{__name__}.{scheduler}_scheduler\")\n        return getattr(module, f\"{scheduler[0].upper()}{scheduler[1:]}Scheduler\")\n    return scheduler\n</code></pre>"},{"location":"api/source/xqute.schedulers.sge_scheduler/","title":"xqute.schedulers.sge_scheduler","text":""},{"location":"api/source/xqute.schedulers.sge_scheduler/","title":"SOURCE CODE xqute.schedulers.sge_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs on SGE\"\"\"\n\nimport asyncio\nimport hashlib\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\n\n\nclass SgeScheduler(Scheduler):DOCS\n    \"\"\"The sge scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n\n    Args:\n        qsub: path to qsub command\n        qstat: path to qstat command\n        qdel: path to qdel command\n        ...: other Scheduler args. List or tuple options will be expanded.\n            For example: `sge_l=['hvmem=2G', 'gpu=1']` will be expaned into\n            `-l h_vmem=2G -l gpu=1`\n    \"\"\"\n\n    name: str = \"sge\"\n\n    __slots__ = Scheduler.__slots__ + (\"qsub\", \"qdel\", \"qstat\")\n\n    def __init__(self, *args, **kwargs):\n        self.qsub = kwargs.pop(\"qsub\", \"qsub\")\n        self.qdel = kwargs.pop(\"qdel\", \"qdel\")\n        self.qstat = kwargs.pop(\"qstat\", \"qstat\")\n        super().__init__(*args, **kwargs)\n\n    def jobcmd_shebang(self, job) -&gt; str:DOCS\n        options = self.config.copy()\n        sha = hashlib.sha256(str(self.workdir).encode()).hexdigest()[:8]\n        options[\"N\"] = f\"{self.jobname_prefix}-{sha}-{job.index}\"\n        if self.cwd:\n            options[\"wd\"] = self.cwd\n        else:\n            options[\"cwd\"] = True\n        # options[\"o\"] = self.stdout_file\n        # options[\"e\"] = self.stderr_file\n\n        options_list = []\n        for key, val in options.items():\n            if val is True:\n                options_list.append(f\"#$ -{key}\")\n            elif isinstance(val, (tuple, list)):\n                for optval in val:\n                    options_list.append(f\"#$ -{key} {optval}\")\n            else:\n                options_list.append(f\"#$ -{key} {val}\")\n\n        return super().jobcmd_shebang(job) + \"\\n\" + \"\\n\".join(options_list)\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n        \"\"\"Submit a job to SGE\n\n        Args:\n            job: The job\n\n        Returns:\n            The job id\n        \"\"\"\n        proc = await asyncio.create_subprocess_exec(\n            self.qsub,\n            self.wrapped_job_script(job).fspath,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        stdout, stderr = await proc.communicate()\n        if proc.returncode != 0:  # pragma: no cover\n            raise RuntimeError(f\"Can't submit job to SGE: {stderr.decode()}\")\n\n        # Your job 613815 (...) has been submitted\n        try:\n            job_id = stdout.decode().split()[2]\n        except Exception:  # pragma: no cover\n            raise RuntimeError(\"Can't get job id from qsub output.\", stdout, stderr)\n\n        return job_id\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job on SGE\n\n        Args:\n            job: The job\n        \"\"\"\n        proc = await asyncio.create_subprocess_exec(\n            self.qdel,\n            str(job.jid),\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        try:\n            jid = job.jid_file.read_text().strip()\n        except FileNotFoundError:  # pragma: no cover\n            return False\n\n        if not jid:\n            return False\n\n        proc = await asyncio.create_subprocess_exec(\n            self.qstat,\n            \"-j\",\n            jid,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        return await proc.wait() == 0\n</code></pre>"},{"location":"api/source/xqute.schedulers.slurm_scheduler/","title":"xqute.schedulers.slurm_scheduler","text":""},{"location":"api/source/xqute.schedulers.slurm_scheduler/","title":"SOURCE CODE xqute.schedulers.slurm_scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs on Slurm\"\"\"\n\nimport asyncio\nimport hashlib\n\nfrom ..job import Job\nfrom ..scheduler import Scheduler\n\n\nclass SlurmScheduler(Scheduler):DOCS\n    \"\"\"The Slurm scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n\n    Args:\n        sbatch: path to sbatch command\n        squeue: path to squeue command\n        scancel: path to scancel command\n        ... other Scheduler args\n    \"\"\"\n\n    name: str = \"slurm\"\n\n    __slots__ = Scheduler.__slots__ + (\"sbatch\", \"squeue\", \"scancel\")\n\n    def __init__(self, *args, **kwargs):\n        self.sbatch = kwargs.pop(\"sbatch\", \"sbatch\")\n        self.squeue = kwargs.pop(\"squeue\", \"squeue\")\n        self.scancel = kwargs.pop(\"scancel\", \"scancel\")\n        super().__init__(*args, **kwargs)\n\n    def jobcmd_shebang(self, job) -&gt; str:DOCS\n        options = self.config.copy()\n\n        sha = hashlib.sha256(str(self.workdir).encode()).hexdigest()[:8]\n        options[\"job-name\"] = f\"{self.jobname_prefix}-{sha}-{job.index}\"\n        options[\"chdir\"] = self.cwd\n        # options[\"output\"] = self.stdout_file\n        # options[\"error\"] = self.stderr_file\n\n        options_list = []\n        for key, val in options.items():\n            key = key.replace(\"_\", \"-\")\n            if len(key) == 1:\n                fmt = \"#SBATCH -{key} {val}\"\n            else:\n                fmt = \"#SBATCH --{key}={val}\"\n            options_list.append(fmt.format(key=key, val=val))\n\n        return super().jobcmd_shebang(job) + \"\\n\" + \"\\n\".join(options_list) + \"\\n\"\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n        \"\"\"Submit a job to Slurm\n\n        Args:\n            job: The job\n\n        Returns:\n            The job id\n        \"\"\"\n        proc = await asyncio.create_subprocess_exec(\n            self.sbatch,\n            self.wrapped_job_script(job).fspath,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.STDOUT,\n        )\n        rc = await proc.wait()\n        if rc != 0:  # pragma: no cover\n            stderr = await proc.stdout.read()\n            raise Exception(stderr.decode().strip())\n\n        stdout = await proc.stdout.read()\n        # salloc: Granted job allocation 65537\n        # sbatch: Submitted batch job 65537\n        return stdout.decode().strip().split()[-1]\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job on Slurm\n\n        Args:\n            job: The job\n        \"\"\"\n        proc = await asyncio.create_subprocess_exec(\n            self.scancel,\n            str(job.jid),\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n\n    async def _get_job_status(self, job: Job) -&gt; str:\n        \"\"\"Tell the status of a job on Slurm\n\n        Args:\n            job: The job\n\n        Returns:\n            The status string\n        \"\"\"\n        try:\n            jid = job.jid_file.read_text().strip()\n        except FileNotFoundError:\n            return \"UNKNOWN\"\n\n        if not jid:\n            return \"UNKNOWN\"\n\n        proc = await asyncio.create_subprocess_exec(\n            self.squeue,\n            \"-j\",\n            jid,\n            \"--noheader\",\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await proc.wait()\n        if proc.returncode != 0:\n            return \"UNKNOWN\"\n\n        # ['8792', 'queue', 'merge', 'user', 'R', '7:34:34', '1', 'server']\n        stdout = await proc.stdout.read()\n        return stdout.decode().strip().split()[4].upper()  # type: ignore\n\n    async def job_fails_before_running(self, job):  # pragma: no coverDOCS\n        status = await self._get_job_status(job)\n        return status in (\n            \"CA\",\n            \"CANCELLED\",\n            \"F\",\n            \"FAILED\",\n            \"NF\",\n            \"NODE_FAIL\",\n            \"PR\",\n            \"PREEMPTED\",\n            \"BF\",\n            \"BOOT_FAIL\",\n            \"SE\",\n            \"SPECIAL_EXIT\",\n            \"ST\",\n            \"STOPPED\",\n            \"TO\",\n            \"TIMEOUT\",\n            \"SI\",\n            \"SIGNALING\",\n        )\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        status = await self._get_job_status(job)\n        return status in (\n            \"R\",\n            \"RUNNING\",\n            \"PD\",\n            \"PENDING\",\n            \"CG\",\n            \"COMPLETING\",\n            \"S\",\n            \"SUSPENDED\",\n            \"CF\",\n            \"CONFIGURING\",\n            # Job is being held after requested reservation was deleted.\n            \"RD\",\n            \"RESV_DEL_HOLD\",\n            # Job is being requeued by a federation.\n            \"RF\",\n            \"REQUEUE_FED\",\n            # Held job is being requeued.\n            \"RH\",\n            \"REQUEUE_HOLD\",\n            # Completing job is being requeued.\n            \"RQ\",\n            \"REQUEUED\",\n            # Job is about to change size.\n            \"RS\",\n            \"RESIZING\",\n            # Sibling was removed from cluster due to other cluster\n            # starting the job.\n            \"RV\",\n            \"REVOKED\",\n            # The job was requeued in a special state. This state can be set by\n            # users, typically in EpilogSlurmctld, if the job has terminated\n            # with a particular exit value.\n            \"SE\",\n            \"SPECIAL_EXIT\",\n            # Job is staging out files.\n            \"SO\",\n            \"STAGE_OUT\",\n            # Job has an allocation, but execution has been stopped with\n            # SIGSTOP signal. CPUS have been retained by this job.\n            \"ST\",\n            \"STOPPED\",\n        )\n</code></pre>"},{"location":"api/source/xqute.schedulers.ssh_scheduler/","title":"xqute.schedulers.ssh_scheduler","text":""},{"location":"api/source/xqute.schedulers.ssh_scheduler/","title":"SOURCE CODE xqute.schedulers.ssh_scheduler DOCS","text":"<pre><code>from .scheduler import SshScheduler\n</code></pre>"},{"location":"api/source/xqute.schedulers.ssh_scheduler.scheduler/","title":"xqute.schedulers.ssh_scheduler.scheduler","text":""},{"location":"api/source/xqute.schedulers.ssh_scheduler.scheduler/","title":"SOURCE CODE xqute.schedulers.ssh_scheduler.scheduler DOCS","text":"<pre><code>\"\"\"The scheduler to run jobs on SSH\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport shlex\n\nfrom yunpath import CloudPath\n\nfrom ...scheduler import Scheduler\nfrom ...job import Job\n\nfrom .client import SSHClient\n\n\nclass SshScheduler(Scheduler):DOCS\n    \"\"\"The ssh scheduler\n\n    Attributes:\n        name: The name of the scheduler\n        job_class: The job class\n\n    Args:\n        ...: other Scheduler args\n    \"\"\"\n\n    name: str = \"ssh\"\n\n    __slots__ = Scheduler.__slots__ + (\"ssh\", \"servers\")\n\n    def __init__(self, *args, **kwargs):\n        self.ssh = kwargs.pop(\"ssh\", \"ssh\")\n        ssh_servers = kwargs.pop(\"servers\", {})\n        super().__init__(*args, **kwargs)\n        self.servers = {}\n        if isinstance(ssh_servers, (tuple, list)):\n            ssh_servers = {server: {} for server in ssh_servers}\n        for key, val in ssh_servers.items():\n            client = SSHClient(self.ssh, key, **val)\n            self.servers[client.name] = client\n\n        if not self.servers:\n            raise ValueError(\n                \"No ssh_servers defined in config, \"\n                \"please define at least one server\",\n            )\n\n    def __del__(self):\n        for server in self.servers.values():\n            if server.is_connected:\n                server.disconnect()\n\n    async def submit_job(self, job: Job) -&gt; str:DOCS\n        \"\"\"Submit a job to SSH\n\n        Args:\n            job: The job\n\n        Returns:\n            The job id\n        \"\"\"\n        server = list(self.servers.values())[job.index % len(self.servers)]\n        await server.connect()\n\n        rc, stdout, stderr = await server.submit(\n            *shlex.split(self.jobcmd_shebang(job)),\n            self.wrapped_job_script(job).fspath,\n        )\n        if rc != 0:\n            # job.stdout_file.write_bytes(stdout)\n            # job.stderr_file.write_bytes(stderr)\n            raise RuntimeError(f\"Failed to submit job #{job.index}: {stderr.decode()}\")\n        try:\n            pid, srvname = stdout.decode().split(\"@\", 1)\n        except (ValueError, TypeError):  # pragma: no cover\n            raise RuntimeError(\n                f\"Failed to submit job #{job.index}: \"\n                f\"expecting 'pid@server', got {stdout.decode()}\"\n            )\n        else:\n            # wait for a while to make sure the process is running\n            # this is to avoid the real command is not run when proc is recycled\n            # too early\n            # this happens for python &lt; 3.12\n            while not job.stdout_file.exists() and not job.stderr_file.exists():\n                if not await self.servers[srvname].is_running(pid):  # pragma: no cover\n                    # job.stdout_file.write_bytes(stdout)\n                    # job.stderr_file.write_bytes(stderr)\n\n                    raise RuntimeError(\n                        f\"Failed to submit job #{job.index}: {stderr.decode()}\"\n                    )\n\n                if isinstance(job.stdout_file, CloudPath):  # pragma: no cover\n                    await asyncio.sleep(2)\n                else:  # pragma: no cover\n                    await asyncio.sleep(0.1)\n\n        return stdout.decode()\n\n    async def kill_job(self, job: Job):DOCS\n        \"\"\"Kill a job on SSH\n\n        Args:\n            job: The job\n        \"\"\"\n        try:\n            pid, server = str(job.jid).split(\"@\", 1)\n            await self.servers[server].kill(pid)\n        except Exception:  # pragma: no cover\n            pass\n\n    async def job_is_running(self, job: Job) -&gt; bool:DOCS\n        \"\"\"Tell if a job is really running, not only the job.jid_file\n\n        In case where the jid file is not cleaned when job is done.\n\n        Args:\n            job: The job\n\n        Returns:\n            True if it is, otherwise False\n        \"\"\"\n        try:\n            jid = job.jid_file.read_text().strip()\n        except FileNotFoundError:\n            return False\n\n        if not jid:\n            return False\n\n        try:\n            pid, server = jid.split(\"@\", 1)\n        except (ValueError, TypeError):  # pragma: no cover\n            # Can be the jid file by a different scheduler from previous runs\n            return False\n\n        if server not in self.servers:\n            return False\n\n        try:\n            return await self.servers[server].is_running(pid)\n        except Exception:  # pragma: no cover\n            return False\n</code></pre>"},{"location":"api/source/xqute.schedulers.ssh_scheduler.submitter/","title":"xqute.schedulers.ssh_scheduler.submitter","text":""},{"location":"api/source/xqute.schedulers.ssh_scheduler.submitter/","title":"SOURCE CODE xqute.schedulers.ssh_scheduler.submitter DOCS","text":"<pre><code>\"\"\"This script is used to wrap the command for the scheduler to submit and run\n\nIt is used by the ssh scheduler to submit jobs to remote servers\nand print the pid of the job to stdout.\nThe real command is run in a subprocess without waiting for the results.\n\nThe script is executed by the scheduler, not the user. And it's not imported\nby xqute directly.\n\nFind a way to pass envs?\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport subprocess\n\nif __name__ == \"__main__\":\n    server, cwd, *cmds = sys.argv[1:]\n\n    proc = subprocess.Popen(\n        cmds,\n        cwd=cwd,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        preexec_fn=os.setpgrp,\n    )\n    stdout = proc.stdout.read().decode()\n    stderr = proc.stderr.read().decode()\n    sys.stdout.write(f\"{proc.pid}@{server}\")\n    # wait for a while to make sure the process is running\n    time.sleep(0.1)\n    rc = proc.poll()\n    if rc is None or rc == 0:\n        # still running or already finished\n        sys.exit(0)\n    else:  # pragma: no cover\n        sys.stderr.write(f\"STDOUT: {stdout}\\nSTDERR: {stderr}\")\n        sys.exit(rc)\n</code></pre>"},{"location":"api/source/xqute.utils/","title":"xqute.utils","text":""},{"location":"api/source/xqute.utils/","title":"SOURCE CODE xqute.utils DOCS","text":"<pre><code>\"\"\"Utilities for xqute\"\"\"\nfrom __future__ import annotations\n\nimport logging\nfrom typing import Union, Tuple, List\n\nfrom rich.logging import RichHandler\n\nfrom .defaults import LOGGER_NAME\n\nCommandType = Union[str, Tuple[str], List[str]]\n\n\nclass DuplicateFilter(logging.Filter):DOCS\n    def __init__(self):\n        super().__init__()\n        self.prev_msg = None\n\n    def filter(self, record):DOCS\n        message = record.getMessage()\n        if message == self.prev_msg:\n            return False\n        self.prev_msg = message\n        return True\n\n\nlogger = logging.getLogger(LOGGER_NAME)\nlogger.addHandler(RichHandler(show_path=False, omit_repeated_times=False))\nlogger.addFilter(DuplicateFilter())\nlogger.setLevel(logging.INFO)\n</code></pre>"},{"location":"api/source/xqute.xqute/","title":"xqute.xqute","text":""},{"location":"api/source/xqute.xqute/","title":"SOURCE CODE xqute.xqute DOCS","text":"<pre><code>\"\"\"The xqute module\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport functools\nimport signal\nfrom collections import deque\nfrom typing import TYPE_CHECKING, Any, List, Mapping, Type\n\nfrom .defaults import (\n    DEFAULT_WORKDIR,\n    DEFAULT_ERROR_STRATEGY,\n    DEFAULT_NUM_RETRIES,\n    DEFAULT_SCHEDULER_FORKS,\n    DEFAULT_SUBMISSION_BATCH,\n    JobStatus,\n)\nfrom .utils import logger, CommandType\nfrom .plugin import plugin\nfrom .schedulers import get_scheduler\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .path import PathType\n    from .scheduler import Scheduler\n    from .job import Job\n\n\nclass Xqute:DOCS\n    \"\"\"The main class of the package\n\n    Attributes:\n        name: The name, used in logger\n        EMPTY_BUFFER_SLEEP_TIME: The time to sleep while waiting when\n            the buffer is empty to wait for the jobs to be pushed\n\n        jobs: The jobs registry\n        plugins: The plugins to be enabled or disabled\n            to disable a plugin, using `-plugin_name`\n            either all plugin names should be prefixed with '+'/'-' or none\n            of them should\n\n        _cancelling: A mark to mark whether a shutting down event\n            is triggered (True for natural cancelling, the signal for\n            cancelling with a signal, SIGINT for example)\n\n        buffer_queue: A buffer queue to save the pushed jobs\n        queue: The job queue\n        scheduler: The scheduler\n        task: The task of producer and consumers\n\n    Args:\n        scheduler: The scheduler class or name\n        plugins: The plugins to be enabled or disabled\n            to disable a plugin, using `-plugin_name`\n            either all plugin names should be prefixed with '+'/'-' or none\n            of them should\n        workdir: The job meta directory\n        submission_batch: The number of consumers to submit jobs. So that the\n            submission process won't exhaust the local resources\n        error_strategy: The strategy when there is error happened\n        num_retries: Max number of retries when error_strategy is retry\n        forks: Max number of job forks for scheduler\n        scheduler_opts: Additional keyword arguments for scheduler\n    \"\"\"\n\n    name: str = \"Xqute\"\n    EMPTY_BUFFER_SLEEP_TIME: int = 1\n\n    def __init__(\n        self,\n        scheduler: str | Type[Scheduler] = \"local\",\n        *,\n        plugins: List[Any] | None = None,\n        workdir: str | PathType = DEFAULT_WORKDIR,\n        submission_batch: int = DEFAULT_SUBMISSION_BATCH,\n        error_strategy: str = DEFAULT_ERROR_STRATEGY,\n        num_retries: int = DEFAULT_NUM_RETRIES,\n        forks: int = DEFAULT_SCHEDULER_FORKS,\n        scheduler_opts: Mapping[str, Any] | None = None,\n        jobname_prefix: str | None = None,\n    ) -&gt; None:\n        self.jobs: List[Job] = []\n\n        self.plugin_context = plugin.plugins_context(plugins)\n\n        self.plugin_context.__enter__()\n\n        logger.info(\n            \"/%s Enabled plugins: %s\",\n            self.name,\n            plugin.get_enabled_plugin_names(),\n        )\n\n        self._cancelling: bool | signal.Signals = False\n\n        self.buffer_queue: deque = deque()\n        self.queue: asyncio.Queue = asyncio.Queue()\n\n        scheduler_opts = scheduler_opts or {}\n        self.scheduler = get_scheduler(scheduler)(\n            workdir=workdir,\n            forks=forks,\n            error_strategy=error_strategy,\n            num_retries=num_retries,\n            jobname_prefix=jobname_prefix,\n            **scheduler_opts,\n        )\n\n        # requires to be defined in a loop\n        loop = asyncio.get_running_loop()\n        for sig in (signal.SIGTERM, signal.SIGINT):\n            loop.add_signal_handler(sig, functools.partial(self.cancel, sig))\n\n        self.task = asyncio.gather(\n            self._producer(),\n            *(self._consumer(i) for i in range(submission_batch)),\n        )\n        plugin.hooks.on_init(self)\n\n    def cancel(self, sig: signal.Signals | None = None) -&gt; None:DOCS\n        \"\"\"Cancel the producer-consumer task\n\n        `self._cancelling` will be set to `signaled` if sig is provided,\n        otherwise it will be set to `True`\n\n        Args:\n            sig: Whether this cancelling is caused by a signal\n        \"\"\"\n        self._cancelling = True\n        if sig:\n            self._cancelling = sig\n            logger.warning(\n                \"/%s Got signal %r, trying a graceful \" \"shutdown ...\",\n                self.name,\n                sig.name,\n            )\n\n        if plugin.hooks.on_shutdown(self, sig) is not False:\n            self.task.cancel()\n\n    async def _producer(self) -&gt; None:\n        \"\"\"The producer\"\"\"\n        polling_counter = 0\n\n        while True:\n            if not self.buffer_queue:\n                logger.debug(\"/%s Buffer queue is empty, waiting ...\", self.name)\n                await asyncio.sleep(self.EMPTY_BUFFER_SLEEP_TIME)\n                continue\n\n            job = self.buffer_queue.popleft()\n            if not await self.scheduler.polling_jobs(\n                self.jobs,\n                \"submittable\",\n                polling_counter,\n            ):\n                logger.debug(\"/%s Hit max forks of scheduler ...\", self.name)\n                await asyncio.sleep(0.1)\n                self.buffer_queue.appendleft(job)\n                polling_counter += 1\n                continue\n\n            job.status = JobStatus.QUEUED\n            await self.queue.put(job)\n\n    async def _consumer(self, index: int) -&gt; None:\n        \"\"\"The consumer\n\n        Args:\n            index: The index of the consumer\n        \"\"\"\n        while True:\n            job = await self.queue.get()\n            logger.debug(\"/%s 'Consumer-%s' submitting %s\", self.name, index, job)\n            await self.scheduler.submit_job_and_update_status(job)\n            self.queue.task_done()\n\n    async def put(self, cmd: CommandType | Job, envs: dict[str, Any] = None) -&gt; None:DOCS\n        \"\"\"Put a command into the buffer\n\n        Args:\n            cmd: The command\n            envs: The environment variables for the job\n        \"\"\"\n        from .job import Job\n\n        envs = envs or {}\n\n        if isinstance(cmd, Job):\n            job = cmd\n            job.envs.update(envs)\n        else:\n            job = self.scheduler.create_job(len(self.jobs), cmd, envs)\n\n        await plugin.hooks.on_job_init(self.scheduler, job)\n        self.jobs.append(job)\n        logger.info(\"/%s Pushing job: %r\", self.name, job)\n\n        self.buffer_queue.append(job)\n        await plugin.hooks.on_job_queued(self.scheduler, job)\n\n    async def _polling_jobs(self) -&gt; None:\n        \"\"\"Polling the jobs to see if they are all done.\n\n        If yes, cancel the producer-consumer task naturally.\n        \"\"\"\n        polling_counter = 0\n        while self._cancelling is False and not await self.scheduler.polling_jobs(\n            self.jobs,\n            \"all_done\",\n            polling_counter,\n        ):\n            await asyncio.sleep(1.0)\n            polling_counter += 1\n\n        if self._cancelling is False:\n            self.cancel()\n\n    async def _await_task(self) -&gt; None:\n        \"\"\"Await the producer-consumer task and catch the CancelledError\"\"\"\n        try:\n            await self.task\n        except asyncio.CancelledError:\n            logger.debug(\"/%s Stoping producer and consumer ...\", self.name)\n            if self._cancelling not in (True, False):  # signaled\n                await self.scheduler.kill_running_jobs(self.jobs)\n\n        logger.info(\"/%s Done!\", self.name)\n\n    async def run_until_complete(self) -&gt; None:DOCS\n        \"\"\"Wait until all jobs complete\"\"\"\n        logger.debug(\n            \"/%s Done feeding jobs, waiting for jobs to be done ...\", self.name\n        )\n        try:\n            await asyncio.gather(self._polling_jobs(), self._await_task())\n        finally:\n            if self.plugin_context:\n                self.plugin_context.__exit__()\n</code></pre>"}]}